/*
   Copyright 2021 JFrog Ltd

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

extern crate proc_macro;
extern crate quote;
extern crate syn;

use proc_macro::TokenStream;
use proc_macro2::{Ident, Span};
use std::collections::HashSet;

use quote::{format_ident, quote};
use syn::punctuated::Punctuated;
use syn::spanned::Spanned;
use syn::token::{Bracket, Pound};
use syn::{
    parse_macro_input, AttrStyle, Attribute, AttributeArgs, DeriveInput, Field, FieldsNamed,
    Lifetime, Path, PathArguments, PathSegment, Token, Type, TypePath, Visibility,
};

/// Use this macro before a struct to make it a signed struct. That means it will have signed JSON
/// associated with it. A test that shows examples is in the `signed-struct/tests` crate.
///
/// This macro generates additional field(s) to support the signed JSON. The struct implements the
/// `pyrsia_client_lib::Signed` trait that includes methods for signing the struct, verifying the
/// signature(s) (multiple signatures are allowed), getting the JSON and creating a new struct
/// instance from the JSON.
///
/// Signed structs should be in a module by themselves, so that other code cannot directly reference
/// their private fields. The macro issues an error if the struct has any public fields. To access
/// the fields, you should use the getters and setters that the macro generates.
///
/// The derive_builder crate is used to create a build that should be used to create instances of
/// the struct.
///
/// Getters are generated with the signature `fn field(&self) -> &type`.
///
/// Setters are generated as `fn field(&mut self, val: type)`. In addition to setting their field,
/// the setters also call the `clear_json()` method provided by the `Signed` trait. This removes
/// any JSON currently associated with the struct because it is no longer valid after the struct's
/// field has been modified.
///
/// The generated impls and their methods use a lifetime named 'π. This greek letter was chosen
/// because it seems unlikely to conflict with most code.
///
/// To better understand the use of this macro, you should read its test in the
/// `signed-struct/tests` crate.
#[proc_macro_attribute]
pub fn signed_struct(args: TokenStream, input: TokenStream) -> TokenStream {
    /////////////////////////////////////////////////////////////////////////////////////////////
    // To debug this, uncomment the println! macros and the tokens generated by the macros
    // will be output to std out. Since this code is run from the compiler, you will not normally
    // want to see this output. Using the log API is not very convenient for compile time code,
    // so I commented the println! macros
    //
    // If you need to see what these macros expand to, it is normally sufficient to use the
    // cargo expand
    // command. If you are working on this code to modify the macros and they are generating
    // syntactically invalid output, cargo expand will not work. That is the time you need to
    // uncomment the println! macros.
    /////////////////////////////////////////////////////////////////////////////////////////////
    let _ = parse_macro_input!(args as AttributeArgs);
    let mut ast = parse_macro_input!(input as DeriveInput);
    #[allow(clippy::let_and_return)]
    match &mut ast.data {
        syn::Data::Struct(ref mut struct_data) => match &mut struct_data.fields {
            syn::Fields::Named(fields) => {
                match unique_json_field_ident(fields) {
                    Ok(json_field_name) => {
                        let json_field = construct_json_field(&json_field_name);
                        fields.named.push(json_field);
                    }
                    Err(error) => return error.to_compile_error().into(),
                }
                let output = quote! {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[derive(derive_builder::Builder)]
                #[derive(signed_struct::SignedStructDerive)]
                #ast
                }
                .into();
                // println!("Output for signed_struct: {}", output);
                output
            }
            _ => syn::parse::Error::new(
                ast.span(),
                "signed_struct may only be used with structs having named fields.",
            )
            .to_compile_error()
            .into(),
        },
        _ => syn::parse::Error::new(ast.span(), "signed_struct may only be used with structs ")
            .to_compile_error()
            .into(),
    }
}

fn construct_json_field(field_name: &Ident) -> Field {
    let json_fields_named: syn::FieldsNamed = syn::parse2(quote!( {
            #[serde(skip)]
            #[builder(setter(skip))]
            #field_name : Option<String>
        } ))
    .unwrap();
    let json_field: Field = json_fields_named.named.first().unwrap().to_owned();
    json_field
}

// scrutinize and annotate the fields of the struct and return the unique name for the generated JSON field
fn unique_json_field_ident(fields: &mut FieldsNamed) -> Result<Ident, syn::parse::Error> {
    let mut field_names: HashSet<String> = HashSet::new();
    for field in fields.named.iter_mut() {
        ensure_field_is_private(field)?;
        for id in field.ident.iter() {
            field_names.insert(id.to_string());
        }
        if field_type_is_option(field) {
            field.attrs.push(builder_attribute())
        }
        // println!("Field info: {:?}", field);
    }
    let mut counter = 0;
    loop {
        let mut candidate_name = String::from("_json");
        candidate_name.push_str(&counter.to_string());
        if !field_names.contains(candidate_name.as_str()) {
            return Ok(format_ident!("_json{}", counter.to_string()));
        }
        counter += 1;
    }
}

// This just checks for owned types like
// Option<foo>
// It does not recognize
// &Option<foo>
fn field_type_is_option(field: &Field) -> bool {
    if let Type::Path(TypePath {
        path: Path { segments, .. },
        ..
    }) = &field.ty
    {
        if let Some(path_segment) = segments.last() {
            return &path_segment.ident.to_string() == "Option";
        }
    }
    false
}

// return an attribute struct that represents
// #[builder(setter(into, strip_option), default)]
fn builder_attribute() -> Attribute {
    let mut punctuated: Punctuated<PathSegment, Token![::]> = Punctuated::new();
    punctuated.push(PathSegment {
        ident: Ident::new("builder", Span::call_site()),
        arguments: PathArguments::None,
    });
    Attribute {
        pound_token: Pound {
            spans: [Span::call_site()],
        },
        style: AttrStyle::Outer,
        bracket_token: Bracket {
            span: Span::call_site(),
        },
        path: Path {
            leading_colon: None,
            segments: punctuated,
        },
        tokens: quote! {(setter(into, strip_option), default)}.into(),
    }
}

fn ensure_field_is_private(field: &Field) -> Result<(), syn::parse::Error> {
    if field.vis != Visibility::Inherited {
        return Err(syn::parse::Error::new(
            field.span(),
            "signed_struct requires all fields to be private",
        ));
    }
    Ok(())
}

#[proc_macro_derive(SignedStructDerive)]
pub fn signed_struct_derive(input: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(input as DeriveInput);
    let (lifetime, signed_lifetime) = if check_has_lifetime(&ast) {
        (quote!(<'π>), quote!(<'π>))
    } else {
        (quote!(), quote!(<'_>))
    };
    match &ast.data {
        syn::Data::Struct(ref struct_data) => match &struct_data.fields {
            syn::Fields::Named(fields) => {
                #[allow(clippy::let_and_return)]
                match scan_fields(fields) {
                    Ok(ScanFieldsResult {
                        json_field_name,
                        type_vec,
                        field_ident_vec,
                        setter_name_vec,
                    }) => {
                        let struct_ident = &ast.ident;
                        let output = quote! {
                                impl #lifetime ::pyrsia_client_lib::signed::Signed #signed_lifetime for #struct_ident #lifetime {
                                    fn json(&self) -> Option<String> {
                                        self.#json_field_name.to_owned()
                                    }

                                    fn clear_json(&mut self) {
                                        self.#json_field_name = None;
                                    }

                                    fn set_json(&mut self, json: &str) {
                                        self.#json_field_name = Option::Some(json.to_string())
                                    }
                                }

                                impl #lifetime #struct_ident #lifetime {
                                    #(pub fn #field_ident_vec(&self)->&#type_vec{&self.#field_ident_vec}

                                      pub fn #setter_name_vec(&mut self, value: #type_vec){self.clear_json(); self.#field_ident_vec = value}

                                    )*
                                }
                            }
                            .into();
                        // println!("Output from signed_struct_derive: {}", output);
                        output
                    }
                    Err(error) => error.to_compile_error().into(),
                }
            }
            _ => syn::parse::Error::new(
                ast.span(),
                "signed_struct_derive may only be used with structs having named fields.",
            )
            .to_compile_error()
            .into(),
        },
        _ => syn::parse::Error::new(
            ast.span(),
            "signed_struct_derive may only be used with structs ",
        )
        .to_compile_error()
        .into(),
    }
}

fn check_has_lifetime(ast: &DeriveInput) -> bool {
    for generic in ast.generics.params.iter() {
        if let syn::GenericParam::Lifetime(_) = generic {
            return true;
        }
    }
    false
}

struct ScanFieldsResult {
    json_field_name: Ident,
    type_vec: Vec<Type>,
    field_ident_vec: Vec<Ident>,
    setter_name_vec: Vec<Ident>,
}

fn scan_fields(fields: &FieldsNamed) -> Result<ScanFieldsResult, syn::parse::Error> {
    let mut type_vec = Vec::new();
    let mut field_name_vec: Vec<Ident> = Vec::new();
    let mut setter_name_vec: Vec<Ident> = Vec::new();
    for field in fields.named.iter() {
        let param_type = field_type_with_modified_lifetime(field);
        type_vec.push(param_type.clone());
        let field_name = field.ident.clone().unwrap();
        field_name_vec.push(field_name.clone());
        setter_name_vec.push(format_ident!("set_{}", field_name));
    }
    setter_name_vec.pop();
    match type_vec.pop() {
        Some(_) => Ok(ScanFieldsResult {
            json_field_name: field_name_vec.pop().unwrap(),
            type_vec,
            field_ident_vec: field_name_vec,
            setter_name_vec,
        }),
        None => Err(syn::parse::Error::new(
            fields.span(),
            "signed_struct_derive does not work with an empty struct",
        )),
    }
}

fn field_type_with_modified_lifetime(field: &Field) -> Type {
    match field.ty {
        syn::Type::Reference(ref t) => {
            let mut ty = t.clone();
            ty.lifetime = Some(Lifetime::new("'π", Span::call_site()));
            syn::Type::Reference(ty)
        }
        _ => field.ty.clone(),
    }
}
