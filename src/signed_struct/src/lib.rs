/*
   Copyright 2021 JFrog Ltd

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

extern crate proc_macro;
extern crate quote;
extern crate signed;
extern crate syn;

use proc_macro::TokenStream;
use proc_macro2::{Ident, Span};
use std::collections::HashSet;

use quote::{format_ident, quote};
use syn::punctuated::Punctuated;
use syn::spanned::Spanned;
use syn::token::{Bracket, Pound};
use syn::{
    parse_macro_input, AttrStyle, Attribute, AttributeArgs, DeriveInput, Field, FieldsNamed,
    Lifetime, Path, PathArguments, PathSegment, Token, Type, TypePath, Visibility,
};

/// Use this macro before a struct to make it a signed struct. That means it will have signed JSON
/// associated with it. A test that shows examples is in `src/signed_struct/tests/lib.rs
///
/// When you annotate a struct with the #[signed_struct] macro like this:<br>
/// #[signed_struct]
/// `pub struct Namespace {`
/// `    id: String,`
/// `    package_type: PackageTypeName,`
/// `    namespace_path: Vec<String>,`
/// `    administrators: Vec<Vec<u8>>,`
/// `    /// ISO-8601 creation time`
/// `    creation_time: Option<String>,`
/// `    modified_time: Option<String>,`
/// `}`
///
/// you get approximately this:
/// #[derive(derive_builder :: Builder)]  // Generates a NamespaceBuilder struct type to build Namespace instances.
/// `pub struct Namespace {`
/// `    id : String,`
/// `    package_type : PackageTypeName,`
/// `    namespace_path : Vec <String>,`
/// `    administrators : Vec <Vec<u8>>,`
/// `    #[builder(setter(into, strip_option), default)]`
/// `    creation_time : Option <String>,`
/// `    #[builder(setter(into, strip_option), default)]`
/// `    modified_time : Option <String>,`
/// `    #[serde(skip)]`
/// `    #[builder(setter(skip))]`
/// `    _json0 : Option <String>`
/// `}`
/// `impl signed::signed::Signed<'_> for Namespace {`
/// `    fn json(& self) -> Option < String > { self._json0.to_owned() }`
/// `    fn clear_json(& mut self) { self._json0 = None ; }`
/// `    fn set_json(& mut self, json : & str) { self._json0 = Option :: Some(json.to_string()) }`
/// `}`
/// `impl Namespace {`
/// `    pub fn id(& self) -> & String { & self.id }`
/// `    pub fn set_id(& mut self, value : String) { self.clear_json() ; self.id = value }`
/// `    pub fn package_type(& self) -> & PackageTypeName { & self.package_type }`
/// `    pub fn set_package_type(& mut self, value : PackageTypeName) { self.clear_json() ; self.package_type = value }`
/// `    pub fn namespace_path(& self) -> & Vec < String > { & self.namespace_path }`
/// `    pub fn set_namespace_path(& mut self, value : Vec < String >) { self.clear_json() ; self.namespace_path = value }`
/// `    pub fn administrators(& self) -> & Vec < Vec < u8 > > { & self.administrators }`
/// `    pub fn set_administrators(& mut self, value : Vec<Vec<u8>>) { self.clear_json() ; self.administrators = value }`
/// `    pub fn creation_time(& self) -> & Option < String > { & self.creation_time }`
/// `    pub fn set_creation_time(& mut self, value : Option < String >) { self.clear_json() ; self.creation_time = value }`
/// `    pub fn modified_time(& self) -> & Option < String > { & self.modified_time }`
/// `    pub fn set_modified_time(& mut self, value : Option < String >) { self.clear_json() ; self.modified_time = value }`
/// `}`

/////////////////////////////////////////////////////////////////////////////////////////////
// To debug this, uncomment the println! macros and the tokens generated by the macros
// will be output to std out. Since this code is run from the compiler, you will not normally
// want to see this output. Using the log API is not very convenient for compile time code,
// so I commented the println! macros
/////////////////////////////////////////////////////////////////////////////////////////////
#[proc_macro_attribute]
pub fn signed_struct(args: TokenStream, input: TokenStream) -> TokenStream {
    let _ = parse_macro_input!(args as AttributeArgs);
    let mut ast = parse_macro_input!(input as DeriveInput);
    #[allow(clippy::let_and_return)]
    match &mut ast.data {
        syn::Data::Struct(ref mut struct_data) => match &mut struct_data.fields {
            syn::Fields::Named(fields) => {
                match unique_json_field_ident(fields) {
                    Ok(json_field_name) => {
                        let json_field = construct_json_field(&json_field_name);
                        fields.named.push(json_field);
                    }
                    Err(error) => return error.to_compile_error().into(),
                }
                let output = quote! {
                #[derive(serde::Serialize, serde::Deserialize)]
                #[derive(derive_builder::Builder)]
                #[derive(signed_struct::SignedStructDerive)]
                #ast
                }
                .into();
                // Uncomment this println to see the output from the #[signed_struct] macro
                // println!("Output for signed_struct: {}", output);
                output
            }
            _ => syn::parse::Error::new(
                ast.span(),
                "signed_struct may only be used with structs having named fields.",
            )
            .to_compile_error()
            .into(),
        },
        _ => syn::parse::Error::new(ast.span(), "signed_struct may only be used with structs ")
            .to_compile_error()
            .into(),
    }
}

#[allow(unused_variables)]
fn construct_json_field(field_name: &Ident) -> Field {
    let json_fields_named: syn::FieldsNamed = syn::parse2(quote!( {
            #[serde(skip)]
            #[builder(setter(skip))]
            #field_name : Option<String>
        } ))
    .unwrap();
    let json_field: Field = json_fields_named.named.first().unwrap().to_owned();
    json_field
}

// scrutinize and annotate the fields of the struct and return the unique name for the generated JSON field
fn unique_json_field_ident(fields: &mut FieldsNamed) -> Result<Ident, syn::parse::Error> {
    let mut field_names: HashSet<String> = HashSet::new();
    for field in fields.named.iter_mut() {
        ensure_field_is_private(field)?;
        for id in field.ident.iter() {
            field_names.insert(id.to_string());
        }
        if field_type_is_option(field) {
            field.attrs.push(builder_attribute())
        }
        // Uncomment this println to see the ast representation of each field in the struct being processed.
        // println!("Field info: {:?}", field);
    }
    let mut counter = 0;
    loop {
        let mut candidate_name = String::from("_json");
        candidate_name.push_str(&counter.to_string());
        if !field_names.contains(candidate_name.as_str()) {
            return Ok(format_ident!("_json{}", counter.to_string()));
        }
        counter += 1;
    }
}

fn field_type_is_option(field: &Field) -> bool {
    if let Type::Path(TypePath {
        path: Path { segments, .. },
        ..
    }) = &field.ty
    {
        if let Some(path_segment) = segments.last() {
            return &path_segment.ident.to_string() == "Option";
        }
    }
    false
}

// return an attribute struct that represents
// #[builder(setter(into, strip_option), default)]
fn builder_attribute() -> Attribute {
    let mut punctuated: Punctuated<PathSegment, Token![::]> = Punctuated::new();
    punctuated.push(PathSegment {
        ident: Ident::new("builder", Span::call_site()),
        arguments: PathArguments::None,
    });
    Attribute {
        pound_token: Pound {
            spans: [Span::call_site()],
        },
        style: AttrStyle::Outer,
        bracket_token: Bracket {
            span: Span::call_site(),
        },
        path: Path {
            leading_colon: None,
            segments: punctuated,
        },
        tokens: quote! {(setter(into, strip_option), default)},
    }
}

fn ensure_field_is_private(field: &Field) -> Result<(), syn::parse::Error> {
    if field.vis != Visibility::Inherited {
        return Err(syn::parse::Error::new(
            field.span(),
            "signed_struct requires all fields to be private",
        ));
    }
    Ok(())
}

#[proc_macro_derive(SignedStructDerive)]
pub fn signed_struct_derive(input: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(input as DeriveInput);
    let (lifetime, signed_lifetime) = if check_has_lifetime(&ast) {
        (quote!(<'π>), quote!(<'π>))
    } else {
        (quote!(), quote!(<'_>))
    };
    match &ast.data {
        syn::Data::Struct(ref struct_data) => match &struct_data.fields {
            syn::Fields::Named(fields) => {
                #[allow(clippy::let_and_return)]
                match scan_fields(fields) {
                    Ok(ScanFieldsResult {
                        json_field_name,
                        type_vec,
                        field_ident_vec,
                        setter_name_vec,
                    }) => {
                        let struct_ident = &ast.ident;
                        let output = quote! {
                                impl #lifetime signed::signed::Signed #signed_lifetime for #struct_ident #lifetime {
                                    fn json(&self) -> Option<String> {
                                        self.#json_field_name.to_owned()
                                    }

                                    fn clear_json(&mut self) {
                                        self.#json_field_name = None;
                                    }

                                    fn set_json(&mut self, json: &str) {
                                        self.#json_field_name = Option::Some(json.to_string())
                                    }
                                }

                                impl #lifetime #struct_ident #lifetime {
                                    #(pub fn #field_ident_vec(&self)->&#type_vec{&self.#field_ident_vec}

                                      pub fn #setter_name_vec(&mut self, value: #type_vec){self.clear_json(); self.#field_ident_vec = value}

                                    )*
                                }
                            }
                            .into();
                        // Uncomment this println! to see the output from the #[signed_struct_derive] macro.
                        // println!("Output from signed_struct_derive: {}", output);
                        output
                    }
                    Err(error) => error.to_compile_error().into(),
                }
            }
            _ => syn::parse::Error::new(
                ast.span(),
                "signed_struct_derive may only be used with structs having named fields.",
            )
            .to_compile_error()
            .into(),
        },
        _ => syn::parse::Error::new(
            ast.span(),
            "signed_struct_derive may only be used with structs ",
        )
        .to_compile_error()
        .into(),
    }
}

fn check_has_lifetime(ast: &DeriveInput) -> bool {
    for generic in ast.generics.params.iter() {
        if let syn::GenericParam::Lifetime(_) = generic {
            return true;
        }
    }
    false
}

struct ScanFieldsResult {
    json_field_name: Ident,
    type_vec: Vec<Type>,
    field_ident_vec: Vec<Ident>,
    setter_name_vec: Vec<Ident>,
}

fn scan_fields(fields: &FieldsNamed) -> Result<ScanFieldsResult, syn::parse::Error> {
    let mut type_vec = Vec::new();
    let mut field_name_vec: Vec<Ident> = Vec::new();
    let mut setter_name_vec: Vec<Ident> = Vec::new();
    for field in fields.named.iter() {
        let param_type = field_type_with_modified_lifetime(field);
        type_vec.push(param_type.clone());
        let field_name = field.ident.clone().unwrap();
        field_name_vec.push(field_name.clone());
        setter_name_vec.push(format_ident!("set_{}", field_name));
    }
    setter_name_vec.pop();
    match type_vec.pop() {
        Some(_) => Ok(ScanFieldsResult {
            json_field_name: field_name_vec.pop().unwrap(),
            type_vec,
            field_ident_vec: field_name_vec,
            setter_name_vec,
        }),
        None => Err(syn::parse::Error::new(
            fields.span(),
            "signed_struct_derive does not work with an empty struct",
        )),
    }
}

fn field_type_with_modified_lifetime(field: &Field) -> Type {
    match field.ty {
        syn::Type::Reference(ref t) => {
            let mut ty = t.clone();
            ty.lifetime = Some(Lifetime::new("'π", Span::call_site()));
            syn::Type::Reference(ty)
        }
        _ => field.ty.clone(),
    }
}
