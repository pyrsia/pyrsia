<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","joeri","devel","github","tiainen","pyrsia","pyrsia_cli","build.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\nuse anyhow::Result;\nuse vergen::{vergen, Config};\n\nfn main() -\u003e Result\u003c()\u003e {\n    vergen(Config::default())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","pyrsia_cli","src","cli","handlers.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse super::config::*;\nuse super::node::*;\nuse std::collections::HashSet;\nuse std::io;\nuse std::io::BufRead;\n\npub fn config_add() {\n    println!(\"Enter host: \");\n    let mut new_cfg = CliConfig {\n        host: io::stdin().lock().lines().next().unwrap().unwrap(),\n        ..Default::default()\n    };\n\n    println!(\"Enter port: \");\n    new_cfg.port = io::stdin().lock().lines().next().unwrap().unwrap();\n\n    println!(\"Enter disk space to be allocated to pyrsia(Please enter with units ex: 10 GB): \");\n    new_cfg.disk_allocated = io::stdin().lock().lines().next().unwrap().unwrap();\n\n    let result = add_config(new_cfg);\n    match result {\n        Ok(_result) =\u003e {\n            println!(\"Node configuration Saved !!\");\n        }\n        Err(error) =\u003e {\n            println!(\"Error Saving Node Configuration:       {}\", error);\n        }\n    };\n}\n\npub fn config_show() {\n    let result = get_config();\n    match result {\n        Ok(config) =\u003e {\n            println!(\"{}\", config)\n        }\n        Err(error) =\u003e {\n            println!(\"No Node Configured:       {}\", error);\n        }\n    };\n}\n\npub async fn node_ping() {\n    let result = ping().await;\n    match result {\n        Ok(_resp) =\u003e {\n            println!(\"Connection Successful !!\")\n        }\n        Err(error) =\u003e {\n            println!(\"Error: {}\", error);\n        }\n    };\n}\n\npub async fn node_status() {\n    let result = status().await;\n    let _resp = match result {\n        Ok(resp) =\u003e {\n            println!(\"{}\", resp);\n        }\n        Err(error) =\u003e {\n            println!(\"Error: {}\", error);\n        }\n    };\n}\n\npub async fn node_list() {\n    let result = peers_connected().await;\n    let _resp = match result {\n        Ok(resp) =\u003e {\n            println!(\"Connected Peers:\");\n            let peers_split = resp.split(',');\n            let mut unique_peers = HashSet::new();\n            for peer in peers_split {\n                unique_peers.insert(peer);\n            }\n            unique_peers.iter().for_each(|p| println!(\"{}\", p));\n        }\n        Err(error) =\u003e {\n            println!(\"Error: {}\", error);\n        }\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","pyrsia_cli","src","cli","parser.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse clap::{arg, command, crate_version, AppSettings, ArgMatches, Command};\nuse const_format::formatcp;\n\npub fn cli_parser() -\u003e ArgMatches {\n    let version_string: \u0026str = formatcp!(\"{} ({})\", crate_version!(), env!(\"VERGEN_GIT_SHA\"));\n    command!()\n        .arg_required_else_help(true)\n        .global_setting(AppSettings::DeriveDisplayOrder)\n        .propagate_version(false)\n        // Config subcommand\n        .subcommands(vec![\n            Command::new(\"config\")\n                .short_flag('c')\n                .about(\"Pyrsia config commands\")\n                .arg_required_else_help(true)\n                .args(\u0026[\n                    arg!(-a --add      \"Adds a node configuration\"),\n                    arg!(-e --edit     \"Edits a node configuration\"),\n                    arg!(-r --remove   \"Removes the stored node configuration\").visible_alias(\"rm\"),\n                    arg!(-s --show     \"Shows the stored node configuration\"),\n                ]),\n            Command::new(\"list\")\n                .short_flag('l')\n                .about(\"Shows list of connected Peers\"),\n            Command::new(\"ping\").about(\"Pings configured pyrsia node\"),\n            Command::new(\"status\")\n                .short_flag('s')\n                .about(\"Shows node information\"),\n        ])\n        .version(version_string)\n        .get_matches()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","pyrsia_cli","src","cli.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod handlers;\npub mod parser;\n\nuse pyrsia::cli_commands::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","pyrsia_cli","src","main.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod cli;\n\nuse cli::handlers::*;\nuse cli::parser::*;\n\n#[tokio::main]\nasync fn main() {\n    // parsing command line arguments\n    let matches = cli_parser();\n\n    // checking and preparing responses for each command and its arguments if applicable\n\n    match matches.subcommand() {\n        Some((\"config\", config_matches)) =\u003e {\n            if config_matches.is_present(\"add\") || config_matches.is_present(\"edit\") {\n                config_add();\n            }\n            if config_matches.is_present(\"show\") {\n                config_show();\n            }\n        }\n        Some((\"list\", _config_matches)) =\u003e {\n            node_list().await;\n        }\n        Some((\"ping\", _config_matches)) =\u003e {\n            node_ping().await;\n        }\n        Some((\"status\", _config_matches)) =\u003e {\n            node_status().await;\n        }\n        _ =\u003e {} //this should be handled by clap arg_required_else_help\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","pyrsia_node","src","args","parser.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse clap::Parser;\nuse libp2p::Multiaddr;\n\nconst DEFAULT_HOST: \u0026str = \"127.0.0.1\";\nconst DEFAULT_LISTEN_ADDRESS: \u0026str = \"/ip4/0.0.0.0/tcp/0\";\nconst DEFAULT_MAX_PROVIDED_KEYS: \u0026str = \"32768\";\nconst DEFAULT_PORT: \u0026str = \"7888\";\n\n/// Application to connect to and participate in the Pyrsia network\n#[derive(Debug, Parser)]\n#[clap(name = \"Pyrsia Node\")]\npub struct PyrsiaNodeArgs {\n    /// The host address to bind to for the Docker API\n    #[clap(long, short = 'H', default_value = DEFAULT_HOST)]\n    pub host: String,\n    /// The address to listen to for incoming requests from other pyrsia nodes\n    #[clap(long = \"listen\", short = 'L', default_value = DEFAULT_LISTEN_ADDRESS)]\n    pub listen_address: Multiaddr,\n    /// the port to listen to for the Docker API\n    #[clap(long, short, default_value = DEFAULT_PORT)]\n    pub port: String,\n    /// An address to connect with another Pyrsia Node (eg /ip4/127.0.0.1/tcp/45153/p2p/12D3KooWKsHbKbcVgyiRRgeXGCK4bp3MngnSU7ioeKTfQzd18B2v)\n    #[clap(long, short = 'P')]\n    pub peer: Option\u003cMultiaddr\u003e,\n    /// The maximum number of keys that can be provided on the network by this Pyrsia Node.\n    #[clap(long, default_value = DEFAULT_MAX_PROVIDED_KEYS)]\n    pub max_provided_keys: usize,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","pyrsia_node","src","args.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod parser;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","pyrsia_node","src","main.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod args;\npub mod network;\n\nuse anyhow::{bail, Result};\nuse args::parser::PyrsiaNodeArgs;\nuse network::handlers;\nuse pyrsia::artifact_service::storage::ArtifactStorage;\nuse pyrsia::docker::error_util::*;\nuse pyrsia::docker::v2::routes::make_docker_routes;\nuse pyrsia::logging::*;\nuse pyrsia::network::client::Client;\nuse pyrsia::network::p2p;\nuse pyrsia::node_api::routes::make_node_routes;\nuse pyrsia::transparency_log::log::TransparencyLog;\nuse pyrsia::util::keypair_util;\nuse pyrsia_blockchain_network::blockchain::Blockchain;\n\nuse clap::Parser;\nuse futures::lock::Mutex;\nuse futures::StreamExt;\nuse log::{debug, info, warn};\nuse std::error::Error;\nuse std::net::{IpAddr, Ipv4Addr, SocketAddr};\nuse std::sync::Arc;\nuse warp::Filter;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    pretty_env_logger::init();\n\n    debug!(\"Parse CLI arguments\");\n    let args = PyrsiaNodeArgs::parse();\n\n    debug!(\"Create transparency log\");\n    let transparency_log = TransparencyLog::new();\n\n    debug!(\"Create p2p components\");\n    let (p2p_client, mut p2p_events, event_loop) = p2p::setup_libp2p_swarm(args.max_provided_keys)?;\n\n    debug!(\"Create artifact storage\");\n    let artifact_storage = ArtifactStorage::new()?;\n\n    debug!(\"Create blockchain components\");\n    let _blockchain = setup_blockchain()?;\n\n    debug!(\"Start p2p event loop\");\n    tokio::spawn(event_loop.run());\n\n    debug!(\"Setup HTTP server\");\n    setup_http(\n        \u0026args,\n        transparency_log,\n        p2p_client.clone(),\n        artifact_storage.clone(),\n    );\n\n    debug!(\"Start p2p components\");\n    setup_p2p(p2p_client.clone(), args).await;\n\n    debug!(\"Listen for p2p events\");\n    loop {\n        if let Some(event) = p2p_events.next().await {\n            match event {\n                // Reply with the content of the artifact on incoming requests.\n                pyrsia::network::event_loop::PyrsiaEvent::RequestArtifact {\n                    artifact_type,\n                    artifact_hash,\n                    channel,\n                } =\u003e {\n                    if let Err(error) = handlers::handle_request_artifact(\n                        p2p_client.clone(),\n                        artifact_storage.clone(),\n                        \u0026artifact_type,\n                        \u0026artifact_hash,\n                        channel,\n                    )\n                    .await\n                    {\n                        warn!(\n                            \"This node failed to provide artifact with type {} and hash {}. Error: {:?}\",\n                            artifact_type, artifact_hash, error\n                        );\n                    }\n                }\n                pyrsia::network::event_loop::PyrsiaEvent::IdleMetricRequest { channel } =\u003e {\n                    if let Err(error) =\n                        handlers::handle_request_idle_metric(p2p_client.clone(), channel).await\n                    {\n                        warn!(\n                            \"This node failed to provide idle metrics. Error: {:?}\",\n                            error\n                        );\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn setup_http(\n    args: \u0026PyrsiaNodeArgs,\n    transparency_log: TransparencyLog,\n    p2p_client: Client,\n    artifact_storage: ArtifactStorage,\n) {\n    // Get host and port from the settings. Defaults to DEFAULT_HOST and DEFAULT_PORT\n    debug!(\n        \"Pyrsia Docker Node will bind to host = {}, port = {}\",\n        args.host, args.port\n    );\n\n    let address = SocketAddr::new(\n        IpAddr::V4(args.host.parse::\u003cIpv4Addr\u003e().unwrap()),\n        args.port.parse::\u003cu16\u003e().unwrap(),\n    );\n\n    debug!(\"Setup HTTP routing\");\n    let docker_routes = make_docker_routes(\n        transparency_log,\n        p2p_client.clone(),\n        artifact_storage.clone(),\n    );\n    let node_api_routes = make_node_routes(p2p_client, artifact_storage);\n    let all_routes = docker_routes.or(node_api_routes);\n\n    debug!(\"Setup HTTP server\");\n    let (addr, server) = warp::serve(\n        all_routes\n            .and(http::log_headers())\n            .recover(custom_recover)\n            .with(warp::log(\"pyrsia_registry\")),\n    )\n    .bind_ephemeral(address);\n\n    info!(\n        \"Pyrsia Docker Node will start running on {}:{}\",\n        addr.ip(),\n        addr.port()\n    );\n\n    tokio::spawn(server);\n}\n\nasync fn setup_p2p(mut p2p_client: Client, args: PyrsiaNodeArgs) {\n    p2p_client\n        .listen(\u0026args.listen_address)\n        .await\n        .expect(\"Listening should not fail\");\n\n    if let Some(to_dial) = args.peer {\n        handlers::dial_other_peer(p2p_client.clone(), \u0026to_dial).await;\n    }\n}\n\npub fn setup_blockchain() -\u003e Result\u003cArc\u003cMutex\u003cBlockchain\u003e\u003e\u003e {\n    let local_keypair = keypair_util::load_or_generate_ed25519();\n\n    let ed25519_keypair = match local_keypair {\n        libp2p::identity::Keypair::Ed25519(v) =\u003e v,\n        _ =\u003e {\n            bail!(\"Keypair Format Error\");\n        }\n    };\n\n    Ok(Arc::new(Mutex::new(Blockchain::new(\u0026ed25519_keypair))))\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::setup_blockchain;\n\n    #[test]\n    fn setup_blockchain_success() {\n        let blockchain = setup_blockchain();\n        assert!(blockchain.is_ok());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","pyrsia_node","src","network","handlers.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse libp2p::request_response::ResponseChannel;\nuse libp2p::Multiaddr;\nuse log::{debug, info};\nuse pyrsia::artifact_service;\nuse pyrsia::artifact_service::storage::ArtifactStorage;\nuse pyrsia::network::artifact_protocol::ArtifactResponse;\nuse pyrsia::network::client::{ArtifactType, Client};\nuse pyrsia::network::idle_metric_protocol::{IdleMetricResponse, PeerMetrics};\n\n/// Reach out to another node with the specified address\npub async fn dial_other_peer(mut p2p_client: Client, to_dial: \u0026Multiaddr) {\n    p2p_client.dial(to_dial).await.expect(\"Dial to succeed.\");\n    info!(\"Dialed {:?}\", to_dial);\n}\n\n/// Respond to a RequestArtifact event by getting the artifact\n/// based on the provided artifact type and hash.\npub async fn handle_request_artifact(\n    mut p2p_client: Client,\n    artifact_storage: ArtifactStorage,\n    artifact_type: \u0026ArtifactType,\n    artifact_id: \u0026str,\n    channel: ResponseChannel\u003cArtifactResponse\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n    debug!(\n        \"Handling request artifact: {:?}={:?}\",\n        artifact_type, artifact_id\n    );\n    let content = match artifact_type {\n        ArtifactType::Artifact =\u003e get_artifact(artifact_storage, artifact_id)?,\n    };\n\n    p2p_client.respond_artifact(content, channel).await\n}\n\n//Respond to the IdleMetricRequest event\npub async fn handle_request_idle_metric(\n    mut p2p_client: Client,\n    channel: ResponseChannel\u003cIdleMetricResponse\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n    let metric = artifact_service::handlers::get_quality_metric();\n    let peer_metrics: PeerMetrics = PeerMetrics {\n        idle_metric: metric.to_le_bytes(),\n    };\n    p2p_client.respond_idle_metric(peer_metrics, channel).await\n}\n\n/// Get the artifact with the provided hash from the artifact manager.\nfn get_artifact(artifact_storage: ArtifactStorage, artifact_id: \u0026str) -\u003e anyhow::Result\u003cVec\u003cu8\u003e\u003e {\n    artifact_service::handlers::get_artifact_locally(\u0026artifact_storage, artifact_id)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","pyrsia_node","src","network.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod handlers;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","artifact_service","handlers.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::artifact_service::service::{Hash, HashAlgorithm};\nuse crate::artifact_service::storage::ArtifactStorage;\nuse crate::cli_commands::config::get_config;\nuse crate::network::client::{ArtifactType, Client};\nuse crate::transparency_log::log::TransparencyLog;\nuse anyhow::{bail, Context};\nuse byte_unit::Byte;\nuse futures::lock::Mutex;\nuse libp2p::PeerId;\nuse log::{debug, info};\nuse multihash::Hasher;\nuse std::collections::HashMap;\nuse std::fs::File;\nuse std::io::{BufReader, Read};\nuse std::str;\nuse std::sync::Arc;\nuse sysinfo::{NetworkExt, ProcessExt, System, SystemExt};\n\n//TODO: read from CLI config file\npub const ALLOCATED_SPACE_FOR_ARTIFACTS: \u0026str = \"10.84 GB\";\n\n//peer metric constants\nconst CPU_STRESS_WEIGHT: f64 = 2_f64;\nconst NETWORK_STRESS_WEIGHT: f64 = 0.001_f64;\nconst DISK_STRESS_WEIGHT: f64 = 0.001_f64;\n\n//This structure is used as the entries to the quality metrics vector\n//#[derive(Debug, Clone, Copy)]\n\n//get_artifact: given artifact_hash(artifactName) pulls artifact for  artifact_manager and\n//              returns read object to read the bytes of artifact\npub async fn get_artifact(\n    transparency_log: Arc\u003cMutex\u003cTransparencyLog\u003e\u003e,\n    p2p_client: Client,\n    artifact_storage: \u0026ArtifactStorage,\n    namespace_specific_id: \u0026str,\n) -\u003e anyhow::Result\u003cVec\u003cu8\u003e\u003e {\n    let artifact_id = transparency_log\n        .lock()\n        .await\n        .get_artifact(namespace_specific_id)?;\n\n    let blob_content = match get_artifact_locally(artifact_storage, \u0026artifact_id) {\n        Ok(blob_content) =\u003e Ok(blob_content),\n        Err(_) =\u003e get_artifact_from_peers(p2p_client, artifact_storage, \u0026artifact_id).await,\n    }?;\n\n    let mut sha256 = multihash::Sha2_256::default();\n    sha256.update(\u0026blob_content);\n    let calculated_hash = hex::encode(sha256.finalize());\n    transparency_log\n        .lock()\n        .await\n        .verify_artifact(namespace_specific_id, \u0026calculated_hash)?;\n\n    Ok(blob_content)\n}\n\npub fn get_artifact_locally(\n    artifact_storage: \u0026ArtifactStorage,\n    artifact_id: \u0026str,\n) -\u003e Result\u003cVec\u003cu8\u003e, anyhow::Error\u003e {\n    let decoded_hash = hex::decode(artifact_id)?;\n    let hash: Hash = Hash::new(HashAlgorithm::SHA256, \u0026decoded_hash)?;\n    let result = artifact_storage.pull_artifact(\u0026hash)?;\n    let mut buf_reader: BufReader\u003cFile\u003e = BufReader::new(result);\n    let mut blob_content = Vec::new();\n    buf_reader.read_to_end(\u0026mut blob_content)?;\n    Ok(blob_content)\n}\n\nasync fn get_artifact_from_peers(\n    mut p2p_client: Client,\n    artifact_storage: \u0026ArtifactStorage,\n    artifact_id: \u0026str,\n) -\u003e Result\u003cVec\u003cu8\u003e, anyhow::Error\u003e {\n    let providers = p2p_client\n        .list_providers(ArtifactType::Artifact, artifact_id.into())\n        .await?;\n\n    match p2p_client.get_idle_peer(providers).await? {\n        Some(peer) =\u003e {\n            get_artifact_from_peer(p2p_client, artifact_storage, \u0026peer, artifact_id).await\n        }\n        None =\u003e bail!(\n            \"Artifact with id {} is not available on the p2p network.\",\n            artifact_id\n        ),\n    }\n}\n\nasync fn get_artifact_from_peer(\n    mut p2p_client: Client,\n    artifact_storage: \u0026ArtifactStorage,\n    peer_id: \u0026PeerId,\n    artifact_id: \u0026str,\n) -\u003e Result\u003cVec\u003cu8\u003e, anyhow::Error\u003e {\n    let artifact = p2p_client\n        .request_artifact(peer_id, ArtifactType::Artifact, artifact_id.into())\n        .await?;\n\n    let decoded_hash = hex::decode(artifact_id)?;\n    let hash: Hash = Hash::new(HashAlgorithm::SHA256, \u0026decoded_hash)?;\n    let cursor = Box::new(std::io::Cursor::new(artifact));\n    put_artifact(artifact_storage, \u0026hash, cursor)?;\n    get_artifact_locally(artifact_storage, artifact_id)\n}\n\n//put_artifact: given artifact_hash(artifactName) \u0026 artifact_path push artifact to artifact_manager\n//              and returns the boolean as true or false if it was able to create or not\npub fn put_artifact(\n    artifact_storage: \u0026ArtifactStorage,\n    artifact_hash: \u0026Hash,\n    art_reader: Box\u003cdyn Read\u003e,\n) -\u003e Result\u003c(), anyhow::Error\u003e {\n    info!(\"put_artifact hash: {}\", artifact_hash);\n    let mut buf_reader = BufReader::new(art_reader);\n    artifact_storage\n        .push_artifact(\u0026mut buf_reader, artifact_hash)\n        .context(\"Error from put_artifact\")\n}\n\npub fn get_arts_summary(\n    artifact_storage: \u0026ArtifactStorage,\n) -\u003e Result\u003cHashMap\u003cString, usize\u003e, anyhow::Error\u003e {\n    artifact_storage\n        .artifacts_count_bydir()\n        .context(\"Error while getting artifacts count\")\n}\n\npub fn get_space_available(artifact_storage: \u0026ArtifactStorage) -\u003e Result\u003cu64, anyhow::Error\u003e {\n    let disk_used_bytes = artifact_storage.space_used()?;\n\n    let mut available_space: u64 = 0;\n    let cli_config = get_config().context(\"Error getting cli config file\")?;\n\n    let total_allocated_size: u64 = Byte::from_str(cli_config.disk_allocated)\n        .unwrap()\n        .get_bytes();\n\n    if total_allocated_size \u003e disk_used_bytes {\n        available_space = total_allocated_size - disk_used_bytes;\n    }\n    Ok(available_space)\n}\n\npub fn disk_usage(artifact_storage: \u0026ArtifactStorage) -\u003e Result\u003cf64, anyhow::Error\u003e {\n    let disk_used_bytes = artifact_storage.space_used()?;\n    let cli_config = get_config().context(\"Error getting cli config file\")?;\n    let total_allocated_size: u64 = Byte::from_str(cli_config.disk_allocated)\n        .unwrap()\n        .get_bytes();\n    let mut disk_usage: f64 = 0.0;\n    debug!(\"disk_used: {}\", disk_used_bytes);\n    debug!(\"total_allocated_size: {}\", total_allocated_size);\n\n    if total_allocated_size \u003e disk_used_bytes {\n        disk_usage = (disk_used_bytes as f64 / total_allocated_size as f64) * 100_f64;\n    }\n    Ok(disk_usage)\n}\n\n/***************************************************\n * Peer Quality Metrics\n ***************************************************/\n// Get the local stress metric to advertise to peers\npub fn get_quality_metric() -\u003e f64 {\n    let mut qm = get_cpu_stress() * CPU_STRESS_WEIGHT;\n    qm += get_network_stress() * NETWORK_STRESS_WEIGHT;\n    qm + get_disk_stress() * DISK_STRESS_WEIGHT\n}\n\n// This function gets the current CPU load on the system.\nfn get_cpu_stress() -\u003e f64 {\n    let sys = System::new_all();\n    let load_avg = sys.load_average();\n    load_avg.one //using the average over the last 1 minute\n}\n\n//This function gets the current network load on the system\nfn get_network_stress() -\u003e f64 {\n    let mut sys = System::new_all();\n    sys.refresh_networks_list();\n    let networks = sys.networks();\n\n    let mut packets_in = 0;\n    let mut packets_out = 0;\n    for (_interface_name, network) in networks {\n        packets_in += network.received();\n        packets_out += network.transmitted();\n    }\n    (packets_in as f64) + (packets_out as f64)\n    //TODO: add network card capabilities to the metric. cards with \u003e network capacity should get a lower stress number.\n}\n\nfn get_disk_stress() -\u003e f64 {\n    let sys = System::new_all();\n    // Sum up the disk usage measured as total read and writes per process:\n    let mut total_usage = 0_u64;\n    for process in sys.processes().values() {\n        let usage = process.disk_usage();\n        total_usage = total_usage + usage.total_written_bytes + usage.total_read_bytes;\n    }\n    total_usage as f64\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::network::client::command::Command;\n    use crate::network::idle_metric_protocol::PeerMetrics;\n    use crate::util::test_util;\n    use anyhow::Context;\n    use assay::assay;\n    use futures::channel::mpsc;\n    use futures::executor;\n    use futures::prelude::*;\n    use libp2p::identity::Keypair;\n    use sha2::{Digest, Sha256};\n    use std::collections::HashSet;\n    use std::env;\n    use std::fs::File;\n    use std::path::PathBuf;\n\n    const VALID_ARTIFACT_HASH: [u8; 32] = [\n        0x86, 0x5c, 0x8d, 0x98, 0x8b, 0xe4, 0x66, 0x9f, 0x3e, 0x48, 0xf7, 0x3b, 0x98, 0xf9, 0xbc,\n        0x25, 0x7, 0xbe, 0x2, 0x46, 0xea, 0x35, 0xe0, 0x9, 0x8c, 0xf6, 0x5, 0x4d, 0x36, 0x44, 0xc1,\n        0x4f,\n    ];\n    const CPU_THREADS: usize = 200;\n    const NETWORK_THREADS: usize = 10;\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-node\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    #[tokio::test]\n    async fn test_put_and_get_artifact() {\n        let transparency_log = Arc::new(Mutex::new(TransparencyLog::new()));\n        let artifact_storage = ArtifactStorage::new()?;\n\n        let (sender, _) = mpsc::channel(1);\n        let p2p_client = Client {\n            sender,\n            local_peer_id: Keypair::generate_ed25519().public().to_peer_id(),\n        };\n\n        let artifact_id = \"an_artifact_id\";\n        transparency_log\n            .lock()\n            .await\n            .add_artifact(artifact_id, \u0026hex::encode(VALID_ARTIFACT_HASH))?;\n\n        let hash = Hash::new(HashAlgorithm::SHA256, \u0026VALID_ARTIFACT_HASH)?;\n        //put the artifact\n        put_artifact(\u0026artifact_storage, \u0026hash, Box::new(get_file_reader()?))\n            .context(\"Error from put_artifact\")?;\n\n        // pull artifact\n        let future = async {\n            get_artifact(\n                transparency_log,\n                p2p_client,\n                \u0026artifact_storage,\n                \u0026artifact_id,\n            )\n            .await\n            .context(\"Error from get_artifact\")\n        };\n        let file = executor::block_on(future)?;\n\n        //validate pulled artifact with the actual data\n        let mut s = String::new();\n        get_file_reader()?.read_to_string(\u0026mut s)?;\n\n        let s1 = match str::from_utf8(file.as_slice()) {\n            Ok(v) =\u003e v,\n            Err(e) =\u003e panic!(\"Invalid UTF-8 sequence: {}\", e),\n        };\n        assert_eq!(s, s1);\n    }\n\n    #[assay(\n        env = [\n            (\"PYRSIA_ARTIFACT_PATH\", \"PyrsiaTest\"),\n            (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    #[tokio::test]\n    async fn test_get_from_peers() {\n        let artifact_storage = ArtifactStorage::new()?;\n\n        let peer_id = Keypair::generate_ed25519().public().to_peer_id();\n\n        let (sender, mut receiver) = mpsc::channel(1);\n\n        tokio::spawn(async move {\n            loop {\n                match receiver.next().await {\n                    Some(Command::ListProviders { artifact_type: _artifact_type, artifact_hash: _artifact_hash, sender }) =\u003e {\n                        let mut set = HashSet::new();\n                        set.insert(peer_id);\n                        let _ = sender.send(set);\n                    },\n                    Some(Command::RequestIdleMetric { peer: _peer, sender }) =\u003e {\n                        let _ = sender.send(Ok(PeerMetrics {\n                            idle_metric: (0.1_f64).to_le_bytes()\n                        }));\n                    },\n                    Some(Command::RequestArtifact { artifact_type: _artifact_type, artifact_hash: _artifact_hash, peer: _peer, sender }) =\u003e {\n                        let _ = sender.send(Ok(b\"RANDOM\".to_vec()));\n                    },\n                    _ =\u003e panic!(\"Command must match Command::ListProviders, Command::RequestIdleMetric, Command::RequestArtifact\"),\n                }\n            }\n        });\n\n        let p2p_client = Client {\n            sender,\n            local_peer_id: peer_id,\n        };\n\n        let mut hasher = Sha256::new();\n        hasher.update(b\"RANDOM\");\n        let hash_bytes = hasher.finalize();\n        let artifact_id = hex::encode(hash_bytes);\n\n        let result = executor::block_on(async {\n            get_artifact_from_peers(p2p_client, \u0026artifact_storage, \u0026artifact_id).await\n        });\n        assert!(result.is_ok());\n    }\n\n    #[assay(\n        env = [\n            (\"PYRSIA_ARTIFACT_PATH\", \"PyrsiaTest\"),\n            (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    #[tokio::test]\n    async fn test_get_from_peers_with_no_providers() {\n        let artifact_storage = ArtifactStorage::new()?;\n\n        let peer_id = Keypair::generate_ed25519().public().to_peer_id();\n\n        let (sender, mut receiver) = mpsc::channel(1);\n\n        tokio::spawn(async move {\n            futures::select! {\n                command = receiver.next() =\u003e match command {\n                    Some(Command::ListProviders { artifact_type: _artifact_type, artifact_hash: _artifact_hash, sender }) =\u003e {\n                        let _ = sender.send(Default::default());\n                    },\n                    _ =\u003e panic!(\"Command must match Command::ListProviders\"),\n                }\n            }\n        });\n\n        let p2p_client = Client {\n            sender,\n            local_peer_id: peer_id,\n        };\n\n        let mut hasher = Sha256::new();\n        hasher.update(b\"RANDOM\");\n        let hash_bytes = hasher.finalize();\n        let artifact_id = hex::encode(hash_bytes);\n\n        let result = executor::block_on(async {\n            get_artifact_from_peers(p2p_client, \u0026artifact_storage, \u0026artifact_id).await\n        });\n        assert!(result.is_err());\n    }\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"PyrsiaTest\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    fn test_disk_usage() {\n        let artifact_storage = ArtifactStorage::new()?;\n\n        let usage_pct_before = disk_usage(\u0026artifact_storage).context(\"Error from disk_usage\")?;\n\n        create_artifact(\u0026artifact_storage).context(\"Error creating artifact\")?;\n\n        let usage_pct_after = disk_usage(\u0026artifact_storage).context(\"Error from disk_usage\")?;\n        assert!(usage_pct_before \u003c usage_pct_after);\n    }\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"PyrsiaTest\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    fn test_get_space_available() {\n        let artifact_storage = ArtifactStorage::new()?;\n\n        let space_available_before =\n            get_space_available(\u0026artifact_storage).context(\"Error from get_space_available\")?;\n\n        create_artifact(\u0026artifact_storage).context(\"Error creating artifact\")?;\n\n        let space_available_after =\n            get_space_available(\u0026artifact_storage).context(\"Error from get_space_available\")?;\n        debug!(\n            \"Before: {}; After: {}\",\n            space_available_before, space_available_after\n        );\n        assert!(space_available_after \u003c space_available_before);\n    }\n\n    fn get_file_reader() -\u003e Result\u003cFile, anyhow::Error\u003e {\n        // test artifact file in resources/test dir\n        let mut curr_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n        curr_dir.push(\"tests/resources/artifact_test.json\");\n\n        let path = String::from(curr_dir.to_string_lossy());\n        let reader = File::open(path.as_str()).unwrap();\n        Ok(reader)\n    }\n\n    fn create_artifact(artifact_storage: \u0026ArtifactStorage) -\u003e Result\u003c(), anyhow::Error\u003e {\n        let hash = Hash::new(HashAlgorithm::SHA256, \u0026VALID_ARTIFACT_HASH)?;\n        artifact_storage\n            .push_artifact(\u0026mut get_file_reader()?, \u0026hash)\n            .context(\"Error while pushing artifact\")\n    }\n\n    #[test]\n    fn cpu_load_test() {\n        use std::sync::atomic::{AtomicBool, Ordering};\n        use std::sync::Arc;\n        use std::thread;\n        use std::time::Duration;\n\n        let loading = Arc::new(AtomicBool::new(true));\n\n        //first measure of CPU for benchmark\n        let qm = get_cpu_stress() * CPU_STRESS_WEIGHT;\n        assert_ne!(0_f64, qm); //zero should never be returned here\n\n        //set CPU on fire to measure stress\n        let mut threads = vec![];\n        for _i in 0..CPU_THREADS {\n            threads.push(thread::spawn({\n                let mut cpu_fire = 0;\n                let loading_test = loading.clone();\n                move || {\n                    while loading_test.load(Ordering::Relaxed) {\n                        cpu_fire = cpu_fire + 1;\n                    }\n                }\n            }));\n        }\n\n        thread::sleep(Duration::from_millis(200)); //let cpu spin up\n\n        //second measure of CPU\n        let qm2 = get_cpu_stress() * CPU_STRESS_WEIGHT;\n        assert!(qm2 \u003e= qm);\n        loading.store(false, Ordering::Relaxed); //kill threads\n\n        //wait for threads\n        for thread in threads {\n            thread.join().unwrap();\n        }\n        //we could add another measure of CPU did no think it was that important\n    }\n\n    #[test]\n    fn network_load_test() {\n        use std::net::UdpSocket;\n        use std::sync::atomic::{AtomicBool, Ordering};\n        use std::sync::Arc;\n        use std::thread;\n\n        let loading = Arc::new(AtomicBool::new(true));\n\n        //fist measure of network for benchmark\n        let qm = get_network_stress() * NETWORK_STRESS_WEIGHT;\n\n        //shotgun the network with packets\n        let mut threads = vec![];\n        for i in 0..NETWORK_THREADS {\n            threads.push(thread::spawn({\n                let address: String = format_args!(\"127.0.0.1:3425{i}\").to_string();\n                let socket = UdpSocket::bind(address).expect(\"couldn't bind to address\");\n                let loading_test = loading.clone();\n                move || {\n                    while loading_test.load(Ordering::Relaxed) {\n                        socket\n                            .send_to(\u0026[0; 10], \"127.0.0.1:4242\")\n                            .expect(\"couldn't send data\");\n                    }\n                }\n            }));\n        }\n\n        let qm2 = get_network_stress() * NETWORK_STRESS_WEIGHT;\n        assert!(qm2 \u003e qm);\n        loading.store(false, Ordering::Relaxed); //kill threads\n\n        //wait for threads\n        for thread in threads {\n            thread.join().unwrap();\n        }\n        //we could add another measure of network did no think it was that important\n    }\n\n    #[test]\n    fn disk_load_test() {\n        use std::fs;\n        use std::fs::OpenOptions;\n        use std::io::Write;\n        use std::sync::atomic::{AtomicBool, Ordering};\n        use std::sync::Arc;\n        use std::thread;\n        use std::time::Duration;\n\n        let loading = Arc::new(AtomicBool::new(true));\n        let test_file = \"pyrsia_test.txt\";\n\n        // fist measure of network for benchmark\n        let qm = get_disk_stress() * DISK_STRESS_WEIGHT;\n\n        // write some data\n        let write_thread = thread::spawn({\n            let file_data = \"Some test data for the file!\\n\";\n            let except_str = format!(\"Unable to open file {}\", test_file).to_string();\n            let mut f = OpenOptions::new()\n                .append(true)\n                .create(true)\n                .open(test_file)\n                .expect(\u0026except_str);\n            let loading_test = loading.clone();\n            move || {\n                while loading_test.load(Ordering::Relaxed) {\n                    f.write_all(file_data.as_bytes())\n                        .expect(\"Unable to write data\");\n                }\n                drop(f);\n            }\n        });\n\n        thread::sleep(Duration::from_millis(400)); //let writes happen\n\n        // second measure of network\n        let qm2 = get_disk_stress() * DISK_STRESS_WEIGHT;\n        loading.store(false, Ordering::Relaxed); //kill thread\n        write_thread.join().unwrap();\n        fs::remove_file(test_file).unwrap_or_else(|why| {\n            assert!(false, \"{:?}\", why.kind());\n        });\n        assert!(qm2 \u003e qm);\n\n        //we could add another measure of disks did no think it was that important\n    }\n\n    #[test]\n    fn quality_metric_test() {\n        let quality_metric = get_quality_metric();\n        assert!(quality_metric != 0_f64);\n    }\n}\n","traces":[{"line":48,"address":[5649600],"length":1,"stats":{"Line":0},"fn_name":"get_artifact"},{"line":54,"address":[4951079,4950602,4951221,4951313,4950918,4951366,4951560,4951413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[4951344,4951537,4951373,4951590],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[4951783,4951658,4952699,4951832,4952871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[4951861],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[4952372,4952322,4950671,4950756,4952027],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[4953053],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[4953151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[4953255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[4953845,4953484,4953706,4953614,4953323,4954079],"length":1,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[4953909,4954117,4953726],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[4954479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[5649776,5651290],"length":1,"stats":{"Line":0},"fn_name":"get_artifact_locally"},{"line":79,"address":[5649848,5650015],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[5650337,5650305,5649973,5650180,5650100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[5650658,5650283,5650626,5650393,5650508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[5650587],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[5650711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[5650972,5650852,5651131,5651180,5650787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[5651044],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[5651312],"length":1,"stats":{"Line":0},"fn_name":"get_artifact_from_peers"},{"line":93,"address":[4955280,4955513,4955398,4955708,4955929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[4955348,4955415,4955641,4955159,4954967,4955026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[4955953,4955913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[4955041,4955838,4956054,4955114,4956015,4956784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[4956827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[4955056,4956912],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[4956791,4957460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[5651472],"length":1,"stats":{"Line":0},"fn_name":"get_artifact_from_peer"},{"line":114,"address":[4958696,4958302,4958177,4958548,4958414],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[4957985,4958038,4958478,4958319,4958252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[4958680,4958720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[4958651,4959033,4958793,4958961,4958841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[4959089,4959169,4959369,4958924,4959329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[4959262,4959637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[4959838,4959782,4959645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[4959743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[5651648,5652212],"length":1,"stats":{"Line":0},"fn_name":"put_artifact"},{"line":132,"address":[5651683,5651939,5651782,5651855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[5651898],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[5652103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[5652090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[5652240],"length":1,"stats":{"Line":0},"fn_name":"get_arts_summary"},{"line":142,"address":[5652259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[5652320,5653238],"length":1,"stats":{"Line":0},"fn_name":"get_space_available"},{"line":148,"address":[5652335,5652517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[5652493],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[5652905,5652502,5652604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[5652842,5652988,5653058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[5653104,5653179],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[5653154,5653181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[5653109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[5654890,5653344],"length":1,"stats":{"Line":0},"fn_name":"disk_usage"},{"line":164,"address":[5653359,5653548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[5653533,5653638,5653945],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[5654028,5654101,5653882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[5654142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[5654154,5654278,5654377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[5654703,5654336,5654539,5654621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[5654679,5655061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[5654968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[5654925],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[5655152],"length":1,"stats":{"Line":1},"fn_name":"get_quality_metric"},{"line":184,"address":[5655156],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[5655191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[5655232],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[5655401,5655296],"length":1,"stats":{"Line":1},"fn_name":"get_cpu_stress"},{"line":191,"address":[5655303],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[5655314],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[5655338],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[5655440,5656009],"length":1,"stats":{"Line":1},"fn_name":"get_network_stress"},{"line":198,"address":[5655447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[5655458],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[5655474,5655538],"length":1,"stats":{"Line":2},"fn_name":null},{"line":202,"address":[5655546],"length":1,"stats":{"Line":1},"fn_name":null},{"line":203,"address":[5655558],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[5655974,5655792,5655570],"length":1,"stats":{"Line":3},"fn_name":null},{"line":205,"address":[5655904,5655829],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[5655941,5655979,5655888],"length":1,"stats":{"Line":2},"fn_name":null},{"line":208,"address":[5655695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[5656505,5656048],"length":1,"stats":{"Line":1},"fn_name":"get_disk_stress"},{"line":213,"address":[5656055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[5656066],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[5656337,5656177,5656470,5656078],"length":1,"stats":{"Line":4},"fn_name":null},{"line":217,"address":[5656353],"length":1,"stats":{"Line":1},"fn_name":null},{"line":218,"address":[5656475,5656372],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[5656272],"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":[5495775,5489067,5490101,5489109,5489178,5488863,5489936,5494706,5496672,5489590,5489678,5489920,5490184,5496681,5488816,5489797,5489501,5488821,5489895,5490282,5489997,5488848],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":254,"address":[5489888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[5490062],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[5490091,5490260,5490350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[5490399,5490493,5490549,5490629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[5490539,5490690],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[5490791,5490858,5490942],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[5491287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":268,"address":[5491306,5491906,5491606,5491695,5491970,5492068,5491464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":271,"address":[5491718,5491921,5492225,5492030,5492130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[5492503,5492420,5492232],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[5492546,5492397,5492864,5493024,5493350,5492660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[5496170,5495915,5495872,5496096,5496255,5493168],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}"},{"line":281,"address":[5495968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[5495971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":283,"address":[5496055],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[5496059],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[5493516,5493684,5493767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[5493677],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[5493988,5493874,5493794,5494250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[5494793,5494863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[5494926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[5495068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[5495213,5495241,5494982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[5496768,5497032,5497622,5497101,5498104,5496736,5496741,5497513,5499760,5497741,5503177,5496990,5497866,5497931,5496783,5497420,5498008,5497841,5503168,5497888],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":307,"address":[5497834],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[5497972],"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":[5498263,5497996,5498087,5498149,5498198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[5498347,5498176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":315,"address":[5498528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[5499905,5500021,5500085,5502268,5499872,5498599,5498814],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}"},{"line":318,"address":[5502246,5499947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[5500236,5500120,5500034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":320,"address":[5500556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[5500625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[5501572],"length":1,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[5501716,5501856],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[5500838],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[5501223,5500939,5501090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":327,"address":[5501066,5500963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[5500647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[5501494,5500788,5501344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[5500514,5500975],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[5499094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[5499101],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[5499164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[5499303],"length":1,"stats":{"Line":0},"fn_name":null},{"line":348,"address":[5502288,5502588,5499358,5502331,5502786,5502516],"length":1,"stats":{"Line":0},"fn_name":"{async_block#1}"},{"line":349,"address":[5502663,5502813,5502537,5502384,5502766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[5499610,5499685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[5504009,5503232,5508512,5508521,5503237,5504237,5504427,5503916,5504384,5503597,5503486,5504504,5503528,5504118,5504362,5503279,5504337,5504600,5506179,5503264],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":359,"address":[5504330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[5504468],"length":1,"stats":{"Line":1},"fn_name":null},{"line":363,"address":[5504492,5504694,5504645,5504759,5504583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[5504843,5504672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[5505024],"length":1,"stats":{"Line":0},"fn_name":null},{"line":369,"address":[5506494,5506288,5505233,5506422,5507549,5506321,5505095],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}"},{"line":370,"address":[5506646,5507313,5507512,5506443,5506572,5506371,5507074,5506870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":371,"address":[5506569,5506395,5506794,5506896],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[5506949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[5507243,5507137,5507013],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[5507048,5506910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":385,"address":[5505513],"length":1,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[5505520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":387,"address":[5505583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[5505722],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[5505777,5507632,5507932,5507675,5508130,5507860],"length":1,"stats":{"Line":0},"fn_name":"{async_block#1}"},{"line":391,"address":[5507728,5508110,5508157,5508007,5507881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":393,"address":[5506104,5506029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":396,"address":[5509312,5511008,5509344,5510958,5509359,5509629,5509317,5509575,5510989,5511017],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":401,"address":[5510919],"length":1,"stats":{"Line":0},"fn_name":null},{"line":403,"address":[7115712],"length":1,"stats":{"Line":1},"fn_name":"test_disk_usage"},{"line":404,"address":[5509811,5509701,5509891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":406,"address":[5510243,5509788,5509953,5510314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":408,"address":[5510231,5510454,5510525,5510346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":410,"address":[5510892,5510823,5510562,5510437],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[5510926,5510808],"length":1,"stats":{"Line":0},"fn_name":null},{"line":414,"address":[5513264,5511119,5511077,5511335,5511389,5513273,5513238,5511072,5511104,5513207],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":419,"address":[5513168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[7116800],"length":1,"stats":{"Line":1},"fn_name":"test_get_space_available"},{"line":422,"address":[5511651,5511461,5511571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[5512084,5511713,5511548,5512001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[5512245,5512119,5511986,5512328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[5512371,5512656,5512727,5512222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[5512618,5512840,5512932,5512758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":435,"address":[5512898,5513175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":438,"address":[7111168,7111554],"length":1,"stats":{"Line":0},"fn_name":"get_file_reader"},{"line":440,"address":[7111175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":441,"address":[7111198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":443,"address":[7111304,7111231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":444,"address":[7111340,7111436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":445,"address":[7111513],"length":1,"stats":{"Line":0},"fn_name":null},{"line":448,"address":[7111600,7111989],"length":1,"stats":{"Line":0},"fn_name":"create_artifact"},{"line":449,"address":[7111774,7111620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":450,"address":[7112161,7112224,7112045],"length":1,"stats":{"Line":0},"fn_name":null},{"line":451,"address":[7112004,7111757,7111832,7111941,7112057],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[5513328,5513333],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":462,"address":[7117895],"length":1,"stats":{"Line":1},"fn_name":null},{"line":465,"address":[7117953],"length":1,"stats":{"Line":1},"fn_name":null},{"line":466,"address":[7118143,7117993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[7118126],"length":1,"stats":{"Line":1},"fn_name":null},{"line":470,"address":[7118192,7118428,7118330],"length":1,"stats":{"Line":3},"fn_name":null},{"line":471,"address":[7118508],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[7118444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":473,"address":[7118455],"length":1,"stats":{"Line":1},"fn_name":null},{"line":474,"address":[5513360,5513527],"length":1,"stats":{"Line":18},"fn_name":"{closure#0}"},{"line":475,"address":[5513493,5513452,5513373],"length":1,"stats":{"Line":191},"fn_name":null},{"line":476,"address":[5513470,5513495],"length":1,"stats":{"Line":26},"fn_name":null},{"line":482,"address":[7118575,7118409],"length":1,"stats":{"Line":2},"fn_name":null},{"line":485,"address":[7118586],"length":1,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[7118626,7118665],"length":1,"stats":{"Line":1},"fn_name":null},{"line":487,"address":[7118703,7118644],"length":1,"stats":{"Line":2},"fn_name":null},{"line":490,"address":[7119078,7118728],"length":1,"stats":{"Line":1},"fn_name":null},{"line":491,"address":[7118993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[5513557,5513552],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":503,"address":[7119191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":506,"address":[7119252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":509,"address":[7119312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":510,"address":[7119360,7119498,7119588],"length":1,"stats":{"Line":3},"fn_name":null},{"line":511,"address":[7120027,7119940],"length":1,"stats":{"Line":2},"fn_name":null},{"line":512,"address":[7119604],"length":1,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[7119725],"length":1,"stats":{"Line":1},"fn_name":null},{"line":514,"address":[7119881],"length":1,"stats":{"Line":1},"fn_name":null},{"line":515,"address":[5513584,5513822],"length":1,"stats":{"Line":8},"fn_name":"{closure#0}"},{"line":516,"address":[5513679,5513597],"length":1,"stats":{"Line":17},"fn_name":null},{"line":517,"address":[5513700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":525,"address":[7119572,7120051],"length":1,"stats":{"Line":2},"fn_name":null},{"line":526,"address":[7120109,7120072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":527,"address":[7120085,7120146],"length":1,"stats":{"Line":2},"fn_name":null},{"line":530,"address":[7120521,7120171],"length":1,"stats":{"Line":1},"fn_name":null},{"line":531,"address":[7120436],"length":1,"stats":{"Line":1},"fn_name":null},{"line":537,"address":[5513840,5513845],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":546,"address":[7120631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":547,"address":[7120700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":550,"address":[7120727],"length":1,"stats":{"Line":1},"fn_name":null},{"line":553,"address":[7121671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":554,"address":[7120782],"length":1,"stats":{"Line":1},"fn_name":null},{"line":555,"address":[7120901,7120809],"length":1,"stats":{"Line":2},"fn_name":null},{"line":556,"address":[7121182,7121392,7121098,7121475,7121290],"length":1,"stats":{"Line":5},"fn_name":null},{"line":559,"address":[7121274,7121349],"length":1,"stats":{"Line":2},"fn_name":null},{"line":560,"address":[7121365,7121434,7121514,7121482],"length":1,"stats":{"Line":2},"fn_name":null},{"line":561,"address":[7121538,7121490],"length":1,"stats":{"Line":2},"fn_name":null},{"line":562,"address":[5514159,5513872],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":563,"address":[5513881,5513974],"length":1,"stats":{"Line":2},"fn_name":null},{"line":564,"address":[5514083,5514008],"length":1,"stats":{"Line":2},"fn_name":null},{"line":567,"address":[5513985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":571,"address":[7121691],"length":1,"stats":{"Line":1},"fn_name":null},{"line":574,"address":[7121768],"length":1,"stats":{"Line":1},"fn_name":null},{"line":575,"address":[7121814],"length":1,"stats":{"Line":1},"fn_name":null},{"line":576,"address":[7121868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":577,"address":[5514376,5514208],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":578,"address":[5514225,5514308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":580,"address":[7122014,7122051],"length":1,"stats":{"Line":1},"fn_name":null},{"line":586,"address":[5514405,5514400],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":587,"address":[7122132],"length":1,"stats":{"Line":1},"fn_name":null},{"line":588,"address":[7122181,7122155],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":94,"coverable":243},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","artifact_service","service.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse anyhow::anyhow;\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest, Sha256, Sha512};\nuse std::fmt::{Display, Formatter};\nuse strum_macros::{EnumIter, EnumString};\n\n// We will provide implementations of this trait for each hash algorithm that we support.\npub trait Digester {\n    fn update_hash(\u0026mut self, input: \u0026[u8]);\n\n    fn finalize_hash(\u0026mut self, hash_buffer: \u0026mut [u8]);\n\n    fn hash_size_in_bytes(\u0026self) -\u003e usize;\n}\n\nimpl Digester for Sha256 {\n    fn update_hash(\u0026mut self, input: \u0026[u8]) {\n        self.update(input);\n    }\n\n    fn finalize_hash(\u0026mut self, hash_buffer: \u0026mut [u8]) {\n        hash_buffer.clone_from_slice(self.clone().finalize().as_slice());\n    }\n\n    fn hash_size_in_bytes(\u0026self) -\u003e usize {\n        256 / 8\n    }\n}\n\nimpl Digester for Sha512 {\n    fn update_hash(\u0026mut self, input: \u0026[u8]) {\n        self.update(input);\n    }\n\n    fn finalize_hash(\u0026mut self, hash_buffer: \u0026mut [u8]) {\n        hash_buffer.clone_from_slice(self.clone().finalize().as_slice());\n    }\n\n    fn hash_size_in_bytes(\u0026self) -\u003e usize {\n        512 / 8\n    }\n}\n\n/// The types of hash algorithms that the artifact service supports\n#[derive(EnumIter, Clone, Debug, PartialEq, EnumString, Serialize, Deserialize)]\npub enum HashAlgorithm {\n    SHA256,\n    SHA512,\n}\n\nimpl HashAlgorithm {\n    pub fn digest_factory(\u0026self) -\u003e Box\u003cdyn Digester\u003e {\n        match self {\n            HashAlgorithm::SHA256 =\u003e Box::new(Sha256::new()),\n            HashAlgorithm::SHA512 =\u003e Box::new(Sha512::new()),\n        }\n    }\n\n    /// Translate a HashAlgorithm to a string.\n    pub fn hash_algorithm_to_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            HashAlgorithm::SHA256 =\u003e \"SHA256\",\n            HashAlgorithm::SHA512 =\u003e \"SHA512\",\n        }\n    }\n\n    fn hash_length_in_bytes(\u0026self) -\u003e usize {\n        match self {\n            HashAlgorithm::SHA256 =\u003e 256 / 8,\n            HashAlgorithm::SHA512 =\u003e 512 / 8,\n        }\n    }\n}\n\nimpl Display for HashAlgorithm {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.write_str(HashAlgorithm::hash_algorithm_to_str(self))\n    }\n}\n\n#[derive(PartialEq, Debug)]\npub struct Hash {\n    pub algorithm: HashAlgorithm,\n    pub bytes: Vec\u003cu8\u003e,\n}\n\nimpl Hash {\n    pub fn new(algorithm: HashAlgorithm, bytes: \u0026[u8]) -\u003e Result\u003cSelf, anyhow::Error\u003e {\n        let expected_length: usize = algorithm.hash_length_in_bytes();\n        if bytes.len() == expected_length {\n            Ok(Hash {\n                algorithm,\n                bytes: bytes.to_vec(),\n            })\n        } else {\n            Err(anyhow!(format!(\"The hash value does not have the correct length for the algorithm. The expected length is {} bytes, but the length of the supplied hash is {}.\", expected_length, bytes.len())))\n        }\n    }\n}\n\nimpl Display for Hash {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.write_str(\u0026format!(\n            \"{}:{}\",\n            self.algorithm.hash_algorithm_to_str(),\n            hex::encode(\u0026self.bytes)\n        ))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    pub use super::*;\n    use strum::IntoEnumIterator;\n\n    const TEST_ARTIFACT_HASH_256: [u8; 32] = [\n        0x6b, 0x29, 0xf2, 0xf1, 0xe5, 0x02, 0x4c, 0x41, 0x95, 0x06, 0xe9, 0x50, 0x3e, 0x02, 0x4b,\n        0x3d, 0x8a, 0x5a, 0x08, 0xb6, 0xf6, 0xd5, 0x5b, 0x68, 0x88, 0x66, 0x79, 0x52, 0xd1, 0x04,\n        0x15, 0x54,\n    ];\n    const TEST_ARTIFACT_HASH_512: [u8; 64] = [\n        0x6b, 0x29, 0xf2, 0xf1, 0xe5, 0x02, 0x4c, 0x41, 0x95, 0x06, 0xe9, 0x50, 0x3e, 0x02, 0x4b,\n        0x3d, 0x8a, 0x5a, 0x08, 0xb6, 0xf6, 0xd5, 0x5b, 0x68, 0x88, 0x66, 0x79, 0x52, 0xd1, 0x04,\n        0x15, 0x54, 0x83, 0x74, 0x5a, 0xc0, 0x84, 0xfe, 0xf2, 0x12, 0x29, 0xd6, 0x57, 0x2c, 0xd4,\n        0x14, 0xf9, 0xb2, 0xa4, 0x82, 0x06, 0xd6, 0x47, 0x62, 0xc5, 0x26, 0x81, 0x11, 0xd1, 0xc4,\n        0x7a, 0x87, 0x4e, 0x71,\n    ];\n\n    const SHA256_HASH_ENCODED: \u0026str =\n        \"5e6009f8ce7a159884aa5e5132ce8c84fefc979f237a0bce4652f90bc77e5591\";\n    const SHA512_HASH_ENCODED: \u0026str = \"838d2542932c2545f222a4daf74e0e1dc1bd76ce5742b4e3a92aaff2e28b038adf50e0bbdfe6da50ff4fc19f8a23a77ce8fd28a38456b33d43a62b3c86978954\";\n\n    #[test]\n    pub fn test_digester_length() {\n        for algorithm in HashAlgorithm::iter() {\n            let digester = algorithm.digest_factory();\n\n            assert_eq!(\n                digester.hash_size_in_bytes(),\n                algorithm.hash_length_in_bytes()\n            );\n        }\n    }\n\n    #[test]\n    pub fn test_digester_256() {\n        let mut digester = HashAlgorithm::SHA256.digest_factory();\n        digester.update_hash(\u0026TEST_ARTIFACT_HASH_256);\n        let mut hash_buffer = [0; 32];\n        digester.finalize_hash(\u0026mut hash_buffer);\n        assert_eq!(hex::encode(hash_buffer), SHA256_HASH_ENCODED);\n    }\n\n    #[test]\n    pub fn test_digester_512() {\n        let mut digester = HashAlgorithm::SHA512.digest_factory();\n        digester.update_hash(\u0026TEST_ARTIFACT_HASH_256);\n        let mut hash_buffer = [0; 64];\n        digester.finalize_hash(\u0026mut hash_buffer);\n        assert_eq!(hex::encode(hash_buffer), SHA512_HASH_ENCODED);\n    }\n\n    #[test]\n    pub fn test_hash_new() {\n        let hash = Hash::new(HashAlgorithm::SHA256, \u0026TEST_ARTIFACT_HASH_256).unwrap();\n\n        assert_eq!(hash.algorithm, HashAlgorithm::SHA256);\n        assert_eq!(hash.bytes, TEST_ARTIFACT_HASH_256);\n    }\n\n    #[test]\n    pub fn test_hash_256_display() {\n        let hash = Hash::new(HashAlgorithm::SHA256, \u0026TEST_ARTIFACT_HASH_256).unwrap();\n        let display = format!(\"{}\", hash);\n        let to_string = format!(\n            \"{}:{}\",\n            hash.algorithm.hash_algorithm_to_str(),\n            hex::encode(hash.bytes)\n        );\n        assert_eq!(display, to_string);\n    }\n\n    #[test]\n    pub fn test_hash_512_display() {\n        let hash = Hash::new(HashAlgorithm::SHA512, \u0026TEST_ARTIFACT_HASH_512).unwrap();\n        let display = format!(\"{}\", hash);\n        let to_string = format!(\n            \"{}:{}\",\n            hash.algorithm.hash_algorithm_to_str(),\n            hex::encode(hash.bytes)\n        );\n        assert_eq!(display, to_string);\n    }\n\n    #[test]\n    pub fn hash_length_does_not_match_algorithm_test() {\n        assert!(\n            Hash::new(HashAlgorithm::SHA512, \u0026[0u8; 7]).is_err(),\n            \"A 56 bit hash value for SHA512 should be an error\"\n        )\n    }\n}\n","traces":[{"line":33,"address":[6022880],"length":1,"stats":{"Line":1},"fn_name":"update_hash"},{"line":34,"address":[6022898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[6022912],"length":1,"stats":{"Line":1},"fn_name":"finalize_hash"},{"line":38,"address":[6022959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[6023056],"length":1,"stats":{"Line":1},"fn_name":"hash_size_in_bytes"},{"line":47,"address":[6023072],"length":1,"stats":{"Line":1},"fn_name":"update_hash"},{"line":48,"address":[6023090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[6023104],"length":1,"stats":{"Line":1},"fn_name":"finalize_hash"},{"line":52,"address":[6023151],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[6023248],"length":1,"stats":{"Line":1},"fn_name":"hash_size_in_bytes"},{"line":68,"address":[5514432],"length":1,"stats":{"Line":1},"fn_name":"digest_factory"},{"line":69,"address":[5514601,5514447],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[5514460,5514707],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[5514475,5514584],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[5514752],"length":1,"stats":{"Line":1},"fn_name":"hash_algorithm_to_str"},{"line":77,"address":[5514761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[5514774],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[5514796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[5514832],"length":1,"stats":{"Line":1},"fn_name":"hash_length_in_bytes"},{"line":84,"address":[5514841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[5514854],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[5514864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[5514896],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":93,"address":[5514915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[5514976,5515625],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":105,"address":[5515028],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[5515056,5515676],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[5515130],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[5515099],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[5515107],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[5515063,5515640,5515243],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[5515696,5515997],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":119,"address":[5516012,5515754,5515796],"length":1,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[5515729],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[5515783],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[5750853,5750848],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":151,"address":[6199885,6199783],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[6199898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[6200016,6200118],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[6199913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[6199954,6200008],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[5750880,5750885],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":163,"address":[6200199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[6200221],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[6200251],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[6200264],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[6200329],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[5750912,5750917],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":172,"address":[6200615],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[6200637],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[6200667],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[6200690],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[6200755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[5750944,5750949],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":181,"address":[6201079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[6201143,6201364],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[6201278,6201414,6201442],"length":1,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[5750976,5750981],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":189,"address":[6201527],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[6201618,6201741],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[6202325,6202001,6201851],"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[6201800],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[6201941],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[6202448,6202248,6202370],"length":1,"stats":{"Line":2},"fn_name":null},{"line":200,"address":[5751013,5751008],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":201,"address":[6202567],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[6202658,6202781],"length":1,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[6203365,6203041,6202891],"length":1,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[6202840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[6202981],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[6203288,6203410,6203488],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[5751045,5751040],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":213,"address":[6203733,6203660,6203722],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[6203604],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":72,"coverable":74},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","artifact_service","storage.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::artifact_service::service::{Digester, Hash, HashAlgorithm};\nuse crate::util::env_util::read_var;\nuse anyhow::{anyhow, bail, Context, Error, Result};\nuse lazy_static::lazy_static;\nuse log::{debug, error, info, warn};\nuse std::collections::HashMap;\nuse std::ffi::{OsStr, OsString};\nuse std::fs::{File, OpenOptions};\nuse std::io::{BufWriter, Read, Write};\nuse std::panic::UnwindSafe;\nuse std::path::{Path, PathBuf};\nuse strum::IntoEnumIterator;\nuse walkdir::{DirEntry, WalkDir};\n\nconst FILE_EXTENSION: \u0026str = \"file\";\n\nlazy_static! {\n    pub static ref ARTIFACTS_DIR: String = {\n        let pyrsia_artifact_path = read_var(\"PYRSIA_ARTIFACT_PATH\", \"pyrsia\");\n        let dev_mode = read_var(\"DEV_MODE\", \"off\");\n        if dev_mode.to_lowercase() == \"on\" {\n            log_static_initialization_failure(\n                \"Pyrsia Artifact directory\",\n                std::fs::create_dir_all(\u0026pyrsia_artifact_path).with_context(|| {\n                    format!(\n                        \"Failed to create artifact manager directory {:?} in dev mode\",\n                        pyrsia_artifact_path\n                    )\n                }),\n            );\n        }\n        pyrsia_artifact_path\n    };\n}\n\nfn log_static_initialization_failure\u003cT: UnwindSafe\u003e(\n    label: \u0026str,\n    result: Result\u003cT, anyhow::Error\u003e,\n) -\u003e T {\n    let panic_wrapper = std::panic::catch_unwind(|| match result {\n        Ok(unwrapped) =\u003e unwrapped,\n        Err(error) =\u003e {\n            let msg = format!(\"Error initializing {}, error is: {}\", label, error);\n            error!(\"{}\", msg);\n            panic!(\"{}\", msg)\n        }\n    });\n    match panic_wrapper {\n        Ok(normal) =\u003e normal,\n        Err(partially_unwound_panic) =\u003e {\n            error!(\"Initialization of {} panicked!\", label);\n            std::panic::resume_unwind(partially_unwound_panic)\n        }\n    }\n}\n\nfn encode_bytes_as_file_name(bytes: \u0026[u8]) -\u003e String {\n    hex::encode(bytes)\n}\n\n// The base file path (no extension on the file name) that will correspond to this hash.\n// The structure of the path is\n// repo_root_dir/hash_algorithm/hash\n// This consists of the artifact repository root directory, a directory whose name is the\n// algorithm used to compute the hash and a file name that is the hash, encoded as hex\n// (base64 is more compact, but hex is easier for troubleshooting). For example\n// pyrsia-artifacts/SHA256/680fade3184f20557aa2bbf4432386eb79836902a1e5aea1ff077e323e6cab34\n// TODO To support nodes that will store many files, we need a scheme that will start separating files by subdirectories under the hash algorithm directory based on the first n bytes of the hash value.\nfn base_file_path(hash: \u0026Hash, repo_dir: \u0026Path) -\u003e PathBuf {\n    let mut buffer: PathBuf = PathBuf::from(repo_dir);\n    buffer.push(hash.algorithm.hash_algorithm_to_str());\n    buffer.push(encode_bytes_as_file_name(\u0026hash.bytes));\n    buffer\n}\n\n// It is possible, though unlikely, for SHA512, SHA3_512 and BLAKE3 to generate the same\n// hash for different content. Separating files by algorithm avoids this type of collision.\n// This function ensures that there is a directory under the repository root for each one of\n// the supported hash algorithms.\nfn ensure_directories_for_hash_algorithms_exist(\n    repository_path: \u0026Path,\n) -\u003e Result\u003c(), anyhow::Error\u003e {\n    let mut path_buf = PathBuf::new();\n    path_buf.push(repository_path);\n    for algorithm in HashAlgorithm::iter() {\n        ensure_subdirectory_exists(\u0026path_buf, algorithm)?;\n    }\n    Ok(())\n}\n\nfn ensure_subdirectory_exists(\n    path_buf: \u0026Path,\n    algorithm: HashAlgorithm,\n) -\u003e Result\u003c(), anyhow::Error\u003e {\n    let mut this_buf = path_buf.to_path_buf();\n    this_buf.push(algorithm.hash_algorithm_to_str());\n    info!(\n        \"Creating directory {}\",\n        this_buf\n            .as_os_str()\n            .to_str()\n            .unwrap_or(\"*** Unable to convert artifact directory path to UTF-8!\")\n    );\n    std::fs::create_dir_all(this_buf.as_os_str())\n        .with_context(|| format!(\"Error creating directory {}\", this_buf.display()))?;\n    Ok(())\n}\n\n// This is a decorator for the Write trait that allows the bytes written by the writer to be\n// used to compute a hash\nstruct WriteHashDecorator\u003c'a\u003e {\n    writer: \u0026'a mut dyn Write,\n    digester: \u0026'a mut Box\u003cdyn Digester\u003e,\n}\n\nimpl\u003c'a\u003e WriteHashDecorator\u003c'a\u003e {\n    fn new(writer: \u0026'a mut impl Write, digester: \u0026'a mut Box\u003cdyn Digester\u003e) -\u003e Self {\n        WriteHashDecorator { writer, digester }\n    }\n}\n\n// Decorator logic is supplied only for the methods that we expect to be called by io::copy\nimpl\u003c'a\u003e Write for WriteHashDecorator\u003c'a\u003e {\n    fn write(\u0026mut self, buf: \u0026[u8]) -\u003e std::io::Result\u003cusize\u003e {\n        let bytes_written = self.writer.write(buf)?;\n        self.digester.update_hash(\u0026buf[..bytes_written]);\n        Ok(bytes_written)\n    }\n\n    fn flush(\u0026mut self) -\u003e std::io::Result\u003c()\u003e {\n        self.writer.flush()\n    }\n\n    fn write_all(\u0026mut self, buf: \u0026[u8]) -\u003e std::io::Result\u003c()\u003e {\n        if self.writer.write(buf).is_ok() {\n            self.digester.update_hash(buf)\n        }\n        Ok(())\n    }\n}\n\n#[derive(Clone)]\npub struct ArtifactStorage {}\n\nimpl ArtifactStorage {\n    pub fn new() -\u003e Result\u003cArtifactStorage, anyhow::Error\u003e {\n        let absolute_path = get_repository_path()?;\n        if is_accessible_directory(\u0026absolute_path) {\n            ensure_directories_for_hash_algorithms_exist(\u0026absolute_path)?;\n\n            Ok(ArtifactStorage {})\n        } else {\n            error!(\n                \"Unable to create ArtifactManager with inaccessible directory: {}\",\n                ARTIFACTS_DIR.as_str()\n            );\n            Err(anyhow!(\n                \"Not an accessible directory: {}\",\n                ARTIFACTS_DIR.as_str()\n            ))\n        }\n    }\n\n    pub fn artifacts_count_bydir(\u0026self) -\u003e Result\u003cHashMap\u003cString, usize\u003e, Error\u003e {\n        let mut dirs_map: HashMap\u003cString, usize\u003e = HashMap::new();\n\n        let repository_path = get_repository_path()?;\n        for file in WalkDir::new(repository_path)\n            .into_iter()\n            .filter_entry(is_directory_or_artifact_file)\n            .filter_map(|file| file.ok())\n        {\n            let path = file.path().display().to_string();\n\n            let dir_1 = match path.rfind('/') {\n                Some(x) =\u003e \u0026path[0..x],\n                None =\u003e \"\",\n            };\n\n            if !dir_1.is_empty() {\n                let len = dir_1.len();\n                if let Some(x) = dir_1.rfind('/') {\n                    *dirs_map.entry(dir_1[x + 1..len].to_string()).or_insert(0) += 1;\n                }\n            }\n        }\n        Ok(dirs_map)\n    }\n\n    /// Calculate the repository size by recursively adding size of each directory inside it.\n    /// Returns the size\n    pub fn space_used(\u0026self) -\u003e Result\u003cu64, Error\u003e {\n        let repository_path = get_repository_path()?;\n        fs_extra::dir::get_size(repository_path.as_os_str())\n            .context(\"Error while calculating the size of artifact manager\")\n    }\n\n    fn file_path_for_new_artifact(\u0026self, expected_hash: \u0026Hash) -\u003e std::io::Result\u003cPathBuf\u003e {\n        let repository_path = get_repository_path()?;\n        let mut base_path: PathBuf = base_file_path(expected_hash, \u0026repository_path);\n        // for now all artifacts are unstructured\n        base_path.set_extension(FILE_EXTENSION);\n        Ok(base_path)\n    }\n\n    /// Push an artifact to this node's local repository.\n    /// Parameters are:\n    /// * reader — An object that this method will use to read the bytes of the artifact being\n    ///            pushed.\n    /// * expected_hash — The hash value that the pushed artifact is expected to have.\n    /// Returns true if it created the artifact local or false if the artifact already existed.\n    pub fn push_artifact(\n        \u0026self,\n        reader: \u0026mut impl Read,\n        expected_hash: \u0026Hash,\n    ) -\u003e Result\u003c(), anyhow::Error\u003e {\n        info!(\n            \"An artifact is being pushed to the artifact manager {}\",\n            expected_hash\n        );\n        let base_path = self.file_path_for_new_artifact(expected_hash)?;\n        debug!(\"Pushing artifact to {}\", base_path.display());\n        // Write to a temporary name that won't be mistaken for a valid file. If the hash checks out, rename it to the base name; otherwise delete it.\n        let tmp_path = tmp_path_from_base(\u0026base_path);\n\n        let out = create_artifact_file(\u0026tmp_path)?;\n        debug!(\"hash is {}\", expected_hash);\n        let mut hash_buffer = [0; HASH_BUFFER_SIZE];\n        let actual_hash = \u0026*do_push(reader, expected_hash, \u0026tmp_path, out, \u0026mut hash_buffer)?;\n        if actual_hash == expected_hash.bytes {\n            rename_to_permanent(expected_hash, \u0026base_path, \u0026tmp_path)\n        } else {\n            handle_wrong_hash(expected_hash, tmp_path, actual_hash)\n        }\n    }\n\n    /// Pull an artifact. The current implementation only looks in the local node's repository.\n    pub fn pull_artifact(\u0026self, hash: \u0026Hash) -\u003e Result\u003cFile, anyhow::Error\u003e {\n        info!(\n            \"An artifact is being pulled from the artifact manager {}\",\n            hash\n        );\n        let repository_path = get_repository_path()?;\n        let mut base_path: PathBuf = base_file_path(hash, \u0026repository_path);\n        // for now all artifacts are unstructured\n        base_path.set_extension(FILE_EXTENSION);\n        debug!(\"Pulling artifact from {}\", base_path.display());\n        File::open(base_path.as_path())\n            .with_context(|| format!(\"{} not found.\", base_path.display()))\n    }\n}\n\nfn get_repository_path() -\u003e std::io::Result\u003cPathBuf\u003e {\n    PathBuf::from(ARTIFACTS_DIR.as_str()).canonicalize()\n}\n\n// return true if the given repository path leads to an accessible directory.\nfn is_accessible_directory(repository_path: \u0026Path) -\u003e bool {\n    match std::fs::metadata(repository_path) {\n        Err(_) =\u003e false,\n        Ok(metadata) =\u003e metadata.is_dir(),\n    }\n}\n\n// Return a temporary file name to use for the file until we have verified that the hash is correct.\n// The temporary file name is guaranteed to be as unique as the hash and not to be mistaken for a\n// file whose name is its has code.\n//\n// The reason for doing this is so that a file whose actual hash is not equal to the expected\n// hash will not be found in the local repository from the time it is created and not fully\n// written until the time its hash is verified. After that, the file is renamed to its permanent\n// name that will match the actual hash value.\nfn tmp_path_from_base(base: \u0026Path) -\u003e PathBuf {\n    let mut tmp_buf = base.to_path_buf();\n    let file_name: \u0026OsStr = base.file_name().unwrap();\n    tmp_buf.set_file_name(format!(\"l0-{}\", file_name.to_str().unwrap()));\n    tmp_buf\n}\n\nfn is_directory_or_artifact_file(entry: \u0026DirEntry) -\u003e bool {\n    let not_hidden = entry\n        .file_name()\n        .to_str()\n        .map(|s| entry.depth() == 0 || !s.starts_with('.'))\n        .unwrap_or(false);\n    not_hidden\n        \u0026\u0026 (entry.file_type().is_dir()\n            || entry\n                .path()\n                .extension()\n                .map(|extension| extension == OsString::from(FILE_EXTENSION).as_os_str())\n                .unwrap_or(false))\n}\n\nfn create_artifact_file(tmp_path: \u0026Path) -\u003e std::io::Result\u003cFile\u003e {\n    OpenOptions::new()\n        .write(true)\n        .create_new(true)\n        .open(tmp_path)\n}\n\nfn handle_wrong_hash(\n    expected_hash: \u0026Hash,\n    tmp_path: PathBuf,\n    actual_hash: \u0026[u8],\n) -\u003e Result\u003c(), Error\u003e {\n    std::fs::remove_file(tmp_path.clone()).with_context(|| {\n        format!(\n            \"Attempted to remove {} because its content has the wrong hash.\",\n            tmp_path.to_str().unwrap()\n        )\n    })?;\n    let msg = format!(\"Contents of artifact did not have the expected hash value of {}. The actual hash was {}:{}\",\n                      expected_hash, expected_hash.algorithm, hex::encode(actual_hash));\n    warn!(\"{}\", msg);\n    bail!(\"{}\", msg)\n}\n\nfn rename_to_permanent(\n    expected_hash: \u0026Hash,\n    base_path: \u0026Path,\n    tmp_path: \u0026Path,\n) -\u003e Result\u003c(), anyhow::Error\u003e {\n    std::fs::rename(tmp_path, base_path).with_context(|| {\n        format!(\n            \"Attempting to rename from temporary file name{} to permanent{}\",\n            tmp_path.to_str().unwrap(),\n            base_path.to_str().unwrap()\n        )\n    })?;\n    debug!(\n        \"Artifact has the expected hash available locally {}\",\n        expected_hash\n    );\n    Ok(())\n}\n\nfn do_push\u003c'b\u003e(\n    reader: \u0026mut impl Read,\n    expected_hash: \u0026Hash,\n    path: \u0026Path,\n    out: File,\n    hash_buffer: \u0026'b mut [u8; HASH_BUFFER_SIZE],\n) -\u003e Result\u003c\u0026'b [u8], Error\u003e {\n    let mut buf_writer: BufWriter\u003cFile\u003e = BufWriter::new(out);\n    let mut digester = expected_hash.algorithm.digest_factory();\n    let mut writer = WriteHashDecorator::new(\u0026mut buf_writer, \u0026mut digester);\n\n    copy_from_reader_to_writer(reader, path, \u0026mut writer)\n        .with_context(|| format!(\"Error writing contents of {}\", expected_hash))?;\n    Ok(actual_hash(hash_buffer, \u0026mut digester))\n}\n\nconst HASH_BUFFER_SIZE: usize = 128;\n\nfn actual_hash\u003c'b\u003e(\n    hash_buffer: \u0026'b mut [u8; HASH_BUFFER_SIZE],\n    digester: \u0026mut Box\u003cdyn Digester\u003e,\n) -\u003e \u0026'b mut [u8] {\n    let buffer_slice: \u0026mut [u8] = \u0026mut hash_buffer[..digester.hash_size_in_bytes()];\n    digester.finalize_hash(buffer_slice);\n    buffer_slice\n}\n\nfn copy_from_reader_to_writer(\n    reader: \u0026mut impl Read,\n    path: \u0026Path,\n    mut writer: \u0026mut impl Write,\n) -\u003e Result\u003c(), Error\u003e {\n    std::io::copy(reader, \u0026mut writer).with_context(|| {\n        format!(\n            \"Error while copying artifact contents to {}\",\n            path.display()\n        )\n    })?;\n    writer.flush().with_context(|| {\n        format!(\n            \"Error while flushing last of artifact contents to {}\",\n            path.display()\n        )\n    })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::util::test_util;\n    use assay::assay;\n    use sha2::{Digest, Sha256};\n    use std::path::PathBuf;\n    use stringreader::StringReader;\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-node\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    pub fn new_artifact_storage_with_valid_directory() {\n        ArtifactStorage::new().expect(\"ArtifactStorage should be created.\");\n\n        let repository_path = get_repository_path()?;\n        let mut sha256_path = repository_path.clone();\n        sha256_path.push(HashAlgorithm::SHA256.hash_algorithm_to_str());\n        let meta256 = std::fs::metadata(sha256_path.as_path())\n            .expect(format!(\"unable to get metadata for {}\", sha256_path.display()).as_str());\n        assert!(meta256.is_dir());\n\n        let mut sha512_path = repository_path.clone();\n        sha512_path.push(HashAlgorithm::SHA512.hash_algorithm_to_str());\n        let meta512 = std::fs::metadata(sha512_path.as_path())\n            .expect(format!(\"unable to get metadata for {}\", sha512_path.display()).as_str());\n        assert!(meta512.is_dir());\n        std::fs::remove_dir_all(repository_path.as_path()).expect(\u0026format!(\n            \"unable to remove temp directory {}\",\n            repository_path.display()\n        ));\n    }\n\n    const TEST_ARTIFACT_DATA: \u0026str = \"Incumbent nonsense text, sesquipedalian and obfuscatory. Exhortations to the mother lode. Dendrites for all.\";\n    const TEST_ARTIFACT_HASH: [u8; 32] = [\n        0x6b, 0x29, 0xf2, 0xf1, 0xe5, 0x02, 0x4c, 0x41, 0x95, 0x06, 0xe9, 0x50, 0x3e, 0x02, 0x4b,\n        0x3d, 0x8a, 0x5a, 0x08, 0xb6, 0xf6, 0xd5, 0x5b, 0x68, 0x88, 0x66, 0x79, 0x52, 0xd1, 0x04,\n        0x15, 0x54,\n    ];\n    const WRONG_ARTIFACT_HASH: [u8; 32] = [\n        0x2d, 0x8c, 0x2f, 0x6d, 0x97, 0x8c, 0xa2, 0x17, 0x12, 0xb5, 0xf6, 0xde, 0x36, 0xc9, 0xd3,\n        0x1f, 0xa8, 0xe9, 0x6a, 0x4f, 0xa5, 0xd8, 0xff, 0x8b, 0x01, 0x88, 0xdf, 0xb9, 0xe7, 0xc1,\n        0x71, 0xbb,\n    ];\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-bogus-path\"),\n          (\"DEV_MODE\", \"off\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    pub fn new_artifact_storage_with_bad_directory() {\n        if let Ok(_) = ArtifactStorage::new() {\n            panic!(\"new should have returned an error because of an invalid directory\");\n        }\n    }\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-node\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    pub fn push_artifact_then_pull_it() {\n        let mut string_reader = StringReader::new(TEST_ARTIFACT_DATA);\n        let hash = Hash::new(HashAlgorithm::SHA256, \u0026TEST_ARTIFACT_HASH)?;\n        let artifact_storage = ArtifactStorage::new().expect(\"Error creating ArtifactManager\");\n\n        // Check the space before pushing artifact\n        let space_before = artifact_storage\n            .space_used()\n            .context(\"Error getting space used by ArtifactManager\")?;\n        assert_eq!(0, space_before);\n\n        artifact_storage\n            .push_artifact(\u0026mut string_reader, \u0026hash)\n            .context(\"Error from push_artifact\")?;\n\n        let mut repository_path = get_repository_path()?;\n        check_artifact_is_written_correctly(\u0026mut repository_path)?;\n\n        // Currently the space_used method does not include the size of directories in the directory tree, so this is how we obtain an independent result to check it.\n        let size_of_files_in_directory_tree = fs_extra::dir::get_size(\u0026repository_path)?;\n        // Check the space used after pushing artifact\n        let space_after = artifact_storage\n            .space_used()\n            .context(\"Error getting space used by ArtifactManager\")?;\n        assert_eq!(\n            size_of_files_in_directory_tree, space_after,\n            \"expect correct result from space_used\"\n        );\n\n        check_able_to_pull_artifact(\u0026hash, \u0026artifact_storage)?;\n    }\n\n    fn check_artifact_is_written_correctly(dir_name: \u0026mut PathBuf) -\u003e Result\u003c()\u003e {\n        dir_name.push(\"SHA256\");\n        dir_name.push(encode_bytes_as_file_name(\u0026TEST_ARTIFACT_HASH));\n        dir_name.set_extension(FILE_EXTENSION);\n        let content_vec = std::fs::read(dir_name.as_path()).context(\"reading pushed file\")?;\n        assert_eq!(content_vec.as_slice(), TEST_ARTIFACT_DATA.as_bytes());\n\n        Ok(())\n    }\n\n    fn check_able_to_pull_artifact(hash: \u0026Hash, artifact_storage: \u0026ArtifactStorage) -\u003e Result\u003c()\u003e {\n        let mut reader = artifact_storage\n            .pull_artifact(\u0026hash)\n            .context(\"Error from pull_artifact\")?;\n        let mut read_buffer = String::new();\n        reader.read_to_string(\u0026mut read_buffer)?;\n        assert_eq!(TEST_ARTIFACT_DATA, read_buffer);\n\n        Ok(())\n    }\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-node\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    pub fn push_wrong_hash_test() {\n        let mut string_reader = StringReader::new(TEST_ARTIFACT_DATA);\n        let hash = Hash::new(HashAlgorithm::SHA256, \u0026WRONG_ARTIFACT_HASH)?;\n        let artifact_storage = ArtifactStorage::new().expect(\"Error creating ArtifactManager\");\n        artifact_storage\n            .push_artifact(\u0026mut string_reader, \u0026hash)\n            .expect_err(\"push_artifact should have returned an error because of the wrong hash\");\n    }\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-node\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    pub fn pull_nonexistent_test() {\n        let hash = Hash::new(HashAlgorithm::SHA256, \u0026WRONG_ARTIFACT_HASH)?;\n        let artifact_storage = ArtifactStorage::new().expect(\"Error creating ArtifactManager\");\n        artifact_storage\n            .pull_artifact(\u0026hash)\n            .expect_err(\"pull_artifact should have failed with nonexistent hash\");\n    }\n\n    #[test]\n    pub fn test_write_hash_decorator() -\u003e anyhow::Result\u003c()\u003e {\n        let mut writer = Vec::new();\n        let mut digester = HashAlgorithm::SHA256.digest_factory();\n        let mut decorator = WriteHashDecorator::new(\u0026mut writer, \u0026mut digester);\n\n        let data = b\"sample_string\";\n        decorator.write(data)?;\n\n        let mut hash_bytes = [0; 32];\n        let mut hasher = Sha256::new();\n        hasher.update(\u0026data);\n\n        digester.finalize_hash(\u0026mut hash_bytes);\n        assert_eq!(hasher.finalize()[..], hash_bytes);\n\n        Ok(())\n    }\n}\n","traces":[{"line":35,"address":[6954068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[6954114],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[6954156,6954275,6954224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[6954433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[4606000],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":41,"address":[4606032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[6954357],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[4590304,4590840],"length":1,"stats":{"Line":0},"fn_name":"log_static_initialization_failure\u003c()\u003e"},{"line":56,"address":[4590897,4590329,4590880,4591604],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003c()\u003e"},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[4590927],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[4591063,4590937],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[4591193,4591282,4591358,4591441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[4591416],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[4590377],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[4590407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[4590435,4590594,4590681,4590518],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[4590649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[5773552],"length":1,"stats":{"Line":0},"fn_name":"encode_bytes_as_file_name"},{"line":74,"address":[5773573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[5773600,5773832],"length":1,"stats":{"Line":0},"fn_name":"base_file_path"},{"line":86,"address":[5773666],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[5773677],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[5773761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[5774332,5773856],"length":1,"stats":{"Line":0},"fn_name":"ensure_directories_for_hash_algorithms_exist"},{"line":99,"address":[5773889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[5773909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[5774111,5773925,5774242,5773990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[5774305,5774134,5774247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[5774086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[5775361,5774368],"length":1,"stats":{"Line":0},"fn_name":"ensure_subdirectory_exists"},{"line":111,"address":[5774408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[5774430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[5774926,5774674,5774529],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[5774780],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[5774746,5775103,5775286,5775163],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[4591670,4591632],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":122,"address":[5775242],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[4591872,4591824],"length":1,"stats":{"Line":1},"fn_name":"new\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":140,"address":[5775392],"length":1,"stats":{"Line":1},"fn_name":"write"},{"line":141,"address":[5775666,5775438],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[5775610,5775777],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[5775784],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[5775808],"length":1,"stats":{"Line":0},"fn_name":"flush"},{"line":147,"address":[5775820],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[5775856,5775998],"length":1,"stats":{"Line":0},"fn_name":"write_all"},{"line":151,"address":[5775893,5776014],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[5776054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[5776020],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[5776080,5777315],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":163,"address":[5776087,5776236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[5776213,5776560,5777310,5776306,5776368],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[5776629,5776426,5776562],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[5776548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[5776764,5776911,5776682,5776374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[5776844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[5777120],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[5776822,5777077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[5777344,5779187],"length":1,"stats":{"Line":0},"fn_name":"artifacts_count_bydir"},{"line":181,"address":[5777375],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[5777405,5777645,5777480,5777699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[5777826,5777742,5779052,5777574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[4591950,4591920],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":189,"address":[5778057,5778188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[5778235,5778351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[5778415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[5778386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[5778525],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[5778584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[5778995,5778625],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[5779000,5778724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[5779084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[5779633,5779216],"length":1,"stats":{"Line":0},"fn_name":"space_used"},{"line":209,"address":[5779353,5779231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[5779523,5779336,5779450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[5780095,5779648],"length":1,"stats":{"Line":0},"fn_name":"file_path_for_new_artifact"},{"line":215,"address":[5779686,5779807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[5779870,5779785],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[5779915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[5779947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[4592000,4594771,4594800,4597571,4597600,4600371],"length":1,"stats":{"Line":0},"fn_name":"push_artifact\u003cstd::io::buffered::bufreader::BufReader\u003calloc::boxed::Box\u003cdyn std::io::Read, alloc::alloc::Global\u003e\u003e\u003e"},{"line":233,"address":[4595065,4597865,4592265,4592047,4594969,4594847,4597769,4592169,4597647],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[4592425,4595039,4595371,4595225,4592571,4598171,4592239,4598025,4597839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[4595432,4595570,4595479,4598279,4592632,4598476,4598370,4595676,4598232,4592876,4595330,4598130,4592679,4592530,4592770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[4598442,4595967,4595642,4592842,4593167,4598767],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[4593309,4596320,4596109,4598790,4595990,4598909,4593576,4599120,4596376,4593520,4593190,4599176],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[4599079,4599378,4596279,4599240,4596440,4596487,4599572,4593778,4596772,4596578,4593972,4593479,4599287,4593640,4593687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[4596642,4599442,4593842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[4593914,4597115,4594153,4594315,4599753,4599968,4597168,4594368,4599915,4596714,4599514,4596953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[4594288,4600026,4597088,4594426,4597226,4599888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[4594519,4597319,4600119],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[4600277,4597232,4594677,4594432,4597477,4600032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[5780112,5781545],"length":1,"stats":{"Line":0},"fn_name":"pull_artifact"},{"line":255,"address":[5780321,5780135,5780241],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[5780303,5780481,5780633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[5780767,5780586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[5780815],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[5780928,5781010,5781104,5780842],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[5781424,5781076,5781345],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[4600438,4600400],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":269,"address":[5781726,5781568],"length":1,"stats":{"Line":0},"fn_name":"get_repository_path"},{"line":270,"address":[5781582],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[5781925,5781760],"length":1,"stats":{"Line":0},"fn_name":"is_accessible_directory"},{"line":275,"address":[5781789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[5781866],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[5781816,5781885],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[5781984,5782424],"length":1,"stats":{"Line":0},"fn_name":"tmp_path_from_base"},{"line":290,"address":[5782030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[5782046,5782149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[5782165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[5782448],"length":1,"stats":{"Line":0},"fn_name":"is_directory_or_artifact_file"},{"line":297,"address":[5782465,5782526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[4600592,4600621],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":302,"address":[5782572,5782656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[5782651,5782593,5782736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[5782633,5782678],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[4600718,4600704],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":311,"address":[5782768],"length":1,"stats":{"Line":0},"fn_name":"create_artifact_file"},{"line":312,"address":[5782792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[5782944,5784349],"length":1,"stats":{"Line":0},"fn_name":"handle_wrong_hash"},{"line":323,"address":[4600880],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":324,"address":[4601000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[4600918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[5783747,5783352,5783444,5783201],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[5783437],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[5784005,5783839,5783709,5783915,5783792],"length":1,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[5784176,5783973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[5784384],"length":1,"stats":{"Line":0},"fn_name":"rename_to_permanent"},{"line":340,"address":[4601120],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":341,"address":[4601206,4601300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[4601142],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[4601235],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[5784738,5784678,5784808,5784591],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[5784794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[4603283,4602688,4601440,4602659,4602064,4602035],"length":1,"stats":{"Line":0},"fn_name":"do_push\u003cstringreader::StringReader\u003e"},{"line":361,"address":[4601533,4602781,4602157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[4601547,4602171,4602795],"length":1,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[4602871,4601623,4602247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[4602318,4601891,4603009,4603139,4602515,4602942,4601761,4602385,4601694],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[4602544,4601920,4601753,4603344,4603001,4603123,4603312,4603440,4603472,4602499,4603600,4603168,4602377,4601875,4603568],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003cstringreader::StringReader\u003e"},{"line":367,"address":[4601853,4601989,4602477,4603101,4603237,4602613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[5784960],"length":1,"stats":{"Line":0},"fn_name":"actual_hash"},{"line":376,"address":[5784984],"length":1,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[5785067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[4604464,4603696,4604080],"length":1,"stats":{"Line":0},"fn_name":"copy_from_reader_to_writer\u003cstringreader::StringReader, pyrsia::artifact_service::storage::WriteHashDecorator\u003e"},{"line":386,"address":[4604515,4604769,4604848,4605040,4604131,4605232,4604001,4604385,4603747],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003cstd::io::buffered::bufreader::BufReader\u003calloc::boxed::Box\u003cdyn std::io::Read, alloc::alloc::Global\u003e\u003e, pyrsia::artifact_service::storage::WriteHashDecorator\u003e"},{"line":387,"address":[4604925,4605117,4605309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[4605291,4604907,4605099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[4605616,4604739,4604816,4604432,4605424,4605808,4604355,4604048,4603971],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}\u003cstd::fs::File, pyrsia::artifact_service::storage::WriteHashDecorator\u003e"},{"line":393,"address":[4605885,4605501,4605693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[4605483,4605675,4605867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[4537551,4538133,4537646,4537210,4537243,4537943,4537936,4537501,4537322,4538058,4537774,4537744,4537760,4537095,4537869],"length":1,"stats":{"Line":11},"fn_name":"modify"},{"line":414,"address":[6222138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[4537088],"length":1,"stats":{"Line":1},"fn_name":"new_artifact_storage_with_valid_directory"},{"line":417,"address":[6219741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[6219798,6219938,6220035],"length":1,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[6219931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[6220062,6220149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[6220214,6220635],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[6220673,6220288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[6220831,6220769],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[6220824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[6220863],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[6220977,6221374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[6221051,6221412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[6221508,6221566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[6221549,6221609,6221765],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[6221654,6221749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[4539024,4538957,4539221,4539146,4538589,4538183,4538298,4538331,4538734,4538410,4538639,4538848,4539031,4538832,4538862],"length":1,"stats":{"Line":11},"fn_name":"modify"},{"line":454,"address":[6222702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[4538176],"length":1,"stats":{"Line":1},"fn_name":"new_artifact_storage_with_bad_directory"},{"line":457,"address":[6222597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[6222734,6222648],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[4539727,4539677,4539920,4540234,4539936,4540112,4539950,4540045,4539386,4539822,4540119,4539419,4539271,4539498,4540309],"length":1,"stats":{"Line":11},"fn_name":"modify"},{"line":467,"address":[6227085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[4539264],"length":1,"stats":{"Line":1},"fn_name":"push_artifact_then_pull_it"},{"line":470,"address":[6223285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[6223356,6223600,6223520],"length":1,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[6223654,6223505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[6223728,6224148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[6224299,6224032],"length":1,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[6224970,6224844,6224281],"length":1,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[6224947,6225064,6225197,6225280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[6225182,6225383,6225315,6225442,6225522],"length":1,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[6225671,6225587,6225874,6225432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[6225645,6225917,6226299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[6226182,6226424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[6226409,6227043,6226974,6226901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[4536147,4535456],"length":1,"stats":{"Line":0},"fn_name":"check_artifact_is_written_correctly"},{"line":502,"address":[4535476],"length":1,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[4535494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[4535536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[4535558,4535756],"length":1,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[4535730,4535953,4536101,4535814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[4536067],"length":1,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[4537065,4536176],"length":1,"stats":{"Line":0},"fn_name":"check_able_to_pull_artifact"},{"line":512,"address":[4536214,4536463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[4536209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[4536443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[4536697,4536912,4536495,4536577,4536848],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[4536764,4536959,4537003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[4536965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[4541024,4540586,4541200,4540815,4540359,4541008,4541397,4540765,4541322,4540474,4540507,4541133,4541207,4540910,4541038],"length":1,"stats":{"Line":11},"fn_name":"modify"},{"line":527,"address":[6228091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[4540352],"length":1,"stats":{"Line":1},"fn_name":"push_wrong_hash_test"},{"line":530,"address":[6227578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[6227798,6227637,6227874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[6227786,6227906],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[6227996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[4542112,4541447,4542288,4542295,4542410,4541903,4542485,4541674,4542096,4541595,4541853,4542221,4541998,4542126,4541562],"length":1,"stats":{"Line":11},"fn_name":"modify"},{"line":543,"address":[6229060],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[4541440],"length":1,"stats":{"Line":1},"fn_name":"pull_nonexistent_test"},{"line":546,"address":[6228795,6228558,6228719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[6228827,6228707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[6228909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[4542528,4543587],"length":1,"stats":{"Line":3},"fn_name":"test_write_hash_decorator"},{"line":555,"address":[4542535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":556,"address":[4542549],"length":1,"stats":{"Line":1},"fn_name":null},{"line":557,"address":[4542623],"length":1,"stats":{"Line":1},"fn_name":null},{"line":559,"address":[4542671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[4542686,4542951,4542771,4543014],"length":1,"stats":{"Line":2},"fn_name":null},{"line":562,"address":[4542917],"length":1,"stats":{"Line":1},"fn_name":null},{"line":563,"address":[4542944],"length":1,"stats":{"Line":1},"fn_name":null},{"line":564,"address":[4543087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":566,"address":[4543094],"length":1,"stats":{"Line":1},"fn_name":null},{"line":567,"address":[4543522,4543322,4543131],"length":1,"stats":{"Line":2},"fn_name":null},{"line":569,"address":[4543480],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":27,"coverable":229},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","artifact_service.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod handlers;\npub mod service;\npub mod storage;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","examples","simple_node.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse clap::Parser;\nuse dirs;\nuse futures::channel::{mpsc as futures_mpsc, oneshot};\nuse futures::StreamExt;\nuse libp2p::{identity, PeerId};\nuse log::{debug, info};\nuse std::{\n    error::Error,\n    fs,\n    io::{Read, Write},\n    os::unix::fs::OpenOptionsExt,\n    sync::{Arc, Mutex},\n};\nuse tokio::io;\n\n// use pyrsia_blockchain_network::blockchain::Blockchain;\nuse pyrsia_blockchain_network::args::parser::BlockchainNodeArgs;\nuse pyrsia_blockchain_network::crypto::hash_algorithm::HashDigest;\nuse pyrsia_blockchain_network::identities::{\n    authority_pen::AuthorityPen, authority_verifier::AuthorityVerifier, key_box::KeyBox,\n};\nuse pyrsia_blockchain_network::network::{Network, Spawner};\nuse pyrsia_blockchain_network::providers::{DataProvider, DataStore, FinalizationProvider};\nuse pyrsia_blockchain_network::structures::block::Block;\nuse pyrsia_blockchain_network::{\n    default_config, gen_chain_config, run_blockchain, run_session, NodeIndex,\n};\n\nconst TXS_PER_BLOCK: usize = 50000;\nconst TX_SIZE: usize = 300;\nconst BLOCK_TIME_MS: u128 = 500;\nconst INITIAL_DELAY_MS: u128 = 5000;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    pretty_env_logger::init();\n\n    let args = BlockchainNodeArgs::parse();\n\n    let key_path = get_keyfile_name(args.clone());\n\n    // If the key file exists, load the key pair. Otherwise, create a random keypair and save to the keypair file\n    let id_keys = create_ed25519_keypair(key_path);\n    let ed25519_pair = identity::Keypair::Ed25519(id_keys.clone());\n    let _peer_id = PeerId::from(ed25519_pair.public());\n\n    info!(\"Getting network up!\");\n    let n_members = 3;\n    let my_node_ix = NodeIndex(args.peer_index);\n\n    let pen = AuthorityPen::new(my_node_ix, id_keys.clone());\n    let verifier = AuthorityVerifier::new();\n\n    let keybox = KeyBox::new(pen, verifier);\n\n    let (authority_to_verifier, mut authority_from_network) = futures_mpsc::unbounded();\n    let (close_verifier, mut exit) = oneshot::channel();\n    tokio::spawn(async move {\n        loop {\n            futures::select! {\n                maybe_auth = authority_from_network.next() =\u003e {\n                    if let Some((_node_ix, _public_key)) = maybe_auth {\n                        // record_authority(node_ix, public_key);\n                    }\n                }\n               _ = \u0026mut exit  =\u003e break,\n            }\n        }\n    });\n\n    let (\n        network,\n        mut manager,\n        block_from_data_io_tx,\n        block_from_network_rx,\n        message_for_network,\n        message_from_network,\n    ) = Network::new(\n        my_node_ix,\n        id_keys.clone(),\n        Default::default(), // peers_by_index,\n        authority_to_verifier,\n    )\n    .await\n    .expect(\"Libp2p network set-up should succeed.\");\n    // Make the \"genesis\" blocks\n    let current_block: Arc\u003cMutex\u003cBlock\u003e\u003e = Arc::new(Mutex::new(Block::new(\n        HashDigest::new(b\"\"),\n        0,\n        vec![],\n        \u0026id_keys,\n    )));\n\n    let data_provider = DataProvider::new(current_block.clone()); // TODO(prince-chrismc): Blend this into blockchain API???\n    let (finalization_provider, mut finalized_rx) = FinalizationProvider::new();\n    let data_store = DataStore::new(current_block.clone(), message_for_network);\n\n    let (close_network, exit) = oneshot::channel();\n    tokio::spawn(async move { manager.run(exit).await });\n\n    let data_size: usize = TXS_PER_BLOCK * TX_SIZE;\n    let chain_config = gen_chain_config(\n        my_node_ix,\n        n_members,\n        data_size,\n        BLOCK_TIME_MS,\n        INITIAL_DELAY_MS,\n    );\n    let (close_chain, exit) = oneshot::channel();\n    tokio::spawn(async move {\n        run_blockchain(\n            chain_config,\n            data_store,\n            current_block,\n            block_from_network_rx,\n            block_from_data_io_tx,\n            message_from_network,\n            exit,\n        )\n        .await\n    });\n\n    let (close_member, exit) = oneshot::channel();\n    tokio::spawn(async move {\n        let config = default_config(n_members.into(), my_node_ix, 0);\n        run_session(\n            config,\n            network,\n            data_provider,\n            finalization_provider,\n            keybox,\n            Spawner {},\n            exit,\n        )\n        .await\n    });\n\n    let mut max_block_finalized = 0;\n    while let Some(block_num) = finalized_rx.next().await {\n        if max_block_finalized \u003c block_num.header.ordinal {\n            max_block_finalized = block_num.header.ordinal;\n        }\n        debug!(\n            \"🌟 Got new batch. Highest finalized = {:?}\",\n            max_block_finalized\n        );\n        if max_block_finalized \u003e= 100 as u128 {\n            break;\n        }\n    }\n    close_member.send(()).expect(\"should send\");\n    close_chain.send(()).expect(\"should send\");\n    close_network.send(()).expect(\"should send\");\n    close_verifier.send(()).expect(\"should send\");\n    Ok(())\n}\n\npub fn write_block(path: \u0026str, block: Block) {\n    let mut file = fs::OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(path)\n        .expect(\"cannot open file\");\n\n    file.write_all(serde_json::to_string(\u0026block).unwrap().as_bytes())\n        .expect(\"write failed\");\n    file.write_all(b\"\\n\").expect(\"write failed\");\n}\n\npub fn write_keypair(path: \u0026String, data: \u0026[u8; 64]) {\n    let mut file = fs::OpenOptions::new()\n        .write(true)\n        .create(true)\n        .mode(0o600)\n        .open(path)\n        .expect(\"cannot open file\");\n\n    file.write_all(data).expect(\"write failed\");\n}\n\npub fn read_keypair(path: \u0026String) -\u003e Result\u003c[u8; 64], Box\u003cdyn Error\u003e\u003e {\n    let mut file = std::fs::File::open(path)?;\n    let mut buf = [0u8; 64];\n    let n = file.read(\u0026mut buf)?;\n    if n == 64 {\n        Ok(buf)\n    } else {\n        Err(Box::new(io::Error::from(io::ErrorKind::InvalidData)))\n    }\n}\n\npub fn get_keyfile_name(args: BlockchainNodeArgs) -\u003e String {\n    let mut path = dirs::home_dir().unwrap();\n    path.push(args.key_filename);\n    let filepath = path.into_os_string().into_string().unwrap();\n    filepath\n}\n\npub fn create_ed25519_keypair(filename: String) -\u003e libp2p::identity::ed25519::Keypair {\n    match read_keypair(\u0026filename) {\n        Ok(v) =\u003e {\n            let data: \u0026mut [u8] = \u0026mut v.clone();\n            debug!(\"Load Keypair from {:?}\", filename);\n            libp2p::identity::ed25519::Keypair::decode(data).unwrap()\n        }\n        Err(_) =\u003e {\n            let id_keys = identity::ed25519::Keypair::generate();\n\n            let data = id_keys.encode();\n            debug!(\"Create Keypair\");\n            write_keypair(\u0026filename, \u0026data);\n            id_keys\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use pyrsia_blockchain_network::args::parser::DEFAULT_BLOCK_KEYPAIR_FILENAME;\n    const TEST_KEYPAIR_FILENAME: \u0026str = \"./test_keypair\";\n    #[test]\n    fn test_get_keyfile_name_succeeded() {\n        let mut path = dirs::home_dir().unwrap();\n\n        path.push(DEFAULT_BLOCK_KEYPAIR_FILENAME);\n        let args = BlockchainNodeArgs {\n            key_filename: DEFAULT_BLOCK_KEYPAIR_FILENAME.to_string(),\n            peer_index: 0,\n        };\n        assert_eq!(\n            path.into_os_string().into_string().unwrap(),\n            get_keyfile_name(args)\n        );\n    }\n\n    #[test]\n    fn test_write_keypair_succeeded() {\n        let file = String::from(TEST_KEYPAIR_FILENAME);\n        let data = [0u8; 64];\n        let result = std::panic::catch_unwind(|| write_keypair(\u0026file, \u0026data));\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_read_keypair_succeeded() {\n        let file = String::from(TEST_KEYPAIR_FILENAME);\n        let data = [0u8; 64];\n        write_keypair(\u0026file, \u0026data);\n        assert!(read_keypair(\u0026file).is_ok());\n    }\n\n    #[test]\n    fn test_create_keypair_succeeded() {\n        let args = BlockchainNodeArgs {\n            key_filename: DEFAULT_BLOCK_KEYPAIR_FILENAME.to_string(),\n            peer_index: 0,\n        };\n        let result = std::panic::catch_unwind(|| create_ed25519_keypair(args));\n        assert!(result.is_ok());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","args","parser.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse clap::Parser;\n\npub const DEFAULT_BLOCK_KEYPAIR_FILENAME: \u0026str = \".block_keypair\";\n\n/// Application to connect to and participate in the Pyrsia blockchain network\n#[derive(Debug, Parser, Clone)]\n#[clap(long_about = None)]\npub struct BlockchainNodeArgs {\n    /// A string to specify the keypair filename\n    #[clap(long, short = 'K', default_value = DEFAULT_BLOCK_KEYPAIR_FILENAME)]\n    pub key_filename: String,\n    /// An unsigned number to specify the node index on Aleph algorithm.\n    #[clap(long, short = 'I', required = true)]\n    pub peer_index: usize,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","args.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod parser;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","blockchain.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse libp2p::identity;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fmt::{self, Debug, Formatter};\n\nuse super::crypto::hash_algorithm::HashDigest;\nuse super::structures::{\n    block::Block,\n    chain::Chain,\n    header::Address,\n    transaction::{Transaction, TransactionType},\n};\n\n/// Define Supported Signature Algorithm\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum SignatureAlgorithm {\n    Ed25519,\n}\n\npub struct Blockchain {\n    // this should actually be a Map\u003cTransaction,Vec\u003cOnTransactionSettled\u003e\u003e but that's later\n    trans_observers: HashMap\u003cTransaction, Box\u003cdyn FnOnce(Transaction)\u003e\u003e,\n    block_observers: Vec\u003cBox\u003cdyn FnMut(Block)\u003e\u003e,\n    chain: Chain,\n}\n\nimpl Debug for Blockchain {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_struct(\"Blockchain\")\n            .field(\"chain\", \u0026self.chain)\n            .field(\"trans_observers\", \u0026self.trans_observers.len())\n            .field(\"block_observers\", \u0026self.block_observers.len())\n            .finish()\n    }\n}\n\nimpl Blockchain {\n    pub fn new(keypair: \u0026identity::ed25519::Keypair) -\u003e Self {\n        let local_id = Address::from(identity::PublicKey::Ed25519(keypair.public()));\n        let transaction = Transaction::new(\n            TransactionType::AddAuthority,\n            local_id,\n            \"this needs to be the root authority\".as_bytes().to_vec(),\n            keypair,\n        );\n        // Make the \"genesis\" blocks\n        let block = Block::new(HashDigest::new(b\"\"), 0, Vec::from([transaction]), keypair);\n        let mut chain: Chain = Default::default();\n        chain.blocks.push(block);\n        Self {\n            trans_observers: Default::default(),\n            block_observers: vec![],\n            chain,\n        }\n    }\n\n    pub fn blocks(\u0026self) -\u003e Vec\u003cBlock\u003e {\n        self.chain.blocks.clone()\n    }\n\n    pub fn submit_transaction\u003cCallBack: 'static + FnOnce(Transaction)\u003e(\n        \u0026mut self,\n        trans: Transaction,\n        on_done: CallBack,\n    ) -\u003e \u0026mut Self {\n        self.trans_observers.insert(trans, Box::new(on_done));\n        self\n    }\n\n    pub fn notify_transaction_settled(\u0026mut self, trans: Transaction) {\n        // if there were no observers, we don't care\n        if let Some(on_settled) = self.trans_observers.remove(\u0026trans) {\n            on_settled(trans)\n        }\n    }\n\n    pub fn add_block_listener\u003cCallBack: 'static + FnMut(Block)\u003e(\n        \u0026mut self,\n        on_block: CallBack,\n    ) -\u003e \u0026mut Self {\n        self.block_observers.push(Box::new(on_block));\n        self\n    }\n\n    pub fn notify_block_event(\u0026mut self, block: Block) -\u003e \u0026mut Self {\n        self.block_observers\n            .iter_mut()\n            .for_each(|notify| notify(block.clone()));\n        self\n    }\n\n    #[warn(dead_code)]\n    pub fn add_block(\u0026mut self, block: Block) {\n        self.chain.blocks.push(block);\n        self.notify_block_event(self.chain.blocks.last().expect(\"block must exist\").clone());\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::cell::Cell;\n    use std::rc::Rc;\n\n    use super::*;\n\n    #[test]\n    fn test_build_blockchain() -\u003e Result\u003c(), String\u003e {\n        let keypair = identity::ed25519::Keypair::generate();\n        let local_id = Address::from(identity::PublicKey::Ed25519(keypair.public()));\n        let mut chain = Blockchain::new(\u0026keypair);\n\n        let mut transactions = vec![];\n        let data = \"Hello First Transaction\";\n        let transaction = Transaction::new(\n            TransactionType::Create,\n            local_id,\n            data.as_bytes().to_vec(),\n            \u0026keypair,\n        );\n        transactions.push(transaction);\n        chain.add_block(Block::new(\n            chain.blocks()[0].header.hash(),\n            chain.blocks()[0].header.ordinal + 1,\n            transactions,\n            \u0026keypair,\n        ));\n        assert_eq!(true, chain.blocks().last().unwrap().verify());\n        assert_eq!(2, chain.blocks().len());\n        Ok(())\n    }\n\n    #[test]\n    fn test_add_trans_listener() -\u003e Result\u003c(), String\u003e {\n        let keypair = identity::ed25519::Keypair::generate();\n        let local_id = Address::from(identity::PublicKey::Ed25519(keypair.public()));\n        let mut chain = Blockchain::new(\u0026keypair);\n\n        let transaction = Transaction::new(\n            TransactionType::Create,\n            local_id,\n            \"some transaction\".as_bytes().to_vec(),\n            \u0026keypair,\n        );\n        let called = Rc::new(Cell::new(false));\n        chain\n            .submit_transaction(transaction.clone(), {\n                let called = called.clone();\n                let transaction = transaction.clone();\n                move |t: Transaction| {\n                    assert_eq!(transaction, t);\n                    called.set(true)\n                }\n            })\n            .notify_transaction_settled(transaction);\n        assert!(called.get());\n        Ok(())\n    }\n\n    #[test]\n    fn test_add_block_listener() -\u003e Result\u003c(), String\u003e {\n        let keypair = identity::ed25519::Keypair::generate();\n        let block = Block::new(\n            HashDigest::new(b\"Hello World!\"),\n            1u128,\n            Vec::new(),\n            \u0026keypair,\n        );\n        let mut chain = Blockchain::new(\u0026keypair);\n        let called = Rc::new(Cell::new(false));\n\n        chain\n            .add_block_listener({\n                let called = called.clone();\n                let block = block.clone();\n                move |b: Block| {\n                    assert_eq!(block, b);\n                    called.set(true);\n                }\n            })\n            .add_block(block);\n\n        assert!(called.get()); // called is still false\n        Ok(())\n    }\n}\n","traces":[{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","crypto","hash_algorithm.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse codec::{Decode, Encode};\nuse multihash::{Code, Multihash, MultihashDigest};\nuse serde::{Deserialize, Serialize};\n\n#[derive(\n    Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq, Hash, Decode, Encode, PartialOrd,\n)]\npub struct HashDigest {\n    multihash: Multihash,\n}\n\nimpl HashDigest {\n    pub fn new(msg: \u0026[u8]) -\u003e Self {\n        Self {\n            multihash: Code::Keccak256.digest(msg),\n        }\n    }\n\n    pub fn to_slice(\u0026self) -\u003e [u8; 32] {\n        self.multihash\n            .digest()\n            .try_into()\n            .expect(\"a valid Keccak256 to be 32 bytes\")\n    }\n}\n\nimpl aleph_bft::Hasher for HashDigest {\n    type Hash = [u8; 32];\n\n    fn hash(x: \u0026[u8]) -\u003e Self::Hash {\n        HashDigest::new(x).to_slice()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use aleph_bft::Hasher;\n\n    #[test]\n    fn test_hash_digest() {\n        let message = b\"hello world\";\n        let expected_digest = [\n            0x47, 0x17, 0x32, 0x85, 0xa8, 0xd7, 0x34, 0x1e, 0x5e, 0x97, 0x2f, 0xc6, 0x77, 0x28,\n            0x63, 0x84, 0xf8, 0x02, 0xf8, 0xef, 0x42, 0xa5, 0xec, 0x5f, 0x03, 0xbb, 0xfa, 0x25,\n            0x4c, 0xb0, 0x1f, 0xad,\n        ];\n\n        let hash = HashDigest::new(message);\n\n        assert_eq!(hash.to_slice(), expected_digest);\n        assert_eq!(HashDigest::hash(message), expected_digest);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","crypto.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod hash_algorithm;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","identities","authority_pen.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse aleph_bft::NodeIndex;\nuse libp2p::core::identity::ed25519::{Keypair, PublicKey};\n\nuse super::signature::Signature;\n\n#[derive(Clone)]\npub struct AuthorityPen {\n    index: NodeIndex,\n    keypair: Keypair,\n}\n\nimpl AuthorityPen {\n    pub fn new(index: NodeIndex, keypair: Keypair) -\u003e Self {\n        Self { index, keypair }\n    }\n    pub fn index(\u0026self) -\u003e NodeIndex {\n        self.index\n    }\n    pub fn public(\u0026self) -\u003e PublicKey {\n        self.keypair.public()\n    }\n    pub fn sign(\u0026self, msg: \u0026[u8]) -\u003e Signature {\n        Signature::new(msg, \u0026self.keypair)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_auth_pen_sign() {\n        let keypair = Keypair::generate();\n        let auth_pen = AuthorityPen::new(0.into(), keypair.clone());\n        let signed = auth_pen.sign(b\"hello world!\");\n\n        assert!(keypair.public().verify(b\"hello world!\", \u0026signed.to_bytes()));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","identities","authority_verifier.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse aleph_bft::{NodeCount, NodeIndex};\nuse libp2p::core::identity::ed25519::PublicKey;\nuse log::{trace, warn};\nuse std::collections::HashMap;\n\nuse super::signature::{MultiSignature, Signature};\n\n#[derive(Clone, Default)]\npub struct AuthorityVerifier {\n    authorities: HashMap\u003cNodeIndex, PublicKey\u003e,\n    // TODO(prince-chrismc): Re-introduce `NodeIndex` to associate with `PeerId` when adding `network`\n    // peers_by_index: HashMap\u003cNodeIndex, PeerId\u003e,\n}\n\nimpl AuthorityVerifier {\n    pub fn new() -\u003e AuthorityVerifier {\n        Default::default()\n    }\n    pub fn save(\u0026mut self, node_ix: NodeIndex, public_key: PublicKey) {\n        trace!(\n            \"Recording new authority {:?} with {:?}\",\n            node_ix,\n            public_key\n        );\n        self.authorities.insert(node_ix, public_key);\n    }\n    /// Verifies whether the message is correctly signed with the signature assumed to be made by a\n    /// node of the given index.\n    pub fn verify(\u0026self, msg: \u0026[u8], sgn: \u0026Signature, index: NodeIndex) -\u003e bool {\n        let sig = sgn.clone().to_bytes();\n        match self.authorities.get(\u0026index) {\n            Some(public_key) =\u003e public_key.verify(msg, \u0026sig),\n            None =\u003e {\n                warn!(\"No public key for {:?}\", index);\n                false\n            }\n        }\n    }\n\n    pub fn node_count(\u0026self) -\u003e NodeCount {\n        self.authorities.len().into()\n    }\n\n    fn threshold(\u0026self) -\u003e usize {\n        2 * self.node_count().0 / 3 + 1\n    }\n\n    /// Verifies whether the given signature set is a correct and complete multisignature of the\n    /// message. Completeness requires more than 2/3 of all authorities.\n    pub fn is_complete(\u0026self, msg: \u0026[u8], partial: \u0026MultiSignature) -\u003e bool {\n        let signature_count = partial.iter().count();\n        if signature_count \u003c self.threshold() {\n            return false;\n        }\n        partial.iter().all(|(i, sgn)| self.verify(msg, sgn, i))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use aleph_bft::PartialMultisignature;\n    use libp2p::core::identity::ed25519::Keypair;\n\n    #[test]\n    fn test_auth_verifier_nothing() {\n        let multi_signs = MultiSignature::with_size(0.into());\n        let verifier = AuthorityVerifier::new();\n\n        assert_eq!(verifier.node_count(), 0.into());\n        assert_eq!(verifier.threshold(), 1);\n        assert_eq!(verifier.is_complete(b\"hello world\", \u0026multi_signs), false);\n    }\n\n    #[test]\n    fn test_auth_verifier_empty() {\n        let keypair = Keypair::generate();\n        let signed = keypair.sign(b\"hello world!\");\n        let sign = Signature::from_bytes(\u0026signed).expect(\"signature to be valid\");\n        let multi_signs =\n            MultiSignature::add_signature(MultiSignature::with_size(1.into()), \u0026sign, 0.into());\n        let verifier = AuthorityVerifier::new();\n\n        assert_eq!(verifier.node_count(), 0.into());\n        assert_eq!(verifier.threshold(), 1);\n        assert_eq!(verifier.is_complete(b\"hello world\", \u0026multi_signs), false);\n    }\n\n    #[test]\n    fn test_auth_verifier_one_signature_valid() {\n        let keypair = Keypair::generate();\n        let signed = keypair.sign(b\"hello world!\");\n        let sign = Signature::from_bytes(\u0026signed).expect(\"signature to be valid\");\n        let node_index: NodeIndex = 0.into();\n        let multi_signs =\n            MultiSignature::add_signature(MultiSignature::with_size(1.into()), \u0026sign, node_index);\n\n        let mut verifier = AuthorityVerifier::new();\n        verifier.save(node_index, keypair.public());\n\n        assert_eq!(verifier.node_count(), 1.into());\n        assert_eq!(verifier.threshold(), 1);\n        assert_eq!(verifier.is_complete(b\"hello world\", \u0026multi_signs), false);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","identities","key_box.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse aleph_bft::{NodeCount, NodeIndex, PartialMultisignature};\nuse async_trait::async_trait;\nuse libp2p::core::identity::ed25519::PublicKey;\nuse log::trace;\n\nuse super::authority_pen::AuthorityPen;\nuse super::authority_verifier::AuthorityVerifier;\nuse super::signature::{MultiSignature, Signature};\n\n#[derive(Clone)]\npub struct KeyBox {\n    authority_pen: AuthorityPen,\n    authority_verifier: AuthorityVerifier,\n}\n\nimpl KeyBox {\n    pub fn new(authority_pen: AuthorityPen, authority_verifier: AuthorityVerifier) -\u003e Self {\n        let mut kb = Self {\n            authority_pen,\n            authority_verifier,\n        };\n        // Record the pen as a known authority -- always trust yourself\n        kb.record_authority(kb.authority_pen.index(), kb.authority_pen.public());\n        kb\n    }\n    pub fn record_authority(\u0026mut self, node_index: NodeIndex, public_key: PublicKey) {\n        self.authority_verifier.save(node_index, public_key);\n    }\n}\n\n#[async_trait]\nimpl aleph_bft::KeyBox for KeyBox {\n    type Signature = Signature;\n\n    fn node_count(\u0026self) -\u003e NodeCount {\n        self.authority_verifier.node_count()\n    }\n\n    async fn sign(\u0026self, msg: \u0026[u8]) -\u003e Self::Signature {\n        trace!(\"🖋️ {:?} signing message\", self.authority_pen.index());\n        self.authority_pen.sign(msg)\n    }\n\n    fn verify(\u0026self, msg: \u0026[u8], sgn: \u0026Self::Signature, index: NodeIndex) -\u003e bool {\n        trace!(\n            \"🔎 {:?} verifying message and signature from {:?}\",\n            self.authority_pen.index(),\n            index\n        );\n        self.authority_verifier.verify(msg, sgn, index)\n    }\n}\n\nimpl aleph_bft::MultiKeychain for KeyBox {\n    type PartialMultisignature = MultiSignature;\n\n    fn from_signature(\n        \u0026self,\n        signature: \u0026Signature,\n        index: NodeIndex,\n    ) -\u003e Self::PartialMultisignature {\n        MultiSignature::add_signature(\n            MultiSignature::with_size(self.authority_verifier.node_count()),\n            signature,\n            index,\n        )\n    }\n    fn is_complete(\u0026self, msg: \u0026[u8], partial: \u0026Self::PartialMultisignature) -\u003e bool {\n        self.authority_verifier.is_complete(msg, partial)\n    }\n}\n\nimpl aleph_bft::Index for KeyBox {\n    fn index(\u0026self) -\u003e NodeIndex {\n        self.authority_pen.index()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use aleph_bft::KeyBox as AlephKeyBox;\n    use libp2p::core::identity::ed25519::Keypair;\n\n    #[tokio::test]\n    async fn test_key_box_self_signed() {\n        let key_box = KeyBox::new(\n            AuthorityPen::new(0.into(), Keypair::generate()),\n            AuthorityVerifier::new(),\n        );\n        let sign: Signature = key_box.sign(b\"hello world!\").await;\n\n        assert_eq!(key_box.verify(b\"hello world\", \u0026sign, 0.into()), false);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","identities","verify_key.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse codec::{Decode, Encode, Error as CodecError, Input};\nuse libp2p::core::identity::ed25519::PublicKey;\nuse log::{debug, trace};\n\n// Convenience wrapper around a ed25519::PublicKey to support the parity scale coded required by aleph_bft\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct VerifyKey {\n    pub public: PublicKey,\n}\n\nimpl VerifyKey {\n    pub fn public(\u0026self) -\u003e PublicKey {\n        self.public.clone()\n    }\n}\n\nimpl Encode for VerifyKey {\n    fn using_encoded\u003cR, F: FnOnce(\u0026[u8]) -\u003e R\u003e(\u0026self, f: F) -\u003e R {\n        self.public().encode().using_encoded(f)\n    }\n\n    fn size_hint(\u0026self) -\u003e usize {\n        32\n    }\n}\n\nimpl Decode for VerifyKey {\n    fn decode\u003cI: Input\u003e(value: \u0026mut I) -\u003e Result\u003cSelf, CodecError\u003e {\n        let mut buf = [0u8; 32];\n        value.read(\u0026mut buf)?;\n        let public = PublicKey::decode(\u0026buf).map_err(|e| {\n            debug!(\"public key decode failed with: {:?}\", e);\n            trace!(\"Failed to decode public key: {}\", hex::encode(\u0026buf));\n            CodecError::from(\"public key decoded from_bytes\")\n        })?;\n        Ok(Self { public })\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","identities.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod authority_pen;\npub mod authority_verifier;\npub mod key_box;\npub mod verify_key;\nuse super::signature;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","lib.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod args;\npub mod blockchain;\npub mod crypto;\npub mod identities;\npub mod network;\npub mod providers;\npub mod signature;\npub mod structures;\n\nuse crate::network::NetworkData;\nuse crate::providers::DataStore;\nuse crate::structures::block::Block;\nuse crate::structures::header::Ordinal;\n\npub use aleph_bft::{default_config, run_session, NodeIndex};\nuse futures::{\n    channel::{\n        mpsc::{UnboundedReceiver, UnboundedSender},\n        oneshot,\n    },\n    FutureExt, StreamExt,\n};\nuse futures_timer::Delay;\nuse log::{debug, info, trace};\nuse std::sync::Mutex;\nuse std::{\n    sync::Arc,\n    time::{self, Duration},\n};\n\npub type BlockPlan = Arc\u003cdyn Fn(Ordinal) -\u003e NodeIndex + Sync + Send + 'static\u003e;\n\npub struct ChainConfig {\n    // Our NodeIndex.\n    pub node_ix: NodeIndex,\n    // Number of random bytes to include in the block.\n    pub data_size: usize,\n    // Delay between blocks\n    pub blocktime_ms: u128,\n    // Delay before the first block should be created\n    pub init_delay_ms: u128,\n    // f(k) means who should author the kth block\n    pub authorship_plan: BlockPlan,\n}\n\npub fn gen_chain_config(\n    node_ix: NodeIndex,\n    n_members: usize,\n    data_size: usize,\n    blocktime_ms: u128,\n    init_delay_ms: u128,\n) -\u003e ChainConfig {\n    //Round robin block authorship plan.\n    // let authorship_plan = Arc::new(move |num: u64| NodeIndex(((num as usize) % n_members) + 1));\n    let authorship_plan = Arc::new(move |num: u128| NodeIndex((num as usize) % n_members));\n    ChainConfig {\n        node_ix,\n        data_size,\n        blocktime_ms,\n        init_delay_ms,\n        authorship_plan,\n    }\n}\n\n// Runs a process that maintains a simple blockchain. The blocks are created every config.blocktime_ms\n// milliseconds and the block authors are determined by config.authorship_plan. The default config\n// uses round robin authorship: node k creates blocks number n if n%n_members = k.\n// A node will create a block n only if:\n// 1) it received the previous block (n-1)\n// 2) it is the nth block author\n// 3) enough time has passed -- to maintain blocktime of roughly config.blocktime_ms milliseconds.\n// This process holds two channel endpoints: block_rx to receive blocks from the network and\n// block_tx to push created blocks to the network (to send them to all the remaining nodes).\npub async fn run_blockchain(\n    config: ChainConfig,\n    mut data_store: DataStore,\n    current_block: Arc\u003cMutex\u003cBlock\u003e\u003e,\n    mut blocks_from_network: UnboundedReceiver\u003cBlock\u003e,\n    _blocks_for_network: UnboundedSender\u003cBlock\u003e,\n    mut messages_from_network: UnboundedReceiver\u003cNetworkData\u003e,\n    mut exit: oneshot::Receiver\u003c()\u003e,\n) {\n    let start_time = time::Instant::now();\n    for block_num in 1u128.. {\n        while current_block.lock().unwrap().header.ordinal \u003c block_num {\n            let curr_author = (config.authorship_plan)(block_num);\n            trace!(\"The current block author is {:?}\", curr_author);\n            if curr_author == config.node_ix {\n                // We need to create the block, but at the right time\n                info!(\n                    \"🔔 It's my turn to create a new block -- block_num {}\",\n                    block_num\n                );\n                let curr_time = time::Instant::now();\n                //TODO(prince-chrismc): This wants to be u64 so we need to do some magic here\n                let block_delay_ms = (block_num - 1) * config.blocktime_ms + config.init_delay_ms;\n                let block_creation_time =\n                    start_time + Duration::from_millis(block_delay_ms.try_into().unwrap());\n                if curr_time \u003e= block_creation_time {\n                    // TODO(prince-chrismc): Figure out how to generate new blocks and push them on the network\n                    // let block = Block::new(block_num, config.data_size);\n                    // blocks_for_network\n                    //     .unbounded_send(block)\n                    //     .expect(\"network should accept blocks\");\n                    info!(\"📝 Saving locally generated block\");\n                    // TODO(prince-chrismc): Generate blocks from \"known transactions\"\n                    // data_store.add_block(block_num);\n                }\n            }\n            // We tick every 125ms.\n            let mut delay_fut = Delay::new(Duration::from_millis(125)).fuse();\n\n            futures::select! {\n                maybe_block = blocks_from_network.next() =\u003e {\n                    if let Some(block) = maybe_block {\n                        info!(\"🧾 Adding new block {} from the network\", block.header.ordinal);\n                        data_store.add_block(block);\n                        //We drop the block at this point, only keep track of the fact that we received it.\n                    }\n                }\n                maybe_message = messages_from_network.next() =\u003e {\n                    if let Some(message) = maybe_message {\n                        trace!(\"recording new message from network\");\n                        data_store.add_message(message);\n                    }\n                }\n                _ = \u0026mut delay_fut =\u003e {\n                    //We do nothing, but this takes us out of the select.\n                }\n                _ = \u0026mut exit =\u003e {\n                    debug!(\"Received exit signal.\");\n                    return;\n                },\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","network.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse super::crypto::hash_algorithm::HashDigest;\nuse super::identities::verify_key::VerifyKey;\nuse super::signature::{MultiSignature, Signature};\nuse super::structures::block::Block;\n\nuse aleph_bft::{NodeIndex, Recipient, TaskHandle};\nuse codec::{Decode, Encode};\nuse futures::{\n    channel::{\n        mpsc::{self, UnboundedReceiver, UnboundedSender},\n        oneshot,\n    },\n    prelude::*,\n    Future, FutureExt, StreamExt,\n};\nuse libp2p::core::identity::ed25519::PublicKey;\nuse libp2p::{\n    core::upgrade,\n    identity,\n    mdns::{Mdns, MdnsEvent},\n    mplex, noise,\n    request_response::{\n        ProtocolSupport, RequestResponse, RequestResponseCodec, RequestResponseConfig,\n        RequestResponseEvent, RequestResponseMessage,\n    },\n    swarm::{NetworkBehaviourEventProcess, SwarmBuilder},\n    tcp::TokioTcpConfig,\n    NetworkBehaviour, PeerId, Swarm, Transport,\n};\nuse log::{debug, info, trace, warn};\nuse std::{collections::HashMap, error::Error, io, iter, time::Duration};\n\n#[derive(Clone)]\npub struct Spawner;\n\nimpl aleph_bft::SpawnHandle for Spawner {\n    fn spawn(\u0026self, _: \u0026str, task: impl Future\u003cOutput = ()\u003e + Send + 'static) {\n        tokio::spawn(task);\n    }\n    fn spawn_essential(\n        \u0026self,\n        _: \u0026str,\n        task: impl Future\u003cOutput = ()\u003e + Send + 'static,\n    ) -\u003e TaskHandle {\n        Box::pin(async move { tokio::spawn(task).await.map_err(|_| ()) })\n    }\n}\n\nconst PYRSIA_BLOCKCHAIN_PROTOCOL_NAME: \u0026str = \"/pyrsia/blockchain/1\";\n\npub type NetworkData = aleph_bft::NetworkData\u003cHashDigest, Block, Signature, MultiSignature\u003e;\n\n#[allow(clippy::large_enum_variant)]\n#[derive(Clone, Encode, Decode)]\nenum Message {\n    Auth(NodeIndex),\n    Consensus(NetworkData),\n    Block(Block),\n    PublicKey(NodeIndex, VerifyKey),\n}\n\n/// Implements the libp2p [`RequestResponseCodec`] trait.\n/// GenericCodec is a suitably adjusted version of the GenericCodec implemented in sc-network in substrate.\n/// Defines how streams of bytes are turned into requests and responses and vice-versa.\n#[derive(Debug, Clone)]\npub struct GenericCodec {}\n\ntype Request = Vec\u003cu8\u003e;\n// The Response type is empty -- we use RequestResponse just to send regular messages (requests).\ntype Response = ();\n\n#[async_trait::async_trait]\nimpl RequestResponseCodec for GenericCodec {\n    type Protocol = Vec\u003cu8\u003e;\n    type Request = Request;\n    type Response = Response;\n\n    async fn read_request\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026Self::Protocol,\n        mut io: \u0026mut T,\n    ) -\u003e io::Result\u003cSelf::Request\u003e\n    where\n        T: AsyncRead + Unpin + Send,\n    {\n        let length = unsigned_varint::aio::read_usize(\u0026mut io)\n            .await\n            .map_err(|err| io::Error::new(io::ErrorKind::InvalidInput, err))?;\n        let mut buffer = vec![0; length];\n        io.read_exact(\u0026mut buffer).await?;\n        Ok(buffer)\n    }\n\n    async fn read_response\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026Self::Protocol,\n        mut _io: \u0026mut T,\n    ) -\u003e io::Result\u003cSelf::Response\u003e\n    where\n        T: AsyncRead + Unpin + Send,\n    {\n        Ok(())\n    }\n\n    async fn write_request\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026Self::Protocol,\n        io: \u0026mut T,\n        req: Self::Request,\n    ) -\u003e io::Result\u003c()\u003e\n    where\n        T: AsyncWrite + Unpin + Send,\n    {\n        let mut buffer = unsigned_varint::encode::usize_buffer();\n        io.write_all(unsigned_varint::encode::usize(req.len(), \u0026mut buffer))\n            .await?;\n\n        io.write_all(\u0026req).await?;\n\n        io.close().await?;\n        Ok(())\n    }\n\n    async fn write_response\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026Self::Protocol,\n        _io: \u0026mut T,\n        _res: Self::Response,\n    ) -\u003e io::Result\u003c()\u003e\n    where\n        T: AsyncWrite + Unpin + Send,\n    {\n        Ok(())\n    }\n}\n\n#[derive(NetworkBehaviour)]\n#[behaviour(event_process = true)]\npub struct Behaviour {\n    mdns: Mdns,\n    rq_rp: RequestResponse\u003cGenericCodec\u003e,\n\n    #[behaviour(ignore)]\n    peers: Vec\u003cPeerId\u003e,\n    #[behaviour(ignore)]\n    peer_by_index: HashMap\u003cNodeIndex, PeerId\u003e,\n    #[behaviour(ignore)]\n    consensus_tx: mpsc::UnboundedSender\u003cNetworkData\u003e,\n    #[behaviour(ignore)]\n    block_tx: mpsc::UnboundedSender\u003cBlock\u003e,\n    #[behaviour(ignore)]\n    node_ix: NodeIndex,\n    #[behaviour(ignore)]\n    public_key: VerifyKey,\n    #[behaviour(ignore)]\n    new_authority_tx: UnboundedSender\u003c(NodeIndex, PublicKey)\u003e,\n}\n\nimpl Behaviour {\n    fn send_consensus_message(\u0026mut self, message: NetworkData, recipient: Recipient) {\n        let message: Vec\u003cu8\u003e = Message::Consensus(message).encode();\n        trace!(\"Dispatching consensus message: {}\", hex::encode(\u0026message));\n        use Recipient::*;\n        match recipient {\n            Node(node_ix) =\u003e {\n                if let Some(peer_id) = self.peer_by_index.get(\u0026node_ix) {\n                    self.rq_rp.send_request(peer_id, message);\n                } else {\n                    warn!(\"No peer_id known for node {:?}.\", node_ix);\n                }\n            }\n            Everyone =\u003e {\n                for peer_id in self.peers.iter() {\n                    self.rq_rp.send_request(peer_id, message.clone());\n                }\n            }\n        }\n    }\n\n    fn send_block_message(\u0026mut self, block: Block) {\n        info!(\"✈️ Sending block {}\", block.header.ordinal);\n        let message = Message::Block(block).encode();\n        for peer_id in self.peers.iter() {\n            self.rq_rp.send_request(peer_id, message.clone());\n        }\n    }\n}\n\nimpl NetworkBehaviourEventProcess\u003cMdnsEvent\u003e for Behaviour {\n    fn inject_event(\u0026mut self, event: MdnsEvent) {\n        if let MdnsEvent::Discovered(list) = event {\n            trace!(\"Processing discovery event with new list {:?}\", list);\n            let auth_message = Message::Auth(self.node_ix).encode();\n            let key_message = Message::PublicKey(self.node_ix, self.public_key.clone()).encode();\n            for (peer, _) in list {\n                if self.peers.iter().any(|p| *p == peer) {\n                    continue;\n                }\n                self.peers.push(peer);\n                trace!(\"Sending authentication message to {:?}\", peer);\n                self.rq_rp.send_request(\u0026peer, auth_message.clone());\n\n                trace!(\"Sending public key message to {:?}\", peer);\n                self.rq_rp.send_request(\u0026peer, key_message.clone());\n            }\n        }\n    }\n}\n\nimpl NetworkBehaviourEventProcess\u003cRequestResponseEvent\u003cRequest, Response\u003e\u003e for Behaviour {\n    fn inject_event(\u0026mut self, event: RequestResponseEvent\u003cRequest, Response\u003e) {\n        if let RequestResponseEvent::Message {\n            peer: peer_id,\n            message,\n        } = event\n        {\n            match message {\n                RequestResponseMessage::Request {\n                    request_id: _,\n                    request,\n                    channel: _,\n                } =\u003e {\n                    if !self.peers.iter().any(|p| *p == peer_id) {\n                        info!(\"An unknown {:?} has sent us a message!\", peer_id);\n                        self.peers.push(peer_id);\n\n                        trace!(\"Sending authentication message to {:?}\", peer_id);\n                        let auth_message = Message::Auth(self.node_ix).encode();\n                        self.rq_rp.send_request(\u0026peer_id, auth_message);\n\n                        trace!(\"Sending public key message to {:?}\", peer_id);\n                        let key_message =\n                            Message::PublicKey(self.node_ix, self.public_key.clone()).encode();\n                        self.rq_rp.send_request(\u0026peer_id, key_message);\n                    }\n\n                    let result = Message::decode(\u0026mut \u0026request[..]);\n                    match result {\n                        Err(e) =\u003e warn!(\n                            \"Failed to decode inbound request as Message: {} -- {}\",\n                            e,\n                            hex::encode(\u0026request)\n                        ),\n                        Ok(message) =\u003e match message {\n                            Message::Consensus(msg) =\u003e {\n                                debug!(\"📌 New consensus message: {:?}\", msg);\n\n                                self.consensus_tx\n                                    .unbounded_send(msg)\n                                    .expect(\"Network must listen\");\n                            }\n                            Message::Auth(node_ix) =\u003e {\n                                debug!(\"🖇️ Authenticated peer: {:?} {:?}\", node_ix, peer_id);\n\n                                if self.peer_by_index.get(\u0026node_ix).is_none() {\n                                    trace!(\"Sending authentication message to {:?}\", peer_id);\n                                    let auth_message = Message::Auth(self.node_ix).encode();\n                                    self.rq_rp.send_request(\u0026peer_id, auth_message);\n\n                                    trace!(\"Sending public key message to {:?}\", peer_id);\n                                    let key_message =\n                                        Message::PublicKey(self.node_ix, self.public_key.clone())\n                                            .encode();\n                                    self.rq_rp.send_request(\u0026peer_id, key_message);\n                                }\n\n                                self.peer_by_index.insert(node_ix, peer_id);\n                            }\n                            Message::Block(block) =\u003e {\n                                debug!(\n                                    \"Received block num {:?} from {:?}\",\n                                    block.header.ordinal, peer_id\n                                );\n                                self.block_tx\n                                    .unbounded_send(block)\n                                    .expect(\"Blockchain process must listen\");\n                            }\n                            Message::PublicKey(node_ix, key) =\u003e {\n                                debug!(\"📑 Received a new public key from {:?}\", node_ix);\n                                self.new_authority_tx\n                                    .unbounded_send((node_ix, key.public()))\n                                    .expect(\"PublicKey process must listen\");\n                            }\n                        }, // We do not send back a response to a request. We treat them simply as one-way messages.}\n                    }\n                }\n                RequestResponseMessage::Response { .. } =\u003e {\n                    //We ignore the response, as it is empty anyway.\n                }\n            }\n        }\n    }\n}\n\npub struct Network {\n    msg_to_manager_tx: mpsc::UnboundedSender\u003c(NetworkData, Recipient)\u003e,\n    msg_from_manager_rx: mpsc::UnboundedReceiver\u003cNetworkData\u003e,\n}\n\n#[async_trait::async_trait]\nimpl aleph_bft::Network\u003cHashDigest, Block, Signature, MultiSignature\u003e for Network {\n    fn send(\u0026self, data: NetworkData, recipient: Recipient) {\n        trace!(\"Sending a message to: {:?}\", recipient);\n        if let Err(e) = self.msg_to_manager_tx.unbounded_send((data, recipient)) {\n            warn!(\"Failed network send: {:?}\", e);\n        }\n    }\n    async fn next_event(\u0026mut self) -\u003e Option\u003cNetworkData\u003e {\n        let msg = self.msg_from_manager_rx.next().await;\n        msg.map(|m| {\n            trace!(\n                \"New event received of network data {}\",\n                hex::encode(m.encode())\n            );\n            m\n        })\n    }\n}\n\npub struct NetworkManager {\n    swarm: Swarm\u003cBehaviour\u003e,\n    consensus_rx: UnboundedReceiver\u003c(NetworkData, Recipient)\u003e,\n    block_rx: UnboundedReceiver\u003cBlock\u003e,\n}\n\nimpl Network {\n    pub async fn new(\n        node_ix: NodeIndex,\n        key_pair: identity::ed25519::Keypair,\n        peer_by_index: HashMap\u003cNodeIndex, PeerId\u003e,\n        new_authority_tx: UnboundedSender\u003c(NodeIndex, PublicKey)\u003e,\n    ) -\u003e Result\u003c\n        (\n            Self,\n            NetworkManager,\n            UnboundedSender\u003cBlock\u003e,\n            UnboundedReceiver\u003cBlock\u003e,\n            UnboundedSender\u003cNetworkData\u003e,\n            UnboundedReceiver\u003cNetworkData\u003e,\n        ),\n        Box\u003cdyn Error\u003e,\n    \u003e {\n        let local_key: identity::Keypair = identity::Keypair::Ed25519(key_pair.clone());\n        let public_key: libp2p::identity::ed25519::PublicKey = key_pair.public();\n        let local_peer_id = PeerId::from(local_key.public());\n        info!(\"Local peer id: {:?}\", local_peer_id);\n\n        // Create a keypair for authenticated encryption of the transport.\n        let noise_keys = noise::Keypair::\u003cnoise::X25519Spec\u003e::new()\n            .into_authentic(\u0026local_key)\n            .expect(\"Signing libp2p-noise static DH keypair failed.\");\n\n        // Create a tokio-based TCP transport use noise for authenticated\n        // encryption and Mplex for multiplexing of substreams on a TCP stream.\n        let transport = TokioTcpConfig::new()\n            .nodelay(true)\n            .upgrade(upgrade::Version::V1)\n            .authenticate(noise::NoiseConfig::xx(noise_keys).into_authenticated())\n            .multiplex(mplex::MplexConfig::new())\n            .boxed();\n\n        let (msg_to_manager_tx, msg_to_manager_rx) = mpsc::unbounded();\n        let (msg_for_store, msg_from_manager) = mpsc::unbounded();\n        let (msg_for_network, msg_from_store) = mpsc::unbounded();\n        let (block_to_data_io_tx, block_to_data_io_rx) = mpsc::unbounded();\n        let (block_from_data_io_tx, block_from_data_io_rx) = mpsc::unbounded();\n        let mut swarm = {\n            let mut rr_cfg = RequestResponseConfig::default();\n            rr_cfg.set_connection_keep_alive(Duration::from_secs(10));\n            rr_cfg.set_request_timeout(Duration::from_secs(4));\n            let protocol_support = ProtocolSupport::Full;\n            let rq_rp = RequestResponse::new(\n                GenericCodec {},\n                iter::once((\n                    PYRSIA_BLOCKCHAIN_PROTOCOL_NAME.as_bytes().to_vec(),\n                    protocol_support,\n                )),\n                rr_cfg,\n            );\n\n            let mdns = Mdns::new(Default::default()).await?;\n            let behaviour = Behaviour {\n                rq_rp,\n                mdns,\n                peers: vec![],\n                peer_by_index,\n                consensus_tx: msg_for_store,\n                block_tx: block_to_data_io_tx,\n                node_ix,\n                public_key: VerifyKey { public: public_key },\n                new_authority_tx,\n            };\n            SwarmBuilder::new(transport, behaviour, local_peer_id)\n                .executor(Box::new(|fut| {\n                    tokio::spawn(fut);\n                }))\n                .build()\n        };\n\n        swarm.listen_on(\"/ip4/0.0.0.0/tcp/0\".parse()?)?;\n\n        let network = Network {\n            msg_to_manager_tx,\n            msg_from_manager_rx: msg_from_store,\n        };\n\n        let network_manager = NetworkManager {\n            swarm,\n            consensus_rx: msg_to_manager_rx,\n            block_rx: block_from_data_io_rx,\n        };\n\n        Ok((\n            network,\n            network_manager,\n            block_from_data_io_tx,\n            block_to_data_io_rx,\n            msg_for_network,\n            msg_from_manager,\n        ))\n    }\n}\n\nimpl NetworkManager {\n    pub async fn run(\u0026mut self, mut exit: oneshot::Receiver\u003c()\u003e) {\n        loop {\n            futures::select! {\n                maybe_msg = self.consensus_rx.next() =\u003e {\n                    if let Some((consensus_msg, recipient)) = maybe_msg {\n                        let handle = \u0026mut self.swarm.behaviour_mut();\n                        handle.send_consensus_message(consensus_msg, recipient);\n                    }\n                }\n                maybe_block = self.block_rx.next() =\u003e {\n                    if let Some(block) = maybe_block {\n                        let handle = \u0026mut self.swarm.behaviour_mut();\n                        handle.send_block_message(block);\n                    }\n                }\n                event = self.swarm.next().fuse() =\u003e {\n                    match event {\n                        Some(event) =\u003e {\n                            trace!(\"Received a swarm event: {:?}\", event);\n                        }\n                        None =\u003e {\n                            panic!(\"Swarm stream ended\");\n                        }\n                    }\n                }\n               _ = \u0026mut exit  =\u003e break,\n            }\n        }\n    }\n}\n","traces":[{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":14},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","providers.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse super::{network::NetworkData, structures::block::Block, structures::header::Ordinal};\nuse async_trait::async_trait;\nuse futures::channel::{\n    mpsc,\n    mpsc::{UnboundedReceiver, UnboundedSender},\n};\nuse log::{debug, error};\nuse std::{\n    collections::{HashMap, HashSet},\n    sync::{Arc, Mutex},\n};\n\npub struct DataStore {\n    next_message_id: u32,\n    current_block: Arc\u003cMutex\u003cBlock\u003e\u003e,\n    available_blocks: HashSet\u003cOrdinal\u003e,\n    message_requirements: HashMap\u003cu32, usize\u003e,\n    dependent_messages: HashMap\u003cBlock, Vec\u003cu32\u003e\u003e,\n    pending_messages: HashMap\u003cu32, NetworkData\u003e,\n    messages_for_member: UnboundedSender\u003cNetworkData\u003e,\n}\n\nimpl DataStore {\n    pub fn new(\n        current_block: Arc\u003cMutex\u003cBlock\u003e\u003e,\n        messages_for_member: UnboundedSender\u003cNetworkData\u003e,\n    ) -\u003e Self {\n        let available_blocks = (0..=current_block.lock().unwrap().header.ordinal).collect();\n        DataStore {\n            next_message_id: 0,\n            current_block,\n            available_blocks,\n            message_requirements: HashMap::new(),\n            dependent_messages: HashMap::new(),\n            pending_messages: HashMap::new(),\n            messages_for_member,\n        }\n    }\n\n    fn add_pending_message(\u0026mut self, message: NetworkData, requirements: Vec\u003cBlock\u003e) {\n        let message_id = self.next_message_id;\n        // Whatever test you are running should end before this becomes a problem.\n        self.next_message_id += 1;\n        for block in requirements.iter() {\n            self.dependent_messages\n                .entry(block.clone())\n                .or_insert_with(Vec::new)\n                .push(message_id);\n        }\n        self.message_requirements\n            .insert(message_id, requirements.len());\n        self.pending_messages.insert(message_id, message);\n    }\n\n    pub fn add_message(\u0026mut self, message: NetworkData) {\n        let requirements: Vec\u003c_\u003e = message\n            .included_data()\n            .into_iter()\n            .filter(|b| !self.available_blocks.contains(\u0026b.header.ordinal))\n            .collect();\n        if requirements.is_empty() {\n            self.messages_for_member\n                .unbounded_send(message)\n                .expect(\"member accept messages\");\n        } else {\n            self.add_pending_message(message, requirements.into_iter().collect());\n        }\n    }\n\n    fn push_messages(\u0026mut self, block: Block) {\n        for message_id in self\n            .dependent_messages\n            .entry(block.clone())\n            .or_insert_with(Vec::new)\n            .iter()\n        {\n            *self\n                .message_requirements\n                .get_mut(message_id)\n                .expect(\"there are some requirements\") -= 1;\n            if self.message_requirements[message_id] == 0 {\n                let message = self\n                    .pending_messages\n                    .remove(message_id)\n                    .expect(\"there is a pending message\");\n                self.messages_for_member\n                    .unbounded_send(message)\n                    .expect(\"member accept messages\");\n                self.message_requirements.remove(message_id);\n            }\n        }\n        self.dependent_messages.remove(\u0026block);\n    }\n\n    pub fn add_block(\u0026mut self, block: Block) {\n        debug!(\"Added block {:?}.\", block);\n        self.available_blocks.insert(block.header.ordinal);\n        self.push_messages(block);\n        while self\n            .available_blocks\n            .contains(\u0026(self.current_block.lock().unwrap().header.ordinal + 1))\n        {\n            self.current_block.lock().unwrap().header.ordinal += 1;\n        }\n        debug!(\"Updated chain {:?}\", self.available_blocks);\n    }\n}\n\n#[derive(Clone)]\npub struct DataProvider {\n    current_block: Arc\u003cMutex\u003cBlock\u003e\u003e,\n}\n\n#[async_trait]\nimpl aleph_bft::DataProvider\u003cBlock\u003e for DataProvider {\n    async fn get_data(\u0026mut self) -\u003e Block {\n        self.current_block.lock().unwrap().clone()\n    }\n}\n\nimpl DataProvider {\n    // TODO(prince-chrismc): Initial Block?\n    pub fn new(initial_block: Arc\u003cMutex\u003cBlock\u003e\u003e) -\u003e Self {\n        DataProvider {\n            current_block: initial_block,\n        }\n    }\n}\n\npub struct FinalizationProvider {\n    tx: UnboundedSender\u003cBlock\u003e,\n}\n\n#[async_trait]\nimpl aleph_bft::FinalizationHandler\u003cBlock\u003e for FinalizationProvider {\n    async fn data_finalized(\u0026mut self, d: Block) {\n        if let Err(e) = self.tx.unbounded_send(d) {\n            error!(\"Error when sending data from FinalizationProvider {:?}.\", e);\n        }\n    }\n}\n\nimpl FinalizationProvider {\n    pub fn new() -\u003e (Self, UnboundedReceiver\u003cBlock\u003e) {\n        let (tx, rx) = mpsc::unbounded();\n\n        (Self { tx }, rx)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","signature.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse aleph_bft::SignatureSet;\nuse codec::{Decode, Encode};\nuse libp2p::core::identity::ed25519::Keypair;\nuse serde::{Deserialize, Serialize};\nuse std::hash::{Hash, Hasher};\n\npub type Error = ed25519_dalek::SignatureError;\n\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq, Decode)]\npub struct Signature {\n    #[codec(encoded_as = \"[u8; ed25519_dalek::Signature::BYTE_SIZE]\")]\n    signature: ed25519_dalek::Signature,\n}\n\n#[allow(clippy::derive_hash_xor_eq)] // https://github.com/rust-lang/rust-clippy/issues/7666\nimpl Hash for Signature {\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\n        self.signature.to_bytes().hash(state);\n    }\n}\n\nimpl Signature {\n    pub fn from_bytes(msg: \u0026[u8]) -\u003e Result\u003cSelf, Error\u003e {\n        let sig = ed25519_dalek::Signature::from_bytes(msg)?;\n        Ok(Self { signature: sig })\n    }\n    pub fn to_bytes(self) -\u003e [u8; ed25519_dalek::Signature::BYTE_SIZE] {\n        self.signature.to_bytes()\n    }\n    pub fn new(msg: \u0026[u8], keypair: \u0026Keypair) -\u003e Self {\n        let signed: Vec\u003cu8\u003e = keypair.sign(msg);\n        Signature::from_bytes(\u0026signed).expect(\"signed data should always be valid\")\n    }\n}\n\nimpl Encode for Signature {\n    fn using_encoded\u003cR, F: FnOnce(\u0026[u8]) -\u003e R\u003e(\u0026self, f: F) -\u003e R {\n        self.signature.to_bytes().using_encoded(f)\n    }\n\n    fn size_hint(\u0026self) -\u003e usize {\n        ed25519_dalek::Signature::BYTE_SIZE\n    }\n}\n\npub type MultiSignature = SignatureSet\u003cSignature\u003e;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_signature_encode() {\n        let bytes: [u8; ed25519_dalek::Signature::BYTE_SIZE] = [\n            0x6d, 0xd3, 0x55, 0x66, 0x7f, 0xae, 0x4e, 0xb4, 0x3c, 0x6e, 0x0a, 0xb9, 0x2e, 0x87,\n            0x0e, 0xdb, 0x2d, 0xe0, 0xa8, 0x8c, 0xae, 0x12, 0xdb, 0xd8, 0x59, 0x15, 0x07, 0xf5,\n            0x84, 0xfe, 0x49, 0x12, 0xba, 0xbf, 0xf4, 0x97, 0xf1, 0xb8, 0xed, 0xf9, 0x56, 0x7d,\n            0x24, 0x83, 0xd5, 0x4d, 0xdc, 0x64, 0x59, 0xbe, 0xa7, 0x85, 0x52, 0x81, 0xb7, 0xa2,\n            0x46, 0xa6, 0x09, 0xe3, 0x00, 0x1a, 0x4e, 0x08,\n        ];\n        let sign = Signature::from_bytes(\u0026bytes).unwrap();\n        println!(\"{:?}\", sign.encode());\n\n        assert_eq!(\n            sign.encode(),\n            vec![\n                109, 211, 85, 102, 127, 174, 78, 180, 60, 110, 10, 185, 46, 135, 14, 219, 45, 224,\n                168, 140, 174, 18, 219, 216, 89, 21, 7, 245, 132, 254, 73, 18, 186, 191, 244, 151,\n                241, 184, 237, 249, 86, 125, 36, 131, 213, 77, 220, 100, 89, 190, 167, 133, 82,\n                129, 183, 162, 70, 166, 9, 227, 0, 26, 78, 8\n            ]\n        );\n    }\n\n    #[test]\n    fn test_signature_decode() {\n        let bytes: [u8; ed25519_dalek::Signature::BYTE_SIZE] = [\n            0x6d, 0xd3, 0x55, 0x66, 0x7f, 0xae, 0x4e, 0xb4, 0x3c, 0x6e, 0x0a, 0xb9, 0x2e, 0x87,\n            0x0e, 0xdb, 0x2d, 0xe0, 0xa8, 0x8c, 0xae, 0x12, 0xdb, 0xd8, 0x59, 0x15, 0x07, 0xf5,\n            0x84, 0xfe, 0x49, 0x12, 0xba, 0xbf, 0xf4, 0x97, 0xf1, 0xb8, 0xed, 0xf9, 0x56, 0x7d,\n            0x24, 0x83, 0xd5, 0x4d, 0xdc, 0x64, 0x59, 0xbe, 0xa7, 0x85, 0x52, 0x81, 0xb7, 0xa2,\n            0x46, 0xa6, 0x09, 0xe3, 0x00, 0x1a, 0x4e, 0x08,\n        ];\n        let expected = Signature::from_bytes(\u0026bytes).unwrap();\n\n        let mut da: \u0026[u8] = \u0026bytes;\n        let sign = Signature::decode(\u0026mut da);\n\n        assert_eq!(sign.ok(), Some(expected));\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","structures","block.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse codec::{Decode, Encode};\nuse libp2p::identity;\nuse serde::{Deserialize, Serialize};\nuse std::cmp::Ordering;\nuse std::fmt::{Display, Formatter};\n\nuse super::header::{Address, Header};\nuse super::transaction::Transaction;\nuse crate::crypto::hash_algorithm::HashDigest;\nuse crate::signature::Signature;\n\npub type BlockSignature = Signature;\n\n#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Decode, Encode, Hash)]\npub struct Block {\n    pub header: Header,\n    // TODO(fishseabowl): Should be a Merkle Tree to speed up validation with root hash\n    pub transactions: Vec\u003cTransaction\u003e,\n    signature: BlockSignature,\n}\n\nimpl Block {\n    pub fn new(\n        parent_hash: HashDigest,\n        ordinal: u128,\n        transactions: Vec\u003cTransaction\u003e,\n        signing_key: \u0026identity::ed25519::Keypair,\n    ) -\u003e Self {\n        let transaction_root = HashDigest::new(\u0026bincode::serialize(\u0026transactions).unwrap());\n        let header = Header::new(\n            parent_hash,\n            transaction_root,\n            Address::from(identity::PublicKey::Ed25519(signing_key.public())),\n            ordinal,\n        );\n        Self {\n            header,\n            transactions,\n            signature: Signature::new(\u0026bincode::serialize(\u0026header.hash()).unwrap(), signing_key),\n        }\n    }\n\n    pub fn signature(\u0026self) -\u003e BlockSignature {\n        self.signature.clone()\n    }\n\n    // After merging Aleph consensus algorithm, it would be implemented\n    pub fn verify(\u0026self) -\u003e bool {\n        true\n    }\n}\n\nimpl PartialOrd for Block {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        self.header.ordinal.partial_cmp(\u0026other.header.ordinal)\n    }\n}\n\nimpl Display for Block {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let json = serde_json::to_string_pretty(\u0026self).expect(\"json format error\");\n        write!(f, \"{}\", json)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::super::transaction::TransactionType;\n    use super::*;\n\n    #[test]\n    fn test_build_block() -\u003e Result\u003c(), String\u003e {\n        let keypair = identity::ed25519::Keypair::generate();\n        let local_id = Address::from(identity::PublicKey::Ed25519(keypair.public()));\n\n        let transactions = vec![Transaction::new(\n            TransactionType::Create,\n            local_id,\n            b\"Hello First Transaction\".to_vec(),\n            \u0026keypair,\n        )];\n        let block = Block::new(HashDigest::new(b\"\"), 1, transactions.to_vec(), \u0026keypair);\n        let expected_signature =\n            Signature::new(\u0026bincode::serialize(\u0026block.header.hash()).unwrap(), \u0026keypair);\n\n        assert_eq!(1, block.header.ordinal);\n        assert_eq!(expected_signature, block.signature());\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","structures","chain.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse codec::{Decode, Encode};\nuse serde::{Deserialize, Serialize};\n\nuse super::block::Block;\n\n#[derive(Serialize, Deserialize, Debug, Default, Clone, Decode, Encode, Hash, PartialEq, Eq)]\npub struct Chain {\n    // TODO(prince-chrismc): This eventually needs to be an ordered set so block sequence is always sorted by ordinal\n    pub blocks: Vec\u003cBlock\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","structures","header.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse codec::{Decode, Encode};\nuse libp2p::{identity, PeerId};\nuse multihash::Multihash;\nuse rand::Rng;\nuse serde::{Deserialize, Serialize};\nuse std::time::{SystemTime, UNIX_EPOCH};\n\nuse crate::crypto::hash_algorithm::HashDigest;\n\n#[derive(Serialize, Deserialize, Debug, Clone, Hash, PartialEq, Eq, Copy, Decode, Encode)]\npub struct Address {\n    // This can not be libp2p's PeerId as it is missing the SCALE codec support for Aleph,\n    // internally it's a https://github.com/libp2p/rust-libp2p/blob/6cc3b4ec52c922bfcf562a29b5805c3150e37c75/core/src/peer_id.rs#L40\n    // So we will stick with that.\n    peer_id: Multihash,\n}\n\nimpl From\u003cidentity::PublicKey\u003e for Address {\n    fn from(key: identity::PublicKey) -\u003e Address {\n        Self {\n            peer_id: PeerId::from_public_key(\u0026key).into(),\n        }\n    }\n}\n\nimpl From\u003cPeerId\u003e for Address {\n    fn from(peer_id: PeerId) -\u003e Address {\n        Self {\n            peer_id: peer_id.into(),\n        }\n    }\n}\n\npub type Ordinal = u128;\n\n// this struct exists only for generating a hash\n#[derive(Serialize)]\nstruct PartialHeader {\n    parent_hash: HashDigest,\n    transactions_hash: HashDigest,\n    committer: Address,\n    timestamp: u64,\n    ordinal: Ordinal,\n    nonce: u128,\n}\n\nimpl From\u003cHeader\u003e for PartialHeader {\n    fn from(header: Header) -\u003e Self {\n        PartialHeader {\n            parent_hash: header.parent_hash,\n            transactions_hash: header.transactions_hash,\n            committer: header.committer,\n            timestamp: header.timestamp,\n            ordinal: header.ordinal,\n            nonce: header.nonce,\n        }\n    }\n}\n\nfn calculate_hash(incomplete_header: \u0026PartialHeader) -\u003e Result\u003cHashDigest, bincode::Error\u003e {\n    let bytes = bincode::serialize(incomplete_header)?;\n    Ok(HashDigest::new(\u0026bytes))\n}\n\n/// struct Header define the header of a block\n#[derive(Serialize, Deserialize, Debug, Clone, Hash, PartialEq, Eq, Copy, Decode, Encode)]\npub struct Header {\n    /// 256-bit Keccak Hash of the parent block (previous [`Block`][block]'s [`hash`][hash])\n    ///\n    /// [block]: crate::structures::block::Block\n    /// [hash]: crate::structures::header::Header::hash\n    pub parent_hash: HashDigest,\n    /// 256-bit Keccak Hash of the [`Block`][block]'s [`transactions`][transactions]\n    ///\n    /// [block]: crate::structures::block::Block\n    /// [transactions]: crate::structures::block::Block::transactions\n    pub transactions_hash: HashDigest,\n    /// the committer node's PeerId\n    pub committer: Address,\n    /// Unix timestamp in seconds, see \u003chttps://en.wikipedia.org/wiki/Unix_time\u003e for more.\n    pub timestamp: u64,\n    /// block sequence number, the current block number should be the parent (previous) block number plus 1\n    pub ordinal: Ordinal,\n    /// Adds a salt to harden\n    nonce: u128,\n    /// The block id, 256-bit Keccak Hash of the Current Block Header, excluding itself\n    hash: HashDigest,\n}\n\nimpl Header {\n    pub fn new(\n        parent_hash: HashDigest,\n        transactions_hash: HashDigest,\n        committer: Address,\n        ordinal: u128,\n    ) -\u003e Self {\n        let partial = PartialHeader {\n            parent_hash,\n            transactions_hash,\n            committer,\n            timestamp: SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            ordinal,\n            nonce: rand::thread_rng().gen::\u003cu128\u003e(),\n        };\n        Self {\n            parent_hash: partial.parent_hash,\n            transactions_hash: partial.transactions_hash,\n            committer: partial.committer,\n            timestamp: partial.timestamp,\n            ordinal: partial.ordinal,\n            nonce: partial.nonce,\n            hash: calculate_hash(\u0026partial).unwrap(),\n        }\n    }\n\n    pub fn hash(\u0026self) -\u003e HashDigest {\n        self.hash\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use libp2p::identity;\n\n    #[test]\n    fn test_build_block_header() {\n        let keypair = identity::ed25519::Keypair::generate();\n        let local_id = Address::from(identity::PublicKey::Ed25519(keypair.public()));\n\n        let header = Header::new(HashDigest::new(b\"\"), HashDigest::new(b\"\"), local_id, 5);\n\n        let partial: PartialHeader = header.clone().into();\n        let expected_hash = calculate_hash(\u0026partial).unwrap();\n\n        assert_eq!(5, header.ordinal);\n        assert_eq!(expected_hash, header.hash());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","structures","transaction.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse codec::{Decode, Encode};\nuse libp2p::identity;\nuse rand::Rng;\nuse serde::{Deserialize, Serialize};\nuse std::time::{SystemTime, UNIX_EPOCH};\n\nuse super::header::Address;\nuse crate::crypto::hash_algorithm::HashDigest;\nuse crate::signature::Signature;\n\n#[derive(Serialize, Deserialize, Debug, Clone, Hash, PartialEq, Eq, Copy, Decode, Encode)]\npub enum TransactionType {\n    Create,\n    AddAuthority,\n    RevokeAuthority,\n}\n\n// Temporary structure to be able to calculate the hash of a transaction\n#[derive(Serialize)]\nstruct PartialTransaction {\n    type_id: TransactionType,\n    submitter: Address,\n    timestamp: u64,\n    payload: Vec\u003cu8\u003e,\n    nonce: u128,\n}\n\nimpl PartialTransaction {\n    fn convert_to_transaction(\n        self,\n        ed25519_keypair: \u0026identity::ed25519::Keypair,\n    ) -\u003e Result\u003cTransaction, bincode::Error\u003e {\n        let hash = calculate_hash(\u0026self)?;\n        Ok(Transaction {\n            type_id: self.type_id,\n            submitter: self.submitter,\n            timestamp: self.timestamp,\n            payload: self.payload,\n            nonce: self.nonce,\n            hash,\n            signature: Signature::new(\u0026bincode::serialize(\u0026hash)?, ed25519_keypair),\n        })\n    }\n}\n\nimpl From\u003cTransaction\u003e for PartialTransaction {\n    fn from(transaction: Transaction) -\u003e Self {\n        PartialTransaction {\n            type_id: transaction.type_id,\n            submitter: transaction.submitter,\n            timestamp: transaction.timestamp,\n            payload: transaction.payload,\n            nonce: transaction.nonce,\n        }\n    }\n}\n\nfn calculate_hash(\n    incomplete_transaction: \u0026PartialTransaction,\n) -\u003e Result\u003cHashDigest, bincode::Error\u003e {\n    let bytes = bincode::serialize(incomplete_transaction)?;\n    Ok(HashDigest::new(\u0026bytes))\n}\n\npub type TransactionSignature = Signature;\n\n#[derive(Serialize, Deserialize, Debug, Clone, Hash, PartialEq, Eq, Decode, Encode)]\npub struct Transaction {\n    type_id: TransactionType,\n    submitter: Address,\n    timestamp: u64,\n    payload: Vec\u003cu8\u003e,\n    nonce: u128, // Adds a salt to harden\n    hash: HashDigest,\n    signature: TransactionSignature,\n}\nimpl Transaction {\n    pub fn new(\n        type_id: TransactionType,\n        submitter: Address,\n        payload: Vec\u003cu8\u003e,\n        ed25519_keypair: \u0026identity::ed25519::Keypair,\n    ) -\u003e Self {\n        let partial_transaction = PartialTransaction {\n            type_id,\n            submitter,\n            timestamp: SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            payload,\n            nonce: rand::thread_rng().gen::\u003cu128\u003e(),\n        };\n        partial_transaction\n            .convert_to_transaction(ed25519_keypair)\n            .unwrap()\n    }\n    pub fn hash(\u0026self) -\u003e HashDigest {\n        self.hash\n    }\n    pub fn signature(\u0026self) -\u003e TransactionSignature {\n        self.signature.clone()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_transaction_new() {\n        let keypair = identity::ed25519::Keypair::generate();\n        let local_id = Address::from(identity::PublicKey::Ed25519(keypair.public()));\n\n        let transaction = Transaction::new(\n            TransactionType::Create,\n            local_id,\n            b\"Hello First Transaction\".to_vec(),\n            \u0026keypair,\n        );\n        let partial: PartialTransaction = transaction.clone().into();\n        let expected_hash = calculate_hash(\u0026partial).unwrap();\n        let expected_signature =\n            Signature::new(\u0026bincode::serialize(\u0026expected_hash).unwrap(), \u0026keypair);\n\n        assert_eq!(expected_hash, transaction.hash());\n        assert_eq!(expected_signature, transaction.signature());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","structures.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod block;\npub mod chain;\npub mod header;\npub mod transaction;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","build_service","service.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub struct BuildService {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","build_service.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod service;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","cli_commands","config.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::fmt::{Display, Formatter};\n\nconst CONF_FILE: \u0026str = \"pyrsia-cli\";\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct CliConfig {\n    pub host: String,\n    pub port: String,\n    pub disk_allocated: String,\n}\n\nimpl Default for CliConfig {\n    fn default() -\u003e Self {\n        CliConfig {\n            host: \"localhost\".to_string(),\n            port: \"7888\".to_string(),\n            disk_allocated: \"5.84 GB\".to_string(),\n        }\n    }\n}\n\nimpl Display for CliConfig {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let config_toml = toml::to_string_pretty(\u0026self).expect(\"toml format error\");\n        write!(f, \"{}\", config_toml)\n    }\n}\n\npub fn add_config(new_cfg: CliConfig) -\u003e Result\u003c()\u003e {\n    let mut cfg: CliConfig = confy::load(CONF_FILE)?;\n    if !new_cfg.host.is_empty() {\n        cfg.host = new_cfg.host\n    }\n\n    if !new_cfg.port.is_empty() {\n        cfg.port = new_cfg.port\n    }\n    // need more validation for checking units\n    if !new_cfg.disk_allocated.is_empty() {\n        cfg.disk_allocated = new_cfg.disk_allocated\n    }\n\n    confy::store(CONF_FILE, \u0026cfg)?;\n\n    Ok(())\n}\n\npub fn get_config() -\u003e Result\u003cCliConfig\u003e {\n    let cfg: CliConfig = confy::load(CONF_FILE)?;\n\n    Ok(cfg)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use assay::assay;\n    use directories::ProjectDirs;\n    use std::path::PathBuf;\n\n    fn tear_down() {\n        let config_dir_str = get_configuration_directory();\n\n        let path: PathBuf = [\n            config_dir_str.to_owned(),\n            format!(\"{}.toml\", CONF_FILE.to_owned()),\n        ]\n        .iter()\n        .collect();\n\n        if path.exists() {\n            std::fs::remove_dir_all(path.parent().unwrap()).expect(\"Failed to remove directory\");\n        }\n    }\n\n    #[assay(teardown = tear_down())]\n    fn test_config_file_update() {\n        let cfg: CliConfig = get_config().expect(\"could not get conf file\");\n        let cfg2: CliConfig = CliConfig {\n            port: \"7888\".to_string(),\n            ..cfg.clone()\n        };\n        let cfg3: CliConfig = CliConfig {\n            port: \"7878\".to_string(),\n            ..cfg.clone()\n        };\n\n        add_config(cfg2.clone()).expect(\"could not update conf file\");\n        assert_eq!(cfg2.port, \"7888\".to_string());\n        add_config(cfg3).expect(\"could not update conf file\");\n        let new_cfg: CliConfig = get_config().expect(\"could not get conf file\");\n        assert_eq!(new_cfg.port, \"7878\".to_string());\n    }\n\n    fn get_configuration_directory() -\u003e String {\n        let project = ProjectDirs::from(\"rs\", \"\", CONF_FILE).expect(\"bad config dir\");\n\n        let config_dir_option = project.config_dir().to_str();\n\n        if let Some(x) = config_dir_option {\n            return x.to_string();\n        } else {\n            return \"\".to_string();\n        }\n    }\n}\n","traces":[{"line":31,"address":[5891313,5891072],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":33,"address":[5891085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[5891107],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[5891131],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[5891328,5891564],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":42,"address":[5891353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[5891531,5891403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[5891600,5893141],"length":1,"stats":{"Line":0},"fn_name":"add_config"},{"line":48,"address":[5891751,5891937,5891612,5892072],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[5892281,5891923,5892122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[5892195,5892283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[5892172,5892353,5892474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[5892387,5892476],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[5892679,5892364,5892546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[5892592,5892684],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[5892766,5892823,5892969,5892552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[5892799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[5893488],"length":1,"stats":{"Line":0},"fn_name":"get_config"},{"line":67,"address":[5893675,5893504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[5893613],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[7155821,7154960],"length":1,"stats":{"Line":0},"fn_name":"tear_down"},{"line":80,"address":[7154967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[7155473,7155316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[7154977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[7155414,7155066,7155143,7155001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[7155611,7155543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[7155662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[5216847,5216805,5217148,5219600,5219609,5217020,5219540,5216832,5216800],"length":1,"stats":{"Line":7},"fn_name":"{closure#0}"},{"line":95,"address":[7156224],"length":1,"stats":{"Line":1},"fn_name":"test_config_file_update"},{"line":96,"address":[5217013,5217106],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[5217189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[5217432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[5217702,5217758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[5217807],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[5218567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[5218720],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[5218769,5218935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[7155856,7156190],"length":1,"stats":{"Line":0},"fn_name":"get_configuration_directory"},{"line":114,"address":[7155873],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[7155963,7156064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[7156080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[7156188,7156143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[7156155],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":43},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","cli_commands","node.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse super::config::get_config;\nuse crate::node_api::model::cli::Status;\n\npub async fn ping() -\u003e Result\u003cString, reqwest::Error\u003e {\n    //TODO: implement ping api in Node\n    let node_url = format!(\"http://{}/v2\", get_url());\n    let response = reqwest::get(node_url).await?.text().await?;\n    Ok(response)\n}\n\npub async fn peers_connected() -\u003e Result\u003cString, reqwest::Error\u003e {\n    let node_url = format!(\"http://{}/peers\", get_url());\n    let response = reqwest::get(node_url).await?.text().await?;\n    Ok(response)\n}\n\npub async fn status() -\u003e Result\u003cStatus, reqwest::Error\u003e {\n    let node_url = format!(\"http://{}/status\", get_url());\n\n    let response = reqwest::get(node_url).await?.json::\u003cStatus\u003e().await?;\n    Ok(response)\n}\n\npub fn get_url() -\u003e String {\n    let result = get_config();\n    let mut host = String::new();\n    let mut port = String::new();\n    match result {\n        Ok(data) =\u003e {\n            host = data.host;\n            port = data.port;\n        }\n        Err(error) =\u003e {\n            println!(\"Error: {}\", error);\n        }\n    };\n\n    format!(\"{}:{}\", host, port)\n}\n","traces":[{"line":20,"address":[4562494,4562480],"length":1,"stats":{"Line":0},"fn_name":"ping"},{"line":27,"address":[4562542,4562528],"length":1,"stats":{"Line":0},"fn_name":"peers_connected"},{"line":33,"address":[4562576,4562590],"length":1,"stats":{"Line":0},"fn_name":"status"},{"line":40,"address":[4563829,4562624],"length":1,"stats":{"Line":0},"fn_name":"get_url"},{"line":41,"address":[4562641],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[4562699],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[4562714],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[4562815,4562760],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4562817],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[4562904,4563220,4563311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[4563252,4563450,4563399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[4562958],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[4562987,4563109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[4563166,4563597],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":14},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","cli_commands.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod config;\npub mod node;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","docker","constants.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub const MEDIA_TYPE_BLOB_GZIPPED: \u0026str = \"application/vnd.docker.image.rootfs.diff.tar.gzip\";\npub const MEDIA_TYPE_SCHEMA_1: \u0026str = \"application/vnd.docker.distribution.manifest.v1+json\";\npub const MEDIA_TYPE_IMAGE_MANIFEST: \u0026str = \"application/vnd.docker.distribution.manifest.v2+json\";\npub const MEDIA_TYPE_MANIFEST_LIST: \u0026str =\n    \"application/vnd.docker.distribution.manifest.list.v2+json\";\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","docker","error_util.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::transparency_log::log::TransparencyLogError;\nuse log::debug;\nuse serde::{Deserialize, Serialize};\nuse std::convert::Infallible;\nuse std::error::Error;\nuse std::fmt;\nuse warp::http::StatusCode;\nuse warp::reject::Reject;\nuse warp::{Rejection, Reply};\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ErrorMessage {\n    code: RegistryErrorCode,\n    message: String,\n}\n#[derive(Debug, Deserialize, Serialize)]\npub struct ErrorMessages {\n    errors: Vec\u003cErrorMessage\u003e,\n}\n\n#[derive(Debug, Deserialize, Serialize, PartialEq)]\npub enum RegistryErrorCode {\n    BlobUnknown,\n    BlobDoesNotExist(String),\n    ManifestUnknown,\n    Unknown(String),\n}\n\nimpl fmt::Display for RegistryErrorCode {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        let printable = match \u0026self {\n            RegistryErrorCode::BlobUnknown =\u003e \"BLOB_UNKNOWN\".to_string(),\n            RegistryErrorCode::BlobDoesNotExist(hash) =\u003e format!(\"BLOB_DOES_NOT_EXIST({})\", hash),\n            RegistryErrorCode::ManifestUnknown =\u003e \"MANIFEST_UNKNOWN\".to_string(),\n            RegistryErrorCode::Unknown(m) =\u003e format!(\"UNKNOWN({})\", m),\n        };\n        write!(f, \"{}\", printable)\n    }\n}\n\n#[derive(Debug, PartialEq)]\npub struct RegistryError {\n    pub code: RegistryErrorCode,\n}\n\nimpl From\u003canyhow::Error\u003e for RegistryError {\n    fn from(err: anyhow::Error) -\u003e RegistryError {\n        RegistryError {\n            code: RegistryErrorCode::Unknown(err.to_string()),\n        }\n    }\n}\n\nimpl From\u003cTransparencyLogError\u003e for RegistryError {\n    fn from(err: TransparencyLogError) -\u003e RegistryError {\n        RegistryError {\n            code: RegistryErrorCode::Unknown(err.to_string()),\n        }\n    }\n}\n\nimpl From\u003chex::FromHexError\u003e for RegistryError {\n    fn from(err: hex::FromHexError) -\u003e RegistryError {\n        RegistryError {\n            code: RegistryErrorCode::Unknown(err.to_string()),\n        }\n    }\n}\n\nimpl From\u003creqwest::Error\u003e for RegistryError {\n    fn from(err: reqwest::Error) -\u003e RegistryError {\n        RegistryError {\n            code: RegistryErrorCode::Unknown(err.to_string()),\n        }\n    }\n}\n\nimpl From\u003cstd::io::Error\u003e for RegistryError {\n    fn from(err: std::io::Error) -\u003e RegistryError {\n        RegistryError {\n            code: RegistryErrorCode::Unknown(err.to_string()),\n        }\n    }\n}\n\nimpl From\u003cBox\u003cdyn Error\u003e\u003e for RegistryError {\n    fn from(err: Box\u003cdyn Error\u003e) -\u003e RegistryError {\n        RegistryError {\n            code: RegistryErrorCode::Unknown(err.to_string()),\n        }\n    }\n}\n\nimpl From\u003cBox\u003cdyn Error + Send\u003e\u003e for RegistryError {\n    fn from(err: Box\u003cdyn Error + Send\u003e) -\u003e RegistryError {\n        RegistryError {\n            code: RegistryErrorCode::Unknown(err.to_string()),\n        }\n    }\n}\n\nimpl Reject for RegistryError {}\n\npub async fn custom_recover(err: Rejection) -\u003e Result\u003cimpl Reply, Infallible\u003e {\n    let mut status_code = StatusCode::INTERNAL_SERVER_ERROR;\n    let mut error_message = ErrorMessage {\n        code: RegistryErrorCode::Unknown(\"\".to_string()),\n        message: \"\".to_string(),\n    };\n\n    debug!(\"Rejection: {:?}\", err);\n    if let Some(e) = err.find::\u003cRegistryError\u003e() {\n        match \u0026e.code {\n            RegistryErrorCode::BlobUnknown =\u003e {\n                status_code = StatusCode::NOT_FOUND;\n                error_message.code = RegistryErrorCode::BlobUnknown;\n            }\n            RegistryErrorCode::BlobDoesNotExist(hash) =\u003e {\n                status_code = StatusCode::NOT_FOUND;\n                error_message.code = RegistryErrorCode::BlobDoesNotExist(hash.to_string());\n            }\n            RegistryErrorCode::ManifestUnknown =\u003e {\n                status_code = StatusCode::NOT_FOUND;\n                error_message.code = RegistryErrorCode::ManifestUnknown;\n            }\n            RegistryErrorCode::Unknown(m) =\u003e {\n                error_message.message = m.clone();\n            }\n        }\n    } else if let Some(e) = err.find::\u003cwarp::reject::InvalidHeader\u003e() {\n        status_code = StatusCode::BAD_REQUEST;\n        error_message.message = format!(\"{}\", e);\n    }\n\n    debug!(\"ErrorMessage: {:?}\", error_message);\n    Ok(warp::reply::with_status(\n        warp::reply::json(\u0026ErrorMessages {\n            errors: vec![error_message],\n        }),\n        status_code,\n    )\n    .into_response())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io;\n    use std::str;\n    use warp::reply::Response;\n\n    #[test]\n    fn from_io_error() {\n        let io_error_1 = io::Error::new(io::ErrorKind::Interrupted, \"operation interrupted\");\n        let io_error_2 = io::Error::new(io::ErrorKind::Interrupted, \"operation interrupted\");\n\n        let registry_error: RegistryError = io_error_1.into();\n        assert_eq!(\n            registry_error.code,\n            RegistryErrorCode::Unknown(io_error_2.to_string())\n        );\n    }\n\n    #[test]\n    fn from_from_hex_error() {\n        let from_hex_error = hex::FromHexError::OddLength;\n\n        let registry_error: RegistryError = from_hex_error.into();\n        assert_eq!(\n            registry_error.code,\n            RegistryErrorCode::Unknown(from_hex_error.to_string())\n        );\n    }\n\n    #[test]\n    fn from_anyhow_error() {\n        let from_hex_error_1 = hex::FromHexError::OddLength;\n        let anyhow_error_1: anyhow::Error = from_hex_error_1.into();\n\n        let from_hex_error_2 = hex::FromHexError::OddLength;\n        let anyhow_error_2: anyhow::Error = from_hex_error_2.into();\n\n        let registry_error: RegistryError = anyhow_error_1.into();\n        assert_eq!(\n            registry_error.code,\n            RegistryErrorCode::Unknown(anyhow_error_2.to_string())\n        );\n    }\n\n    #[test]\n    fn from_transparency_log_error() {\n        let transparency_log_error_1 = TransparencyLogError::NotFound {\n            id: String::from(\"artifact_id\"),\n        };\n        let transparency_log_error_2 = TransparencyLogError::NotFound {\n            id: String::from(\"artifact_id\"),\n        };\n\n        let registry_error: RegistryError = transparency_log_error_1.into();\n        assert_eq!(\n            registry_error.code,\n            RegistryErrorCode::Unknown(transparency_log_error_2.to_string())\n        );\n    }\n\n    #[tokio::test]\n    async fn custom_recover_from_registry_error_for_blob_unknown() {\n        let registry_error = RegistryError {\n            code: RegistryErrorCode::BlobUnknown,\n        };\n\n        let expected_body = serde_json::to_string(\u0026ErrorMessages {\n            errors: vec![ErrorMessage {\n                code: RegistryErrorCode::BlobUnknown,\n                message: \"\".to_string(),\n            }],\n        })\n        .expect(\"Generating JSON body should not fail.\");\n\n        let response = custom_recover(registry_error.into())\n            .await\n            .expect(\"Reply should be created.\")\n            .into_response();\n\n        verify_recover_response(response, expected_body, StatusCode::NOT_FOUND).await;\n    }\n\n    #[tokio::test]\n    async fn custom_recover_from_registry_error_for_blob_does_not_exist() {\n        let registry_error = RegistryError {\n            code: RegistryErrorCode::BlobDoesNotExist(String::from(\"non_existing_blob_hash\")),\n        };\n\n        let expected_body = serde_json::to_string(\u0026ErrorMessages {\n            errors: vec![ErrorMessage {\n                code: RegistryErrorCode::BlobDoesNotExist(String::from(\"non_existing_blob_hash\")),\n                message: \"\".to_string(),\n            }],\n        })\n        .expect(\"Generating JSON body should not fail.\");\n\n        let response = custom_recover(registry_error.into())\n            .await\n            .expect(\"Reply should be created.\")\n            .into_response();\n\n        verify_recover_response(response, expected_body, StatusCode::NOT_FOUND).await;\n    }\n\n    #[tokio::test]\n    async fn custom_recover_from_registry_error_for_manifest_unknown() {\n        let registry_error = RegistryError {\n            code: RegistryErrorCode::ManifestUnknown,\n        };\n\n        let expected_body = serde_json::to_string(\u0026ErrorMessages {\n            errors: vec![ErrorMessage {\n                code: RegistryErrorCode::ManifestUnknown,\n                message: \"\".to_string(),\n            }],\n        })\n        .expect(\"Generating JSON body should not fail.\");\n\n        let response = custom_recover(registry_error.into())\n            .await\n            .expect(\"Reply should be created.\")\n            .into_response();\n\n        verify_recover_response(response, expected_body, StatusCode::NOT_FOUND).await;\n    }\n\n    #[tokio::test]\n    async fn custom_recover_from_registry_error_for_unknown() {\n        let registry_error = RegistryError {\n            code: RegistryErrorCode::Unknown(String::from(\"unknown_error\")),\n        };\n\n        let expected_body = serde_json::to_string(\u0026ErrorMessages {\n            errors: vec![ErrorMessage {\n                code: RegistryErrorCode::Unknown(\"\".to_string()),\n                message: String::from(\"unknown_error\"),\n            }],\n        })\n        .expect(\"Generating JSON body should not fail.\");\n\n        let response = custom_recover(registry_error.into())\n            .await\n            .expect(\"Reply should be created.\")\n            .into_response();\n\n        verify_recover_response(response, expected_body, StatusCode::INTERNAL_SERVER_ERROR).await;\n    }\n\n    #[derive(Debug)]\n    struct UnhandledErrorForCustomRecover {}\n    impl Reject for UnhandledErrorForCustomRecover {}\n\n    #[tokio::test]\n    async fn custom_recover_from_registry_error_for_unhandled_error() {\n        let unhandled_error = UnhandledErrorForCustomRecover {};\n\n        let expected_body = serde_json::to_string(\u0026ErrorMessages {\n            errors: vec![ErrorMessage {\n                code: RegistryErrorCode::Unknown(\"\".to_string()),\n                message: String::from(\"\"),\n            }],\n        })\n        .expect(\"Generating JSON body should not fail.\");\n\n        let response = custom_recover(unhandled_error.into())\n            .await\n            .expect(\"Reply should be created.\")\n            .into_response();\n\n        verify_recover_response(response, expected_body, StatusCode::INTERNAL_SERVER_ERROR).await;\n    }\n\n    async fn verify_recover_response(\n        response: Response,\n        expected_body: String,\n        expected_status: StatusCode,\n    ) {\n        let status = response.status();\n        let actual_body_bytes = hyper::body::to_bytes(response.into_body())\n            .await\n            .expect(\"Response body to be converted to bytes\");\n        let actual_body_str = str::from_utf8(\u0026actual_body_bytes)\n            .map(str::to_owned)\n            .expect(\"Response body to be converted to string\");\n        assert_eq!(status, expected_status);\n        assert_eq!(actual_body_str, expected_body);\n    }\n}\n","traces":[{"line":46,"address":[7144688,7145302],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":47,"address":[7144713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[7144749],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[7145046,7144776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[7144816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[7144843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[7145010,7145171,7145266],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[7145344,7145501],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":65,"address":[7145373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[7145686,7145536],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":73,"address":[7145560],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[7145712],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":81,"address":[7145755],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[7145872,7146029],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":89,"address":[7145901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[7146064,7146225],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":97,"address":[7146083],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[7146416,7146256],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":105,"address":[7146289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[7146608,7146448],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":113,"address":[7146481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[6459233,6461704,6462223,6459111,6459056],"length":1,"stats":{"Line":5},"fn_name":"{async_fn#0}"},{"line":121,"address":[6459197],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[6459307,6459207],"length":1,"stats":{"Line":2},"fn_name":null},{"line":124,"address":[6459351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[6459500,6459634,6459588,6459722],"length":1,"stats":{"Line":3},"fn_name":null},{"line":128,"address":[6459947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":129,"address":[6460019,6460488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[6461297],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[6460490],"length":1,"stats":{"Line":1},"fn_name":null},{"line":132,"address":[6461302,6461225,6460500],"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":[6460535],"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":[6460547],"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":[6461126,6460565,6460990],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[6460886],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[6460575],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[6460814,6460891,6460585],"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":[6460620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[6460731,6460632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[6460158,6460056,6460400],"length":1,"stats":{"Line":2},"fn_name":null},{"line":147,"address":[6460123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[6460141,6460405,6460211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[6461487,6460160,6461405],"length":1,"stats":{"Line":3},"fn_name":null},{"line":152,"address":[6462052,6462155],"length":1,"stats":{"Line":2},"fn_name":null},{"line":153,"address":[6461929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[6461733],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[4586282,4585728],"length":1,"stats":{"Line":3},"fn_name":"from_io_error"},{"line":170,"address":[4585735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[4585784],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[4585832],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[4586016,4586122],"length":1,"stats":{"Line":2},"fn_name":null},{"line":176,"address":[4585972,4585908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":181,"address":[4586664,4586320],"length":1,"stats":{"Line":3},"fn_name":"from_from_hex_error"},{"line":182,"address":[4586327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[4586335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[4586543,4586441],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[4586388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[4587267,4586688],"length":1,"stats":{"Line":3},"fn_name":"from_anyhow_error"},{"line":193,"address":[4586695],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[4586711],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[4586749],"length":1,"stats":{"Line":1},"fn_name":null},{"line":197,"address":[4586757],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[4586799],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[4586985,4587105],"length":1,"stats":{"Line":2},"fn_name":null},{"line":202,"address":[4586894,4586941],"length":1,"stats":{"Line":2},"fn_name":null},{"line":207,"address":[4587984,4587296],"length":1,"stats":{"Line":3},"fn_name":"from_transparency_log_error"},{"line":209,"address":[4587311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":[4587373],"length":1,"stats":{"Line":1},"fn_name":null},{"line":215,"address":[4587444],"length":1,"stats":{"Line":1},"fn_name":null},{"line":216,"address":[4587823,4587703],"length":1,"stats":{"Line":2},"fn_name":null},{"line":218,"address":[4587610,4587659],"length":1,"stats":{"Line":2},"fn_name":null},{"line":222,"address":[4588322,4588173],"length":1,"stats":{"Line":1},"fn_name":null},{"line":223,"address":[4588031,4588417,4588016],"length":1,"stats":{"Line":6},"fn_name":"custom_recover_from_registry_error_for_blob_unknown"},{"line":228,"address":[6801039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[6801029,6800534,6800856],"length":1,"stats":{"Line":2},"fn_name":null},{"line":230,"address":[6800764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[6800776],"length":1,"stats":{"Line":1},"fn_name":null},{"line":236,"address":[6801215,6801321,6800576,6800656],"length":1,"stats":{"Line":3},"fn_name":null},{"line":241,"address":[4588211,4588154,4588023,4588065],"length":1,"stats":{"Line":5},"fn_name":null},{"line":244,"address":[4588754,4588605],"length":1,"stats":{"Line":1},"fn_name":null},{"line":245,"address":[4588448,4588463,4588849],"length":1,"stats":{"Line":6},"fn_name":"custom_recover_from_registry_error_for_blob_does_not_exist"},{"line":247,"address":[6802412,6802655],"length":1,"stats":{"Line":2},"fn_name":null},{"line":250,"address":[6803184],"length":1,"stats":{"Line":1},"fn_name":null},{"line":251,"address":[6802967,6803174,6802745],"length":1,"stats":{"Line":1},"fn_name":null},{"line":252,"address":[6802892,6802819],"length":1,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[6802936],"length":1,"stats":{"Line":1},"fn_name":null},{"line":258,"address":[6803466,6802549,6802469,6803360],"length":1,"stats":{"Line":3},"fn_name":null},{"line":263,"address":[4588643,4588455,4588497,4588586],"length":1,"stats":{"Line":5},"fn_name":null},{"line":266,"address":[4589037,4589186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":267,"address":[4588880,4588895,4589281],"length":1,"stats":{"Line":6},"fn_name":"custom_recover_from_registry_error_for_manifest_unknown"},{"line":272,"address":[6805103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":273,"address":[6804598,6804920,6805093],"length":1,"stats":{"Line":2},"fn_name":null},{"line":274,"address":[6804828],"length":1,"stats":{"Line":1},"fn_name":null},{"line":275,"address":[6804840],"length":1,"stats":{"Line":1},"fn_name":null},{"line":280,"address":[6804640,6804720,6805385,6805279],"length":1,"stats":{"Line":3},"fn_name":null},{"line":285,"address":[4588887,4589018,4588929,4589075],"length":1,"stats":{"Line":5},"fn_name":null},{"line":288,"address":[4589469,4589618],"length":1,"stats":{"Line":1},"fn_name":null},{"line":289,"address":[4589327,4589312,4589713],"length":1,"stats":{"Line":6},"fn_name":"custom_recover_from_registry_error_for_unknown"},{"line":291,"address":[6806476,6806719],"length":1,"stats":{"Line":2},"fn_name":null},{"line":294,"address":[6807239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[6806809,6807031],"length":1,"stats":{"Line":1},"fn_name":null},{"line":296,"address":[6806955,6806883],"length":1,"stats":{"Line":2},"fn_name":null},{"line":297,"address":[6806999],"length":1,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[6807521,6807415,6806613,6806533],"length":1,"stats":{"Line":3},"fn_name":null},{"line":307,"address":[4589319,4589507,4589361,4589450],"length":1,"stats":{"Line":5},"fn_name":null},{"line":314,"address":[4590029,4590178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":315,"address":[4590273,4589872,4589887],"length":1,"stats":{"Line":6},"fn_name":"custom_recover_from_registry_error_for_unhandled_error"},{"line":316,"address":[6808580],"length":1,"stats":{"Line":1},"fn_name":null},{"line":318,"address":[6809185],"length":1,"stats":{"Line":1},"fn_name":null},{"line":319,"address":[6808594,6808977],"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":[6808902,6808824],"length":1,"stats":{"Line":2},"fn_name":null},{"line":321,"address":[6808946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":326,"address":[6808716,6809353,6808636,6809415],"length":1,"stats":{"Line":3},"fn_name":null},{"line":331,"address":[4590067,4590010,4589921,4589879],"length":1,"stats":{"Line":5},"fn_name":null},{"line":334,"address":[4585584],"length":1,"stats":{"Line":1},"fn_name":"verify_recover_response"},{"line":339,"address":[6798795,6798974],"length":1,"stats":{"Line":2},"fn_name":null},{"line":340,"address":[6799099,6798846,6798977],"length":1,"stats":{"Line":2},"fn_name":null},{"line":343,"address":[6799591,6799488],"length":1,"stats":{"Line":2},"fn_name":null},{"line":346,"address":[6799645,6799884],"length":1,"stats":{"Line":1},"fn_name":null},{"line":347,"address":[6799940,6799974,6799792],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":105,"coverable":120},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","docker","v2","handlers","blobs.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::artifact_service::handlers::get_artifact;\nuse crate::artifact_service::storage::ArtifactStorage;\nuse crate::docker::error_util::{RegistryError, RegistryErrorCode};\nuse crate::network::client::Client;\nuse crate::transparency_log::log::TransparencyLog;\nuse futures::lock::Mutex;\nuse log::debug;\nuse std::result::Result;\nuse std::sync::Arc;\nuse warp::{http::StatusCode, Rejection, Reply};\n\npub async fn handle_get_blobs(\n    transparency_log: Arc\u003cMutex\u003cTransparencyLog\u003e\u003e,\n    p2p_client: Client,\n    artifact_storage: ArtifactStorage,\n    hash: String,\n) -\u003e Result\u003cimpl Reply, Rejection\u003e {\n    debug!(\"Getting blob with hash : {:?}\", hash);\n\n    let blob_content = get_artifact(\n        transparency_log,\n        p2p_client,\n        \u0026artifact_storage,\n        \u0026get_namespace_specific_id(\u0026hash),\n    )\n    .await\n    .map_err(|_| {\n        warp::reject::custom(RegistryError {\n            code: RegistryErrorCode::BlobUnknown,\n        })\n    })?;\n\n    Ok(warp::http::response::Builder::new()\n        .header(\"Content-Type\", \"application/octet-stream\")\n        .status(StatusCode::OK)\n        .body(blob_content.to_vec())\n        .unwrap())\n}\n\nfn get_namespace_specific_id(hash: \u0026str) -\u003e String {\n    format!(\"DOCKER::BLOB::{}\", hash)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::artifact_service::service::{Hash, HashAlgorithm};\n    use crate::util::test_util;\n    use anyhow::Context;\n    use assay::assay;\n    use futures::channel::mpsc;\n    use hyper::header::HeaderValue;\n    use libp2p::identity::Keypair;\n    use std::borrow::Borrow;\n    use std::fs::File;\n    use std::path::PathBuf;\n\n    const VALID_ARTIFACT_HASH: [u8; 32] = [\n        0x86, 0x5c, 0x8d, 0x98, 0x8b, 0xe4, 0x66, 0x9f, 0x3e, 0x48, 0xf7, 0x3b, 0x98, 0xf9, 0xbc,\n        0x25, 0x7, 0xbe, 0x2, 0x46, 0xea, 0x35, 0xe0, 0x9, 0x8c, 0xf6, 0x5, 0x4d, 0x36, 0x44, 0xc1,\n        0x4f,\n    ];\n\n    #[test]\n    fn test_get_namespace_specific_id() {\n        let hash = \"hash\";\n\n        assert_eq!(\n            get_namespace_specific_id(hash),\n            format!(\"DOCKER::BLOB::{}\", hash)\n        );\n    }\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-node\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    #[tokio::test]\n    async fn test_handle_get_blobs_unknown_in_artifact_service() {\n        let hash = \"7300a197d7deb39371d4683d60f60f2fbbfd7541837ceb2278c12014e94e657b\";\n        let namespace_specific_id = format!(\"DOCKER::BLOB::{}\", hash);\n\n        let transparency_log = Arc::new(Mutex::new(TransparencyLog::new()));\n        transparency_log\n            .lock()\n            .await\n            .add_artifact(\u0026namespace_specific_id, hash)?;\n\n        let (sender, _) = mpsc::channel(1);\n        let p2p_client = Client {\n            sender,\n            local_peer_id: Keypair::generate_ed25519().public().to_peer_id(),\n        };\n\n        let artifact_storage = ArtifactStorage::new()?;\n\n        let result = handle_get_blobs(\n            transparency_log,\n            p2p_client,\n            artifact_storage,\n            hash.to_string(),\n        )\n        .await;\n\n        assert!(result.is_err());\n        let rejection = result.err().unwrap();\n        let registry_error = rejection.find::\u003cRegistryError\u003e().unwrap().borrow();\n        assert_eq!(\n            *registry_error,\n            RegistryError {\n                code: RegistryErrorCode::BlobUnknown,\n            }\n        );\n    }\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-node\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    #[tokio::test]\n    async fn test_handle_get_blobs() {\n        let hash = \"865c8d988be4669f3e48f73b98f9bc2507be0246ea35e0098cf6054d3644c14f\";\n        let namespace_specific_id = format!(\"DOCKER::BLOB::{}\", hash);\n\n        let transparency_log = Arc::new(Mutex::new(TransparencyLog::new()));\n        transparency_log\n            .lock()\n            .await\n            .add_artifact(\u0026namespace_specific_id, hash)?;\n\n        let (sender, _) = mpsc::channel(1);\n        let p2p_client = Client {\n            sender,\n            local_peer_id: Keypair::generate_ed25519().public().to_peer_id(),\n        };\n\n        let artifact_storage = ArtifactStorage::new()?;\n        create_artifact(\u0026artifact_storage)?;\n\n        let result = handle_get_blobs(\n            transparency_log,\n            p2p_client,\n            artifact_storage,\n            hash.to_string(),\n        )\n        .await;\n\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_response();\n        assert_eq!(response.status(), StatusCode::OK);\n        assert_eq!(\n            response.headers().get(\"Content-Type\"),\n            Some(\u0026HeaderValue::from_static(\"application/octet-stream\"))\n        );\n    }\n\n    fn get_file_reader() -\u003e Result\u003cFile, anyhow::Error\u003e {\n        // test artifact file in resources/test dir\n        let mut curr_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n        curr_dir.push(\"tests/resources/artifact_test.json\");\n\n        let path = String::from(curr_dir.to_string_lossy());\n        let reader = File::open(path.as_str()).unwrap();\n        Ok(reader)\n    }\n\n    fn create_artifact(artifact_storage: \u0026ArtifactStorage) -\u003e Result\u003c(), anyhow::Error\u003e {\n        let hash = Hash::new(HashAlgorithm::SHA256, \u0026VALID_ARTIFACT_HASH)?;\n        artifact_storage\n            .push_artifact(\u0026mut get_file_reader()?, \u0026hash)\n            .context(\"Error while pushing artifact\")\n    }\n}\n","traces":[{"line":28,"address":[6346464],"length":1,"stats":{"Line":0},"fn_name":"handle_get_blobs"},{"line":34,"address":[4879651,4879781,4879466,4879705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[4880017],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[4880048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[4880175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[4880183,4880284],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[4881904,4882000],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":44,"address":[4881922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4881913],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[4881282,4881542,4881664,4881330,4881410,4881589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[4881442],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[4881619,4881629,4881450,4881378,4881581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[6346608],"length":1,"stats":{"Line":1},"fn_name":"get_namespace_specific_id"},{"line":57,"address":[6346632],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[7099125,7099120],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":82,"address":[7243927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[7244059,7244149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[7243948],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[7244097,7243968],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[7100333,7100633,7099837,7099926,7099403,7100479,7099157,7100772,7100014,7104617,7099184,7099199,7099514,7104608,7099152,7100256,7100231,7104582,7100272,7100133,7099445],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":95,"address":[7100224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[7100395],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[7100431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[7100449,7100709,7100813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[7100880,7100967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[7101683,7101033,7101351,7101212,7101566,7101437],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[7101753,7101460,7101657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[7101822],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[7101996,7101932,7102074],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[7102718,7102811,7102433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[7102545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[7102569],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[7102693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[7103523,7103670],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[7103593,7103718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[7103764,7103858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[7103991,7103883],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[7105446,7104923,7106153,7104965,7105853,7111113,7104719,7104672,7105999,7105792,7106292,7111078,7105534,7105751,7104704,7111104,7105776,7104677,7105653,7105034,7105357],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":140,"address":[7105744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[7105915],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[7105951],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[7106229,7105969,7106333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[7106400,7106487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[7106553,7106732,7106871,7106957,7107086,7107203],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[7107273,7106980,7107177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[7107342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[7107452,7107594,7107516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[7108081,7108161,7107953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[7108214,7108066,7108541,7108458],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[7108285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[7108309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[7108433],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[7109399,7109253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[7109447,7109323],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[7109674,7109638,7109454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[7110314],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[7110220,7109644],"length":1,"stats":{"Line":0},"fn_name":null},{"line":176,"address":[7110263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[7243170,7242784],"length":1,"stats":{"Line":0},"fn_name":"get_file_reader"},{"line":182,"address":[7242791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[7242814],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[7242920,7242847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":186,"address":[7243052,7242956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[7243129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[7243216,7243605],"length":1,"stats":{"Line":0},"fn_name":"create_artifact"},{"line":191,"address":[7243236,7243390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[7243661,7243777,7243840],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[7243373,7243448,7243557,7243620,7243673],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":11,"coverable":68},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","docker","v2","handlers","manifests.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::artifact_service::handlers::get_artifact;\nuse crate::artifact_service::storage::ArtifactStorage;\nuse crate::docker::error_util::{RegistryError, RegistryErrorCode};\nuse crate::network::client::Client;\nuse crate::transparency_log::log::TransparencyLog;\nuse futures::lock::Mutex;\nuse log::debug;\nuse std::sync::Arc;\nuse warp::http::StatusCode;\nuse warp::{Rejection, Reply};\n\n// Handles GET endpoint documented at https://docs.docker.com/registry/spec/api/#manifest\npub async fn fetch_manifest(\n    transparency_log: Arc\u003cMutex\u003cTransparencyLog\u003e\u003e,\n    p2p_client: Client,\n    artifact_storage: ArtifactStorage,\n    name: String,\n    tag: String,\n) -\u003e Result\u003cimpl Reply, Rejection\u003e {\n    debug!(\"Fetching manifest for {} with tag: {}\", name, tag);\n\n    let manifest_content = get_artifact(\n        transparency_log,\n        p2p_client,\n        \u0026artifact_storage,\n        \u0026get_namespace_specific_id(\u0026name, \u0026tag),\n    )\n    .await\n    .map_err(|_| {\n        warp::reject::custom(RegistryError {\n            code: RegistryErrorCode::ManifestUnknown,\n        })\n    })?;\n\n    let len = manifest_content.len();\n\n    Ok(warp::http::response::Builder::new()\n        .header(\n            \"Content-Type\",\n            \"application/vnd.docker.distribution.manifest.v2+json\",\n        )\n        .header(\"Content-Length\", len)\n        .status(StatusCode::OK)\n        .body(manifest_content.to_vec())\n        .unwrap())\n}\n\nfn get_namespace_specific_id(name: \u0026str, tag: \u0026str) -\u003e String {\n    format!(\"DOCKER::MANIFEST::{}::{}\", name, tag)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::artifact_service::service::{Hash, HashAlgorithm};\n    use crate::util::test_util;\n    use anyhow::Context;\n    use assay::assay;\n    use futures::channel::mpsc;\n    use hyper::header::HeaderValue;\n    use libp2p::identity::Keypair;\n    use std::borrow::Borrow;\n    use std::fs::File;\n    use std::path::PathBuf;\n\n    const VALID_ARTIFACT_HASH: [u8; 32] = [\n        0x86, 0x5c, 0x8d, 0x98, 0x8b, 0xe4, 0x66, 0x9f, 0x3e, 0x48, 0xf7, 0x3b, 0x98, 0xf9, 0xbc,\n        0x25, 0x7, 0xbe, 0x2, 0x46, 0xea, 0x35, 0xe0, 0x9, 0x8c, 0xf6, 0x5, 0x4d, 0x36, 0x44, 0xc1,\n        0x4f,\n    ];\n\n    #[test]\n    fn test_get_namespace_specific_id() {\n        let name = \"name\";\n        let tag = \"tag\";\n\n        assert_eq!(\n            get_namespace_specific_id(name, tag),\n            format!(\"DOCKER::MANIFEST::{}::{}\", name, tag)\n        );\n    }\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-node\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    #[tokio::test]\n    async fn test_fetch_manifest_unknown_in_artifact_service() {\n        let name = \"name\";\n        let tag = \"tag\";\n        let hash = \"7300a197d7deb39371d4683d60f60f2fbbfd7541837ceb2278c12014e94e657b\";\n        let namespace_specific_id = format!(\"DOCKER::MANIFEST::{}::{}\", name, tag);\n\n        let transparency_log = Arc::new(Mutex::new(TransparencyLog::new()));\n        transparency_log\n            .lock()\n            .await\n            .add_artifact(\u0026namespace_specific_id, hash)?;\n\n        let (sender, _) = mpsc::channel(1);\n        let p2p_client = Client {\n            sender,\n            local_peer_id: Keypair::generate_ed25519().public().to_peer_id(),\n        };\n\n        let artifact_storage = ArtifactStorage::new()?;\n\n        let result = fetch_manifest(\n            transparency_log,\n            p2p_client,\n            artifact_storage,\n            name.to_string(),\n            tag.to_string(),\n        )\n        .await;\n\n        assert!(result.is_err());\n        let rejection = result.err().unwrap();\n        let registry_error = rejection.find::\u003cRegistryError\u003e().unwrap().borrow();\n        assert_eq!(\n            *registry_error,\n            RegistryError {\n                code: RegistryErrorCode::ManifestUnknown,\n            }\n        );\n    }\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-node\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    #[tokio::test]\n    async fn test_fetch_manifest() {\n        let name = \"name\";\n        let tag = \"tag\";\n        let hash = \"865c8d988be4669f3e48f73b98f9bc2507be0246ea35e0098cf6054d3644c14f\";\n        let namespace_specific_id = format!(\"DOCKER::MANIFEST::{}::{}\", name, tag);\n\n        let transparency_log = Arc::new(Mutex::new(TransparencyLog::new()));\n        transparency_log\n            .lock()\n            .await\n            .add_artifact(\u0026namespace_specific_id, hash)?;\n\n        let (sender, _) = mpsc::channel(1);\n        let p2p_client = Client {\n            sender,\n            local_peer_id: Keypair::generate_ed25519().public().to_peer_id(),\n        };\n\n        let artifact_storage = ArtifactStorage::new()?;\n        create_artifact(\u0026artifact_storage)?;\n\n        let result = fetch_manifest(\n            transparency_log,\n            p2p_client,\n            artifact_storage,\n            name.to_string(),\n            tag.to_string(),\n        )\n        .await;\n\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_response();\n        assert_eq!(response.status(), StatusCode::OK);\n        assert_eq!(\n            response.headers().get(\"Content-Length\"),\n            Some(\u0026HeaderValue::from_static(\"4903\"))\n        );\n        assert_eq!(\n            response.headers().get(\"Content-Type\"),\n            Some(\u0026HeaderValue::from_static(\n                \"application/vnd.docker.distribution.manifest.v2+json\"\n            ))\n        );\n    }\n\n    fn get_file_reader() -\u003e Result\u003cFile, anyhow::Error\u003e {\n        // test artifact file in resources/test dir\n        let mut curr_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n        curr_dir.push(\"tests/resources/artifact_test.json\");\n\n        let path = String::from(curr_dir.to_string_lossy());\n        let reader = File::open(path.as_str()).unwrap();\n        Ok(reader)\n    }\n\n    fn create_artifact(artifact_storage: \u0026ArtifactStorage) -\u003e Result\u003c(), anyhow::Error\u003e {\n        let hash = Hash::new(HashAlgorithm::SHA256, \u0026VALID_ARTIFACT_HASH)?;\n        artifact_storage\n            .push_artifact(\u0026mut get_file_reader()?, \u0026hash)\n            .context(\"Error while pushing artifact\")\n    }\n}\n","traces":[{"line":29,"address":[4962272],"length":1,"stats":{"Line":0},"fn_name":"fetch_manifest"},{"line":36,"address":[4876414,4876360,4876166,4876505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[4876847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[4876878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[4877005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[4877188,4877013,4877247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4879040,4879136],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":46,"address":[4879058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[4879049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[4878381,4878311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[4878397,4878654,4878489,4878701,4878776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[4878556],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[4878452,4878741,4878731,4878693,4878564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[4962464],"length":1,"stats":{"Line":1},"fn_name":"get_namespace_specific_id"},{"line":65,"address":[4962501],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[4836512,4836517],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":90,"address":[6441207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[6441228],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[6441544,6441351],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[6441249],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[6441409,6441279],"length":1,"stats":{"Line":2},"fn_name":null},{"line":99,"address":[4837525,4836795,4836549,4837318,4837406,4842258,4842297,4842288,4837725,4838071,4836837,4836906,4837917,4836544,4837229,4836591,4837648,4836576,4837623,4837664,4838210],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":104,"address":[4837616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[4837787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[4837831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[4837849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[4837868],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[4837887,4838171,4838283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[4838421,4838508],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[4838753,4838892,4838978,4839108,4839225,4838574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[4839199,4839295,4839001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[4839364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[4839616,4839474,4839538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[4839975,4840260,4840353],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[4840087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[4840111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[4840528,4840235],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[4840536],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[4841346,4841199],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[4841269,4841394],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[4841534,4841440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[4841559,4841667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[4849865,4843533,4843333,4849888,4843879,4842603,4843431,4843472,4843037,4844018,4842357,4849897,4842645,4842384,4842352,4842399,4843214,4843725,4842714,4843456,4843126],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":152,"address":[4843424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[4843595],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[4843639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[4843657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[4843676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[4843695,4844091,4843979],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[4844229,4844316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[4845033,4844561,4844786,4844382,4844700,4844916],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[4845007,4844809,4845103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[4845172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[4845346,4845282,4845424],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[4845991,4845783,4845911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[4846044,4845896,4846288,4846371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[4846115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[4846139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[4846546,4846263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[4846554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[4847217,4847363],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[4847411,4847287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":188,"address":[4847602,4847418,4847638],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[4848278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[4848184,4847608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[4848227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[4849103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[4848980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[4849052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[6440450,6440064],"length":1,"stats":{"Line":0},"fn_name":"get_file_reader"},{"line":203,"address":[6440071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[6440094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[6440127,6440200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":207,"address":[6440236,6440332],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[6440409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":211,"address":[6440496,6440885],"length":1,"stats":{"Line":0},"fn_name":"create_artifact"},{"line":212,"address":[6440670,6440516],"length":1,"stats":{"Line":0},"fn_name":null},{"line":213,"address":[6441120,6441057,6440941],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[6440653,6440728,6440953,6440837,6440900],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":12,"coverable":79},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","docker","v2","handlers.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod blobs;\npub mod manifests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","docker","v2","routes.rs"],"content":"// all warp routes can be here\n/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::artifact_service::storage::ArtifactStorage;\nuse crate::docker::v2::handlers::{blobs::handle_get_blobs, manifests::fetch_manifest};\nuse crate::network::client::Client;\nuse crate::transparency_log::log::TransparencyLog;\nuse futures::lock::Mutex;\nuse std::sync::Arc;\nuse warp::Filter;\n\npub fn make_docker_routes(\n    transparency_log: TransparencyLog,\n    p2p_client: Client,\n    artifact_storage: ArtifactStorage,\n) -\u003e impl Filter\u003cExtract = impl warp::Reply, Error = warp::Rejection\u003e + Clone {\n    let empty_json = \"{}\";\n    let v2_base = warp::path(\"v2\")\n        .and(warp::get())\n        .and(warp::path::end())\n        .map(move || empty_json)\n        .with(warp::reply::with::header(\n            \"Content-Length\",\n            empty_json.len(),\n        ))\n        .with(warp::reply::with::header(\n            \"Content-Type\",\n            \"application/json\",\n        ));\n\n    let transparency_log_fetch_manifest = Arc::new(Mutex::new(transparency_log));\n    let transparency_log_get_blobs = transparency_log_fetch_manifest.clone();\n    let p2p_client_fetch_manifest = p2p_client.clone();\n    let artifact_storage_fetch_manifest = artifact_storage.clone();\n\n    let v2_manifests = warp::path!(\"v2\" / \"library\" / String / \"manifests\" / String)\n        .and(warp::get().or(warp::head()).unify())\n        .and_then(move |name, tag| {\n            fetch_manifest(\n                transparency_log_fetch_manifest.clone(),\n                p2p_client_fetch_manifest.clone(),\n                artifact_storage_fetch_manifest.clone(),\n                name,\n                tag,\n            )\n        });\n\n    let v2_blobs = warp::path!(\"v2\" / \"library\" / String / \"blobs\" / String)\n        .and(warp::get().or(warp::head()).unify())\n        .and(warp::path::end())\n        .and_then(move |_name, hash| {\n            handle_get_blobs(\n                transparency_log_get_blobs.clone(),\n                p2p_client.clone(),\n                artifact_storage.clone(),\n                hash,\n            )\n        });\n\n    warp::any().and(v2_base.or(v2_manifests).or(v2_blobs))\n}\n","traces":[{"line":26,"address":[4867001,4864720],"length":1,"stats":{"Line":0},"fn_name":"make_docker_routes"},{"line":31,"address":[4864747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[4864985,4864862,4865043,4865263,4865097,4865208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[4864923],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[4865022],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[4865070],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[4865157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[4865128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[4865223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4865510,4865360,4865452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[4865534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[4865628,4865580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[4865644],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[4865689,4866029,4865862,4865738],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[4865826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[4865869],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[4866044,4866103,4866381,4866238,4866220],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[4866184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[4866227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[4866250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[4866396,4866637],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":21},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","docker","v2.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod handlers;\npub mod routes;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","docker.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod constants;\npub mod error_util;\npub mod v2;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","lib.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n#![allow(mixed_script_confusables)] // This is to allow structs created by a derive macro to have private fields that begin with the grek letter π\n\npub mod artifact_service;\npub mod cli_commands;\npub mod docker;\npub mod logging;\npub mod network;\npub mod node_api;\npub mod transparency_log;\npub mod util;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","logging","http.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse log::trace;\nuse std::convert::Infallible;\nuse warp::http::HeaderMap;\nuse warp::Filter;\n\npub fn log_headers() -\u003e impl Filter\u003cExtract = (), Error = Infallible\u003e + Copy {\n    warp::header::headers_cloned()\n        .map(|headers: HeaderMap| {\n            for (k, v) in headers.iter() {\n                // Error from `to_str` should be handled properly\n                trace!(target: \"pyrsia_registry\", \"{}: {}\", k, v.to_str().expect(\"Failed to print header value\"))\n            }\n        })\n        .untuple_one()\n}\n","traces":[{"line":22,"address":[4882160],"length":1,"stats":{"Line":0},"fn_name":"log_headers"},{"line":23,"address":[4882161],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","logging.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod http;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","network","artifact_protocol.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::network::client::ArtifactType;\nuse async_trait::async_trait;\nuse futures::prelude::*;\nuse libp2p::core::upgrade::{read_length_prefixed, write_length_prefixed, ProtocolName};\nuse libp2p::request_response::RequestResponseCodec;\nuse log::debug;\nuse std::io;\n\n#[derive(Debug, Clone)]\npub struct ArtifactExchangeProtocol();\n/// The `ArtifactExchangeCodec` defines the request and response types\n/// for the [`RequestResponse`](crate::RequestResponse) protocol for\n/// exchanging artifacts. At the moment, the implementation for\n/// encoding/decoding writes all bytes of a single artifact at once.\n#[derive(Clone)]\npub struct ArtifactExchangeCodec();\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct ArtifactRequest(pub ArtifactType, pub String);\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct ArtifactResponse(pub Vec\u003cu8\u003e);\n\nimpl ProtocolName for ArtifactExchangeProtocol {\n    fn protocol_name(\u0026self) -\u003e \u0026[u8] {\n        \"/artifact-exchange/1\".as_bytes()\n    }\n}\n\n#[async_trait]\nimpl RequestResponseCodec for ArtifactExchangeCodec {\n    type Protocol = ArtifactExchangeProtocol;\n    type Request = ArtifactRequest;\n    type Response = ArtifactResponse;\n\n    async fn read_request\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026ArtifactExchangeProtocol,\n        io: \u0026mut T,\n    ) -\u003e io::Result\u003cSelf::Request\u003e\n    where\n        T: AsyncRead + Unpin + Send,\n    {\n        let type_vec = read_length_prefixed(io, 1_000).await?;\n        if type_vec.is_empty() {\n            return Err(io::ErrorKind::UnexpectedEof.into());\n        }\n\n        let hash_vec = read_length_prefixed(io, 1_000_000).await?;\n        if hash_vec.is_empty() {\n            return Err(io::ErrorKind::UnexpectedEof.into());\n        }\n\n        let artifact_type = match type_vec[0] {\n            1 =\u003e ArtifactType::Artifact,\n            _ =\u003e return Err(io::ErrorKind::InvalidData.into()),\n        };\n\n        let artifact_hash = String::from_utf8(hash_vec).unwrap();\n        debug!(\n            \"Read ArtifactRequest: {:?}={:?}\",\n            artifact_type, artifact_hash\n        );\n\n        Ok(ArtifactRequest(artifact_type, artifact_hash))\n    }\n\n    async fn read_response\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026ArtifactExchangeProtocol,\n        io: \u0026mut T,\n    ) -\u003e io::Result\u003cSelf::Response\u003e\n    where\n        T: AsyncRead + Unpin + Send,\n    {\n        let vec = read_length_prefixed(io, 100_000_000).await?;\n\n        if vec.is_empty() {\n            return Err(io::ErrorKind::UnexpectedEof.into());\n        }\n\n        Ok(ArtifactResponse(vec))\n    }\n\n    async fn write_request\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026ArtifactExchangeProtocol,\n        io: \u0026mut T,\n        ArtifactRequest(artifact_type, artifact_hash): ArtifactRequest,\n    ) -\u003e io::Result\u003c()\u003e\n    where\n        T: AsyncWrite + Unpin + Send,\n    {\n        debug!(\n            \"Write ArtifactRequest: {:?}={:?}\",\n            artifact_type, artifact_hash\n        );\n\n        let artifact_data_type: Vec\u003cu8\u003e = match artifact_type {\n            ArtifactType::Artifact =\u003e vec![1],\n        };\n\n        write_length_prefixed(io, artifact_data_type).await?;\n        write_length_prefixed(io, artifact_hash).await?;\n        io.close().await?;\n\n        Ok(())\n    }\n\n    async fn write_response\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026ArtifactExchangeProtocol,\n        io: \u0026mut T,\n        ArtifactResponse(data): ArtifactResponse,\n    ) -\u003e io::Result\u003c()\u003e\n    where\n        T: AsyncWrite + Unpin + Send,\n    {\n        write_length_prefixed(io, data).await?;\n        io.close().await?;\n\n        Ok(())\n    }\n}\n","traces":[{"line":39,"address":[7219568],"length":1,"stats":{"Line":0},"fn_name":"protocol_name"},{"line":58,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":29},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","network","behaviour.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::network::artifact_protocol::{ArtifactExchangeCodec, ArtifactRequest, ArtifactResponse};\nuse crate::network::idle_metric_protocol::{\n    IdleMetricExchangeCodec, IdleMetricRequest, IdleMetricResponse,\n};\n\nuse libp2p::identify::{Identify, IdentifyEvent};\nuse libp2p::kad::record::store::MemoryStore;\nuse libp2p::kad::{Kademlia, KademliaEvent};\nuse libp2p::request_response::{RequestResponse, RequestResponseEvent};\nuse libp2p::NetworkBehaviour;\n\n/// Defines the [`NetworkBehaviour`] to be used in the libp2p\n/// Swarm. The PyrsiaNetworkBehaviour consists of the following\n/// behaviours:\n///\n/// * [`Identify`]\n/// * [`Kademlia`]\n/// * [`RequestResponse`] for exchanging artifacts\n#[derive(NetworkBehaviour)]\n#[behaviour(out_event = \"PyrsiaNetworkEvent\")]\npub struct PyrsiaNetworkBehaviour {\n    pub identify: Identify,\n    pub kademlia: Kademlia\u003cMemoryStore\u003e,\n    pub request_response: RequestResponse\u003cArtifactExchangeCodec\u003e,\n    pub idle_metric_request_response: RequestResponse\u003cIdleMetricExchangeCodec\u003e,\n}\n\n/// Each event in the `PyrsiaNetworkBehaviour` is wrapped in a\n/// `PyrsiaNetworkEvent`.\n#[derive(Debug)]\npub enum PyrsiaNetworkEvent {\n    Identify(IdentifyEvent),\n    Kademlia(KademliaEvent),\n    RequestResponse(RequestResponseEvent\u003cArtifactRequest, ArtifactResponse\u003e),\n    IdleMetricRequestResponse(RequestResponseEvent\u003cIdleMetricRequest, IdleMetricResponse\u003e),\n}\n\nimpl From\u003cIdentifyEvent\u003e for PyrsiaNetworkEvent {\n    fn from(event: IdentifyEvent) -\u003e Self {\n        PyrsiaNetworkEvent::Identify(event)\n    }\n}\n\nimpl From\u003cKademliaEvent\u003e for PyrsiaNetworkEvent {\n    fn from(event: KademliaEvent) -\u003e Self {\n        PyrsiaNetworkEvent::Kademlia(event)\n    }\n}\n\nimpl From\u003cRequestResponseEvent\u003cArtifactRequest, ArtifactResponse\u003e\u003e for PyrsiaNetworkEvent {\n    fn from(event: RequestResponseEvent\u003cArtifactRequest, ArtifactResponse\u003e) -\u003e Self {\n        PyrsiaNetworkEvent::RequestResponse(event)\n    }\n}\n\nimpl From\u003cRequestResponseEvent\u003cIdleMetricRequest, IdleMetricResponse\u003e\u003e for PyrsiaNetworkEvent {\n    fn from(event: RequestResponseEvent\u003cIdleMetricRequest, IdleMetricResponse\u003e) -\u003e Self {\n        PyrsiaNetworkEvent::IdleMetricRequestResponse(event)\n    }\n}\n","traces":[{"line":55,"address":[5641392],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":56,"address":[5641408],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[5641472],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":62,"address":[5641489],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[5641568],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":68,"address":[5641584],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[5641648],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":74,"address":[5641665],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":8},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","network","client","command.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::network::artifact_protocol::ArtifactResponse;\nuse crate::network::client::{ArtifactHash, ArtifactType};\nuse crate::network::idle_metric_protocol::{IdleMetricResponse, PeerMetrics};\nuse futures::channel::oneshot;\nuse libp2p::core::{Multiaddr, PeerId};\nuse libp2p::request_response::ResponseChannel;\nuse std::collections::HashSet;\nuse strum_macros::Display;\n\n/// Commands are sent by the [`Client`] to the [`PyrsiaEventLoop`].\n/// Each command matches exactly with one if the functions that are\n/// defined in `Client`.\n#[derive(Debug, Display)]\npub enum Command {\n    Listen {\n        addr: Multiaddr,\n        sender: oneshot::Sender\u003canyhow::Result\u003c()\u003e\u003e,\n    },\n    Dial {\n        peer_addr: Multiaddr,\n        sender: oneshot::Sender\u003canyhow::Result\u003c()\u003e\u003e,\n    },\n    ListPeers {\n        peer_id: PeerId,\n        sender: oneshot::Sender\u003cHashSet\u003cPeerId\u003e\u003e,\n    },\n    Provide {\n        artifact_type: ArtifactType,\n        artifact_hash: ArtifactHash,\n        sender: oneshot::Sender\u003c()\u003e,\n    },\n    ListProviders {\n        artifact_type: ArtifactType,\n        artifact_hash: ArtifactHash,\n        sender: oneshot::Sender\u003cHashSet\u003cPeerId\u003e\u003e,\n    },\n    RequestArtifact {\n        artifact_type: ArtifactType,\n        artifact_hash: ArtifactHash,\n        peer: PeerId,\n        sender: oneshot::Sender\u003canyhow::Result\u003cVec\u003cu8\u003e\u003e\u003e,\n    },\n    RespondArtifact {\n        artifact: Vec\u003cu8\u003e,\n        channel: ResponseChannel\u003cArtifactResponse\u003e,\n    },\n    RequestIdleMetric {\n        peer: PeerId,\n        sender: oneshot::Sender\u003canyhow::Result\u003cPeerMetrics\u003e\u003e,\n    },\n    RespondIdleMetric {\n        metric: PeerMetrics,\n        channel: ResponseChannel\u003cIdleMetricResponse\u003e,\n    },\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use futures::channel::oneshot;\n\n    #[test]\n    fn command_correctly_implements_display() {\n        let (sender, _) = oneshot::channel();\n        let addr: Multiaddr = \"/ip4/127.0.0.1\".parse().unwrap();\n\n        assert_eq!(\n            String::from(\"Listen\"),\n            Command::Listen { addr, sender }.to_string()\n        );\n    }\n}\n","traces":[{"line":79,"address":[6346992,6346997],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":80,"address":[6625671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":81,"address":[6625732,6625801],"length":1,"stats":{"Line":2},"fn_name":null},{"line":83,"address":[6625992],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[6625843],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[6625870],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","network","client.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod command;\n\nuse crate::network::artifact_protocol::ArtifactResponse;\nuse crate::network::client::command::Command;\nuse crate::network::idle_metric_protocol::{IdleMetricResponse, PeerMetrics};\nuse futures::channel::{mpsc, oneshot};\nuse futures::prelude::*;\nuse libp2p::core::{Multiaddr, PeerId};\nuse libp2p::request_response::ResponseChannel;\nuse log::debug;\nuse std::collections::HashSet;\n\n/* peer metrics support */\nconst PEER_METRIC_THRESHOLD: f64 = 0.5_f64;\n#[derive(Clone, Debug, PartialEq, PartialOrd)]\nstruct IdleMetric {\n    pub peer: PeerId,\n    pub metric: f64,\n}\n/* peer metric support */\n\nuse strum_macros::Display;\n/// Defines the different types of artifacts that can be transferred\n/// within the libp2p swarm.\n#[derive(Clone, Debug, Display, PartialEq, Eq)]\npub enum ArtifactType {\n    Artifact,\n}\n\n/// A utility struct for easily defining a hash from different\n/// types that can be used as a provisioning key within the\n/// libp2p swarm.\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct ArtifactHash {\n    pub hash: String,\n}\n\n/// Construct an ArtifactHash from `String`\nimpl From\u003cString\u003e for ArtifactHash {\n    fn from(hash: String) -\u003e Self {\n        ArtifactHash { hash }\n    }\n}\n\n/// Construct an ArtifactHash from `\u0026String`\nimpl From\u003c\u0026String\u003e for ArtifactHash {\n    fn from(hash: \u0026String) -\u003e Self {\n        ArtifactHash { hash: hash.clone() }\n    }\n}\n\n/// Construct an ArtifactHash from `\u0026str`\nimpl From\u003c\u0026str\u003e for ArtifactHash {\n    fn from(hash: \u0026str) -\u003e Self {\n        ArtifactHash {\n            hash: String::from(hash),\n        }\n    }\n}\n\n/// The `Client` provides entry points to interact with the libp2p swarm.\n#[derive(Clone)]\npub struct Client {\n    pub sender: mpsc::Sender\u003cCommand\u003e,\n    pub local_peer_id: PeerId,\n}\n\nimpl Client {\n    /// Instruct the swarm to start listening on the specified address.\n    pub async fn listen(\u0026mut self, addr: \u0026Multiaddr) -\u003e anyhow::Result\u003c()\u003e {\n        debug!(\"p2p::Client::listen {:?}\", addr);\n\n        let (sender, receiver) = oneshot::channel();\n        self.sender\n            .send(Command::Listen {\n                addr: addr.clone(),\n                sender,\n            })\n            .await?;\n        receiver.await?\n    }\n\n    /// Dial a peer with the specified address.\n    pub async fn dial(\u0026mut self, peer_addr: \u0026Multiaddr) -\u003e anyhow::Result\u003c()\u003e {\n        debug!(\"p2p::Client::dial {:?}\", peer_addr);\n\n        let (sender, receiver) = oneshot::channel();\n        self.sender\n            .send(Command::Dial {\n                peer_addr: peer_addr.clone(),\n                sender,\n            })\n            .await?;\n        receiver.await?\n    }\n\n    /// List the peers that this node is connected to.\n    pub async fn list_peers(\u0026mut self) -\u003e anyhow::Result\u003cHashSet\u003cPeerId\u003e\u003e {\n        let (sender, receiver) = oneshot::channel();\n        self.sender\n            .send(Command::ListPeers {\n                peer_id: self.local_peer_id,\n                sender,\n            })\n            .await?;\n        Ok(receiver.await?)\n    }\n\n    /// Inform the swarm that this node is currently a\n    /// provider of the artifact with the specified `type`\n    /// and `hash`.\n    pub async fn provide(\n        \u0026mut self,\n        artifact_type: ArtifactType,\n        artifact_hash: ArtifactHash,\n    ) -\u003e anyhow::Result\u003c()\u003e {\n        debug!(\n            \"p2p::Client::provide {:?}={:?}\",\n            artifact_type, artifact_hash\n        );\n\n        let (sender, receiver) = oneshot::channel();\n        self.sender\n            .send(Command::Provide {\n                artifact_type,\n                artifact_hash,\n                sender,\n            })\n            .await?;\n        Ok(receiver.await?)\n    }\n\n    /// List all peers in the swarm that are providing\n    /// the artifact with the specified `type` and `hash`.\n    pub async fn list_providers(\n        \u0026mut self,\n        artifact_type: ArtifactType,\n        artifact_hash: ArtifactHash,\n    ) -\u003e anyhow::Result\u003cHashSet\u003cPeerId\u003e\u003e {\n        debug!(\n            \"p2p::Client::list_providers {:?}={:?}\",\n            artifact_type, artifact_hash\n        );\n\n        let (sender, receiver) = oneshot::channel();\n        self.sender\n            .send(Command::ListProviders {\n                artifact_type,\n                artifact_hash,\n                sender,\n            })\n            .await?;\n        Ok(receiver.await?)\n    }\n\n    /// Request an artifact with the specified `type` and `hash`\n    /// from the swarm.\n    pub async fn request_artifact(\n        \u0026mut self,\n        peer: \u0026PeerId,\n        artifact_type: ArtifactType,\n        artifact_hash: ArtifactHash,\n    ) -\u003e anyhow::Result\u003cVec\u003cu8\u003e\u003e {\n        debug!(\n            \"p2p::Client::request_artifact {:?}: {:?}={:?}\",\n            peer, artifact_type, artifact_hash\n        );\n\n        let (sender, receiver) = oneshot::channel();\n        self.sender\n            .send(Command::RequestArtifact {\n                artifact_type,\n                artifact_hash,\n                peer: *peer,\n                sender,\n            })\n            .await?;\n        receiver.await?\n    }\n\n    /// Put the artifact as a response to an incoming artifact\n    /// request.\n    pub async fn respond_artifact(\n        \u0026mut self,\n        artifact: Vec\u003cu8\u003e,\n        channel: ResponseChannel\u003cArtifactResponse\u003e,\n    ) -\u003e anyhow::Result\u003c()\u003e {\n        debug!(\"p2p::Client::respond_artifact size={:?}\", artifact.len());\n\n        self.sender\n            .send(Command::RespondArtifact { artifact, channel })\n            .await?;\n\n        Ok(())\n    }\n\n    //get a peer with a low enough work load to download artifact otherwise the lowest work load of the set\n    //TODO: chunk the peers to some limit to keep from shotgunning the network\n    pub async fn get_idle_peer(\n        \u0026mut self,\n        providers: HashSet\u003cPeerId\u003e,\n    ) -\u003e anyhow::Result\u003cOption\u003cPeerId\u003e\u003e {\n        debug!(\n            \"p2p::Client::get_idle_peer() entered with {} peers\",\n            providers.len()\n        );\n        let mut idle_metrics: Vec\u003cIdleMetric\u003e = Vec::new();\n        for peer in providers.iter() {\n            let (sender, receiver) = oneshot::channel();\n            self.sender\n                .send(Command::RequestIdleMetric {\n                    peer: *peer,\n                    sender,\n                })\n                .await?;\n\n            match receiver.await.expect(\"Sender not to be dropped.\") {\n                Ok(peer_metric) =\u003e {\n                    let metric: f64 = f64::from_le_bytes(peer_metric.idle_metric);\n                    let idle_metric = IdleMetric {\n                        peer: *peer,\n                        metric,\n                    };\n                    if idle_metric.metric \u003c PEER_METRIC_THRESHOLD {\n                        debug!(\n                                \"p2p::Client::get_idle_peer() Found peer with a below threshold idle value {}\",\n                                metric\n                            );\n                        return Ok(Some(idle_metric.peer));\n                    } else {\n                        debug!(\n                            \"p2p::Client::get_idle_peer() Pushing idle peer with value {}\",\n                            metric\n                        );\n                        idle_metrics.push(idle_metric);\n                    }\n                }\n                Err(e) =\u003e {\n                    debug!(\n                            \"p2p::Client::get_idle_peer() Unable to get peer metric for peer {} error {}\",\n                            peer, e\n                        );\n                }\n            };\n        }\n\n        //sort the peers in ascending order according to their idle metric and return top of list\n        idle_metrics.sort_by(|a, b| a.metric.partial_cmp(\u0026b.metric).unwrap());\n        Ok(idle_metrics.first().map(|idle_metric| idle_metric.peer))\n    }\n\n    pub async fn respond_idle_metric(\n        \u0026mut self,\n        metric: PeerMetrics,\n        channel: ResponseChannel\u003cIdleMetricResponse\u003e,\n    ) -\u003e anyhow::Result\u003c()\u003e {\n        debug!(\n            \"p2p::Client::respond_idle_metric PeerMetrics metric ={:?}\",\n            metric\n        );\n\n        self.sender\n            .send(Command::RespondIdleMetric { metric, channel })\n            .await?;\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use libp2p::identity::Keypair;\n    use rand::distributions::Alphanumeric;\n    use rand::{thread_rng, Rng};\n\n    #[tokio::test]\n    async fn test_listen() {\n        let (sender, mut receiver) = mpsc::channel(1);\n\n        let mut client = Client {\n            sender,\n            local_peer_id: Keypair::generate_ed25519().public().to_peer_id(),\n        };\n\n        let address: Multiaddr = \"/ip4/127.0.0.1\".parse().unwrap();\n        let cloned_address = address.clone();\n        tokio::spawn(async move { client.listen(\u0026address).await });\n\n        futures::select! {\n            command = receiver.next() =\u003e match command {\n                Some(Command::Listen { addr, sender }) =\u003e {\n                    assert_eq!(addr, cloned_address);\n                    let _ = sender.send(Ok(()));\n                },\n                _ =\u003e panic!(\"Command must match Command::Listen\")\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_dial() {\n        let (sender, mut receiver) = mpsc::channel(1);\n\n        let mut client = Client {\n            sender,\n            local_peer_id: Keypair::generate_ed25519().public().to_peer_id(),\n        };\n\n        let address: Multiaddr = \"/ip4/127.0.0.1\".parse().unwrap();\n        let cloned_address = address.clone();\n        tokio::spawn(async move { client.dial(\u0026address).await });\n\n        futures::select! {\n            command = receiver.next() =\u003e match command {\n                Some(Command::Dial { peer_addr, sender }) =\u003e {\n                    assert_eq!(peer_addr, cloned_address);\n                    let _ = sender.send(Ok(()));\n                },\n                _ =\u003e panic!(\"Command must match Command::Dial\")\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_list_peers() {\n        let (sender, mut receiver) = mpsc::channel(1);\n\n        let local_peer_id = Keypair::generate_ed25519().public().to_peer_id();\n        let mut client = Client {\n            sender,\n            local_peer_id,\n        };\n\n        tokio::spawn(async move { client.list_peers().await });\n\n        futures::select! {\n            command = receiver.next() =\u003e match command {\n                Some(Command::ListPeers { peer_id, sender }) =\u003e {\n                    assert_eq!(peer_id, local_peer_id);\n                    let _ = sender.send(Default::default());\n                },\n                _ =\u003e panic!(\"Command must match Command::ListPeers\")\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_idle_metric() {\n        let (sender, mut receiver) = mpsc::channel(1);\n\n        let local_peer_id = Keypair::generate_ed25519().public().to_peer_id();\n        let mut client = Client {\n            sender,\n            local_peer_id,\n        };\n\n        let mut peers: HashSet\u003cPeerId\u003e = HashSet::new();\n        peers.insert(client.local_peer_id);\n        tokio::spawn(async move { client.get_idle_peer(peers).await });\n\n        futures::select! {\n            command = receiver.next() =\u003e match command {\n                Some(Command::RequestIdleMetric { peer, sender }) =\u003e {\n                    assert_eq!(peer, local_peer_id);\n                    let peer_metric = PeerMetrics {\n                        idle_metric: 8675309f64.to_le_bytes(),\n                    };\n                    let _ = sender.send(Ok(peer_metric));\n                },\n                None =\u003e {},\n                _ =\u003e panic!(\"Command must match Command::RequestIdleMetric\")\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_provide() {\n        let (sender, mut receiver) = mpsc::channel(1);\n\n        let mut client = Client {\n            sender,\n            local_peer_id: Keypair::generate_ed25519().public().to_peer_id(),\n        };\n\n        let random_hash: String = thread_rng()\n            .sample_iter(\u0026Alphanumeric)\n            .take(30)\n            .map(char::from)\n            .collect();\n        let cloned_random_hash = random_hash.clone();\n        tokio::spawn(async move {\n            client\n                .provide(ArtifactType::Artifact, random_hash.into())\n                .await\n        });\n\n        futures::select! {\n            command = receiver.next() =\u003e match command {\n                Some(Command::Provide { artifact_type, artifact_hash, sender }) =\u003e {\n                    assert_eq!(artifact_type, ArtifactType::Artifact);\n                    assert_eq!(artifact_hash.hash, cloned_random_hash);\n                    let _ = sender.send(());\n                },\n                _ =\u003e panic!(\"Command must match Command::Provide\")\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_list_providers() {\n        let (sender, mut receiver) = mpsc::channel(1);\n\n        let mut client = Client {\n            sender,\n            local_peer_id: Keypair::generate_ed25519().public().to_peer_id(),\n        };\n\n        let random_hash: String = thread_rng()\n            .sample_iter(\u0026Alphanumeric)\n            .take(30)\n            .map(char::from)\n            .collect();\n        let cloned_random_hash = random_hash.clone();\n        tokio::spawn(async move {\n            client\n                .list_providers(ArtifactType::Artifact, random_hash.into())\n                .await\n        });\n\n        futures::select! {\n            command = receiver.next() =\u003e match command {\n                Some(Command::ListProviders { artifact_type, artifact_hash, sender }) =\u003e {\n                    assert_eq!(artifact_type, ArtifactType::Artifact);\n                    assert_eq!(artifact_hash.hash, cloned_random_hash);\n                    let _ = sender.send(Default::default());\n                },\n                _ =\u003e panic!(\"Command must match Command::ListProviders\")\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_request_artifact() {\n        let (sender, mut receiver) = mpsc::channel(1);\n\n        let mut client = Client {\n            sender,\n            local_peer_id: Keypair::generate_ed25519().public().to_peer_id(),\n        };\n\n        let other_peer_id = Keypair::generate_ed25519().public().to_peer_id();\n        let random_hash: String = thread_rng()\n            .sample_iter(\u0026Alphanumeric)\n            .take(30)\n            .map(char::from)\n            .collect();\n        let cloned_random_hash = random_hash.clone();\n        tokio::spawn(async move {\n            client\n                .request_artifact(\u0026other_peer_id, ArtifactType::Artifact, random_hash.into())\n                .await\n        });\n\n        futures::select! {\n            command = receiver.next() =\u003e match command {\n                Some(Command::RequestArtifact { peer, artifact_type, artifact_hash, sender }) =\u003e {\n                    assert_eq!(peer, other_peer_id);\n                    assert_eq!(artifact_type, ArtifactType::Artifact);\n                    assert_eq!(artifact_hash.hash, cloned_random_hash);\n                    let _ = sender.send(Ok(vec![]));\n                },\n                _ =\u003e panic!(\"Command must match Command::RequestArtifact\")\n            }\n        }\n    }\n\n    #[test]\n    fn test_artifact_from_str_ref() {\n        let str = \"abcd\";\n\n        let artifact = ArtifactHash::from(str);\n\n        assert_eq!(artifact.hash, str);\n    }\n\n    #[test]\n    fn test_artifact_from_string() {\n        let str = \"abcd\";\n\n        let artifact = ArtifactHash::from(str.to_string());\n\n        assert_eq!(artifact.hash, str);\n    }\n\n    #[test]\n    fn test_artifact_from_string_ref() {\n        let str = String::from(\"abcd\");\n\n        let artifact = ArtifactHash::from(\u0026str);\n\n        assert_eq!(artifact.hash, str);\n    }\n}\n","traces":[{"line":56,"address":[4849952],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":63,"address":[4850016],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":64,"address":[4850035],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[4850096],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":72,"address":[4850119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[4565655,4565792,4565946,4566027,4565616,4567639],"length":1,"stats":{"Line":4},"fn_name":"{async_fn#0}"},{"line":87,"address":[4565748,4566068,4566013,4566159],"length":1,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[4566402],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[4566797,4566675,4566878,4566558,4566977],"length":1,"stats":{"Line":4},"fn_name":null},{"line":91,"address":[4566518],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[4566472],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[4566506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[4566957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[4567395,4565840,4567237,4566938,4567644,4567189],"length":1,"stats":{"Line":4},"fn_name":null},{"line":100,"address":[4567783,4568155,4568074,4569767,4567920,4567744],"length":1,"stats":{"Line":4},"fn_name":"{async_fn#0}"},{"line":101,"address":[4567876,4568141,4568287,4568196],"length":1,"stats":{"Line":3},"fn_name":null},{"line":103,"address":[4568530],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[4568686,4568925,4569105,4568803,4569006],"length":1,"stats":{"Line":4},"fn_name":null},{"line":105,"address":[4568646],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[4568600],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[4568634],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[4569085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[4569066,4569365,4569317,4567968,4569523,4569772],"length":1,"stats":{"Line":4},"fn_name":null},{"line":114,"address":[4570424,4571493,4570005,4569915,4570138,4569872],"length":1,"stats":{"Line":4},"fn_name":"{async_fn#0}"},{"line":115,"address":[4569985,4570218],"length":1,"stats":{"Line":2},"fn_name":null},{"line":116,"address":[4570746,4570679,4570842,4570412,4570569],"length":1,"stats":{"Line":4},"fn_name":null},{"line":117,"address":[4570300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[4570231],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[4570291],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[4570822],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[4571498,4571007,4570803,4570044,4571052,4571169],"length":1,"stats":{"Line":4},"fn_name":null},{"line":128,"address":[4850400],"length":1,"stats":{"Line":1},"fn_name":"provide"},{"line":133,"address":[4571997,4571732,4572048,4572139],"length":1,"stats":{"Line":3},"fn_name":null},{"line":138,"address":[4572437],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[4572722,4572922,4573021,4572841,4572604],"length":1,"stats":{"Line":4},"fn_name":null},{"line":140,"address":[4572540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[4572500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[4572528],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[4573001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":146,"address":[4573576,4572982,4573239,4573191,4571824,4573378],"length":1,"stats":{"Line":4},"fn_name":null},{"line":151,"address":[4850496],"length":1,"stats":{"Line":1},"fn_name":"list_providers"},{"line":156,"address":[4574297,4573908,4574170,4574221],"length":1,"stats":{"Line":3},"fn_name":null},{"line":161,"address":[4574589],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[4575160,4575061,4574752,4574869,4574985],"length":1,"stats":{"Line":4},"fn_name":null},{"line":163,"address":[4574688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[4574648],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[4574676],"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":[4575140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[4575487,4575835,4575315,4575121,4574000,4575363],"length":1,"stats":{"Line":4},"fn_name":null},{"line":174,"address":[4850592],"length":1,"stats":{"Line":1},"fn_name":"request_artifact"},{"line":180,"address":[4576469,4576520,4576204,4576611],"length":1,"stats":{"Line":3},"fn_name":null},{"line":185,"address":[4576988],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[4577530,4577705,4577411,4577294,4577606],"length":1,"stats":{"Line":4},"fn_name":null},{"line":187,"address":[4577150],"length":1,"stats":{"Line":1},"fn_name":null},{"line":189,"address":[4577047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[4577075],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[4577138],"length":1,"stats":{"Line":1},"fn_name":null},{"line":193,"address":[4577685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[4577908,4578036,4577666,4577860,4576296,4578390],"length":1,"stats":{"Line":4},"fn_name":null},{"line":199,"address":[4850688],"length":1,"stats":{"Line":0},"fn_name":"respond_artifact"},{"line":215,"address":[4850800],"length":1,"stats":{"Line":1},"fn_name":"get_idle_peer"},{"line":219,"address":[4579093,4579184,4579042,4578773,4579300],"length":1,"stats":{"Line":3},"fn_name":null},{"line":221,"address":[4579261],"length":1,"stats":{"Line":0},"fn_name":null},{"line":223,"address":[4579480],"length":1,"stats":{"Line":1},"fn_name":null},{"line":224,"address":[4579499,4579747,4579601,4581653],"length":1,"stats":{"Line":3},"fn_name":null},{"line":225,"address":[4579762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[4580159,4580035,4579838,4580384,4580296,4580499],"length":1,"stats":{"Line":5},"fn_name":null},{"line":227,"address":[4579923],"length":1,"stats":{"Line":1},"fn_name":null},{"line":228,"address":[4579842],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[4579908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":231,"address":[4580479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":233,"address":[4578865,4580565,4580450,4580604],"length":1,"stats":{"Line":4},"fn_name":null},{"line":234,"address":[4581005],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[4581021,4581697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[4581706],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[4581787],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[4581847,4581971],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[4582192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[4582635,4581806,4582553],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[4582864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[4581064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[4581266,4581080,4581175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[4579709,4583060,4583389,4583344],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":265,"address":[4583440,4583075,4583175,4583456],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":268,"address":[4850896],"length":1,"stats":{"Line":0},"fn_name":"respond_idle_metric"},{"line":294,"address":[5859731,5859472,5859312,5859285,5859351,5859553,5859280],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":295,"address":[5859413,5859621],"length":1,"stats":{"Line":2},"fn_name":null},{"line":299,"address":[5859772,5859858,5859704],"length":1,"stats":{"Line":3},"fn_name":null},{"line":302,"address":[5860217,5860377],"length":1,"stats":{"Line":2},"fn_name":null},{"line":303,"address":[5860384],"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":[5862295,5862145,5860725,5860641,5860433,5862112],"length":1,"stats":{"Line":5},"fn_name":"{async_block#0}"},{"line":306,"address":[5861689,5860809,5861347,5859496,5861088,5861900],"length":1,"stats":{"Line":7},"fn_name":null},{"line":307,"address":[5861006,5860764,5861120],"length":1,"stats":{"Line":3},"fn_name":null},{"line":308,"address":[5861184],"length":1,"stats":{"Line":1},"fn_name":null},{"line":309,"address":[5861240,5861526,5861414],"length":1,"stats":{"Line":2},"fn_name":null},{"line":310,"address":[5861589,5861463],"length":1,"stats":{"Line":2},"fn_name":null},{"line":312,"address":[5861134,5861321],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[5863616,5863589,5863776,5863857,5864035,5863655,5863584],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":319,"address":[5863925,5863717],"length":1,"stats":{"Line":2},"fn_name":null},{"line":323,"address":[5864162,5864076,5864008],"length":1,"stats":{"Line":3},"fn_name":null},{"line":326,"address":[5864521,5864681],"length":1,"stats":{"Line":2},"fn_name":null},{"line":327,"address":[5864688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":[5866416,5864945,5866449,5865029,5866599,5864737],"length":1,"stats":{"Line":5},"fn_name":"{async_block#0}"},{"line":330,"address":[5865392,5866204,5863800,5865651,5865993,5865113],"length":1,"stats":{"Line":7},"fn_name":null},{"line":331,"address":[5865424,5865310,5865068],"length":1,"stats":{"Line":3},"fn_name":null},{"line":332,"address":[5865488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":333,"address":[5865544,5865718,5865830],"length":1,"stats":{"Line":2},"fn_name":null},{"line":334,"address":[5865893,5865767],"length":1,"stats":{"Line":2},"fn_name":null},{"line":336,"address":[5865625,5865438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[5867953,5868126,5868262,5867893,5868054,5867920,5867888],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":343,"address":[5868191,5868003],"length":1,"stats":{"Line":2},"fn_name":null},{"line":345,"address":[5868372,5868303,5868238],"length":1,"stats":{"Line":3},"fn_name":null},{"line":351,"address":[5870410,5868722,5870224,5870267],"length":1,"stats":{"Line":3},"fn_name":"{async_block#0}"},{"line":353,"address":[5869550,5869972,5869912,5870089,5869244,5868985,5868075],"length":1,"stats":{"Line":7},"fn_name":null},{"line":354,"address":[5869173,5868943,5869270],"length":1,"stats":{"Line":3},"fn_name":null},{"line":355,"address":[5869331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":356,"address":[5869443,5869727,5869617],"length":1,"stats":{"Line":2},"fn_name":null},{"line":357,"address":[5869666,5869889,5869780],"length":1,"stats":{"Line":2},"fn_name":null},{"line":359,"address":[5869284,5869524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[5871701,5872125,5871696,5871728,5871767,5871900,5871980],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":366,"address":[5871832,5872048],"length":1,"stats":{"Line":2},"fn_name":null},{"line":368,"address":[5872169,5872098,5872244],"length":1,"stats":{"Line":3},"fn_name":null},{"line":374,"address":[5872607],"length":1,"stats":{"Line":1},"fn_name":null},{"line":375,"address":[5872630],"length":1,"stats":{"Line":1},"fn_name":null},{"line":376,"address":[5872803,5874987,5873044,5874944,5875179],"length":1,"stats":{"Line":4},"fn_name":"{async_block#0}"},{"line":378,"address":[5874515,5874087,5874688,5873172,5871924,5873764],"length":1,"stats":{"Line":7},"fn_name":null},{"line":379,"address":[5873125,5873575,5873846],"length":1,"stats":{"Line":3},"fn_name":null},{"line":380,"address":[5873868],"length":1,"stats":{"Line":1},"fn_name":null},{"line":381,"address":[5874154,5873980,5874233],"length":1,"stats":{"Line":2},"fn_name":null},{"line":382,"address":[5874315],"length":1,"stats":{"Line":1},"fn_name":null},{"line":383,"address":[5874211,5874291],"length":1,"stats":{"Line":2},"fn_name":null},{"line":385,"address":[5874331],"length":1,"stats":{"Line":1},"fn_name":null},{"line":387,"address":[5873841],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[5873799,5874061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[5876995,5876615,5876549,5876576,5876544,5876736,5876817],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":395,"address":[5876885,5876677],"length":1,"stats":{"Line":2},"fn_name":null},{"line":399,"address":[5877036,5876968,5877122],"length":1,"stats":{"Line":3},"fn_name":null},{"line":402,"address":[5877604,5877481],"length":1,"stats":{"Line":2},"fn_name":null},{"line":407,"address":[5877698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":408,"address":[5879754,5878032,5877728,5877948,5879680,5880157,5879536,5879569],"length":1,"stats":{"Line":5},"fn_name":"{async_block#0}"},{"line":409,"address":[5880069,5879939,5879835,5879622],"length":1,"stats":{"Line":3},"fn_name":null},{"line":410,"address":[5879630,5879956,5880090,5879701,5879892],"length":1,"stats":{"Line":2},"fn_name":null},{"line":414,"address":[5878665,5878116,5878395,5879102,5879313,5876760],"length":1,"stats":{"Line":7},"fn_name":null},{"line":415,"address":[5878313,5878071,5878427],"length":1,"stats":{"Line":3},"fn_name":null},{"line":416,"address":[5878483],"length":1,"stats":{"Line":1},"fn_name":null},{"line":417,"address":[5878563,5878732,5878884],"length":1,"stats":{"Line":2},"fn_name":null},{"line":418,"address":[5878984,5878793,5878941],"length":1,"stats":{"Line":2},"fn_name":null},{"line":419,"address":[5878947],"length":1,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[5878441,5878639],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[5881451,5880992,5881024,5881192,5881063,5880997,5881273],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":428,"address":[5881125,5881341],"length":1,"stats":{"Line":2},"fn_name":null},{"line":432,"address":[5881424,5881492,5881578],"length":1,"stats":{"Line":3},"fn_name":null},{"line":435,"address":[5882060,5881937],"length":1,"stats":{"Line":2},"fn_name":null},{"line":440,"address":[5882154],"length":1,"stats":{"Line":1},"fn_name":null},{"line":441,"address":[5884171,5884844,5882184,5882404,5882488,5884128,5884282,5884356],"length":1,"stats":{"Line":5},"fn_name":"{async_block#0}"},{"line":442,"address":[5884224,5884437,5884541,5884651],"length":1,"stats":{"Line":3},"fn_name":null},{"line":443,"address":[5884779,5884303,5884557,5884494,5884232],"length":1,"stats":{"Line":2},"fn_name":null},{"line":447,"address":[5883705,5881216,5882851,5882572,5883915,5883121],"length":1,"stats":{"Line":7},"fn_name":null},{"line":448,"address":[5882527,5882883,5882769],"length":1,"stats":{"Line":3},"fn_name":null},{"line":449,"address":[5882939],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[5883019,5883340,5883188],"length":1,"stats":{"Line":2},"fn_name":null},{"line":451,"address":[5883397,5883249,5883464],"length":1,"stats":{"Line":2},"fn_name":null},{"line":452,"address":[5883626,5883403,5883517],"length":1,"stats":{"Line":2},"fn_name":null},{"line":454,"address":[5883095,5882897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":460,"address":[5885712,5885680,5885975,5886159,5885751,5885892,5885685],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":461,"address":[5885816,5886043],"length":1,"stats":{"Line":2},"fn_name":null},{"line":465,"address":[5886292,5886203,5886132],"length":1,"stats":{"Line":3},"fn_name":null},{"line":468,"address":[5886657],"length":1,"stats":{"Line":1},"fn_name":null},{"line":469,"address":[5886992,5886873],"length":1,"stats":{"Line":2},"fn_name":null},{"line":474,"address":[5887089],"length":1,"stats":{"Line":1},"fn_name":null},{"line":475,"address":[5887408,5887119,5889440,5889612,5887492,5889483,5889686,5890117],"length":1,"stats":{"Line":5},"fn_name":"{async_block#0}"},{"line":476,"address":[5889876,5889772,5889536,5889985],"length":1,"stats":{"Line":3},"fn_name":null},{"line":477,"address":[5889633,5889893,5889829,5890049,5889544],"length":1,"stats":{"Line":2},"fn_name":null},{"line":481,"address":[5885916,5888220,5887578,5888999,5887862,5889209],"length":1,"stats":{"Line":7},"fn_name":null},{"line":482,"address":[5887531,5887897,5887780],"length":1,"stats":{"Line":3},"fn_name":null},{"line":483,"address":[5887961],"length":1,"stats":{"Line":1},"fn_name":null},{"line":484,"address":[5888287,5888430,5888113],"length":1,"stats":{"Line":2},"fn_name":null},{"line":485,"address":[5888344,5888591,5888487],"length":1,"stats":{"Line":2},"fn_name":null},{"line":486,"address":[5888714,5888501,5888648],"length":1,"stats":{"Line":2},"fn_name":null},{"line":487,"address":[5888767,5888654,5888920],"length":1,"stats":{"Line":2},"fn_name":null},{"line":489,"address":[5888194,5887911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":495,"address":[5890976,5890981],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":496,"address":[5962519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":498,"address":[5962540],"length":1,"stats":{"Line":1},"fn_name":null},{"line":500,"address":[5962693,5962565],"length":1,"stats":{"Line":1},"fn_name":null},{"line":504,"address":[5891008,5891013],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":505,"address":[5962775],"length":1,"stats":{"Line":1},"fn_name":null},{"line":507,"address":[5962796],"length":1,"stats":{"Line":1},"fn_name":null},{"line":509,"address":[5962836,5962966],"length":1,"stats":{"Line":1},"fn_name":null},{"line":513,"address":[5891040,5891045],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":514,"address":[5963047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":516,"address":[5963079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":518,"address":[5963259,5963195,5963091],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":163,"coverable":193},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","network","event_loop.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::network::artifact_protocol::{ArtifactRequest, ArtifactResponse};\nuse crate::network::behaviour::{PyrsiaNetworkBehaviour, PyrsiaNetworkEvent};\nuse crate::network::client::command::Command;\nuse crate::network::client::ArtifactType;\nuse crate::network::idle_metric_protocol::{IdleMetricRequest, IdleMetricResponse, PeerMetrics};\nuse futures::channel::{mpsc, oneshot};\nuse futures::prelude::*;\nuse libp2p::core::{Multiaddr, PeerId};\nuse libp2p::identify::IdentifyEvent;\nuse libp2p::kad::{GetClosestPeersOk, GetProvidersOk, KademliaEvent, QueryId, QueryResult};\nuse libp2p::multiaddr::Protocol;\nuse libp2p::request_response::{\n    RequestId, RequestResponseEvent, RequestResponseMessage, ResponseChannel,\n};\nuse libp2p::swarm::SwarmEvent;\nuse libp2p::Swarm;\nuse log::{debug, info, trace, warn};\nuse std::collections::hash_map::Entry::Vacant;\nuse std::collections::{HashMap, HashSet};\nuse std::error::Error;\n\ntype PendingDialMap = HashMap\u003cMultiaddr, oneshot::Sender\u003canyhow::Result\u003c()\u003e\u003e\u003e;\ntype PendingListPeersMap = HashMap\u003cQueryId, oneshot::Sender\u003cHashSet\u003cPeerId\u003e\u003e\u003e;\ntype PendingStartProvidingMap = HashMap\u003cQueryId, oneshot::Sender\u003c()\u003e\u003e;\ntype PendingRequestArtifactMap = HashMap\u003cRequestId, oneshot::Sender\u003canyhow::Result\u003cVec\u003cu8\u003e\u003e\u003e\u003e;\ntype PendingRequestIdleMetricMap = HashMap\u003cRequestId, oneshot::Sender\u003canyhow::Result\u003cPeerMetrics\u003e\u003e\u003e;\n\n/// The `PyrsiaEventLoop` is responsible for taking care of incoming\n/// events from the libp2p [`Swarm`] itself, the different network\n/// behaviours that exist inside the `Swarm` and incoming commands\n/// from the [`Client`].\npub struct PyrsiaEventLoop {\n    swarm: Swarm\u003cPyrsiaNetworkBehaviour\u003e,\n    command_receiver: mpsc::Receiver\u003cCommand\u003e,\n    event_sender: mpsc::Sender\u003cPyrsiaEvent\u003e,\n    pending_dial: PendingDialMap,\n    pending_list_peers: PendingListPeersMap,\n    pending_start_providing: PendingStartProvidingMap,\n    pending_list_providers: PendingListPeersMap,\n    pending_request_artifact: PendingRequestArtifactMap,\n    pending_idle_metric_requests: PendingRequestIdleMetricMap,\n}\n\nimpl PyrsiaEventLoop {\n    pub fn new(\n        swarm: Swarm\u003cPyrsiaNetworkBehaviour\u003e,\n        command_receiver: mpsc::Receiver\u003cCommand\u003e,\n        event_sender: mpsc::Sender\u003cPyrsiaEvent\u003e,\n    ) -\u003e Self {\n        Self {\n            swarm,\n            command_receiver,\n            event_sender,\n            pending_dial: Default::default(),\n            pending_list_peers: Default::default(),\n            pending_start_providing: Default::default(),\n            pending_list_providers: Default::default(),\n            pending_request_artifact: Default::default(),\n            pending_idle_metric_requests: Default::default(),\n        }\n    }\n\n    /// Creates the actual event loop to begin listening for\n    /// incoming events on the swarm and command channels.\n    pub async fn run(mut self) {\n        loop {\n            futures::select! {\n                event = self.swarm.next() =\u003e match event.expect(\"Swarm stream to be infinite.\") {\n                    SwarmEvent::Behaviour(PyrsiaNetworkEvent::Identify(identify_event)) =\u003e self.handle_identify_event(identify_event).await,\n                    SwarmEvent::Behaviour(PyrsiaNetworkEvent::Kademlia(kademlia_event)) =\u003e self.handle_kademlia_event(kademlia_event).await,\n                    SwarmEvent::Behaviour(PyrsiaNetworkEvent::RequestResponse(request_response_event)) =\u003e self.handle_request_response_event(request_response_event).await,\n                    SwarmEvent::Behaviour(PyrsiaNetworkEvent::IdleMetricRequestResponse(request_response_event)) =\u003e self.handle_idle_metric_request_response_event(request_response_event).await,\n                    swarm_event =\u003e self.handle_swarm_event(swarm_event).await,\n                },\n                command = self.command_receiver.next() =\u003e match command {\n                    Some(c) =\u003e {\n                        self.handle_command(c).await;\n                    },\n                    // Command channel closed, thus shutting down the network event loop.\n                    None =\u003e { warn!(\"Got empty command\"); return },\n                },\n            }\n        }\n    }\n\n    // Handles events from the `Identify` network behaviour.\n    async fn handle_identify_event(\u0026mut self, event: IdentifyEvent) {\n        trace!(\"Handle IdentifyEvent: {:?}\", event);\n        match event {\n            IdentifyEvent::Pushed { .. } =\u003e {}\n            IdentifyEvent::Received { peer_id, info } =\u003e {\n                println!(\"Identify::Received: {}; {:?}\", peer_id, info);\n                if let Some(addr) = info.listen_addrs.get(0) {\n                    if let Some(sender) = self.pending_dial.remove(addr) {\n                        let _ = sender.send(Ok(()));\n                    }\n\n                    debug!(\n                        \"Identify::Received: adding address {:?} for peer {}\",\n                        addr.clone(),\n                        peer_id\n                    );\n                    self.swarm\n                        .behaviour_mut()\n                        .kademlia\n                        .add_address(\u0026peer_id, addr.clone());\n                }\n            }\n            IdentifyEvent::Sent { .. } =\u003e {}\n            IdentifyEvent::Error { .. } =\u003e {}\n        }\n    }\n\n    // Handles events from the `Kademlia` network behaviour.\n    async fn handle_kademlia_event(\u0026mut self, event: KademliaEvent) {\n        trace!(\"Handle KademliaEvent: {:?}\", event);\n        match event {\n            KademliaEvent::OutboundQueryCompleted {\n                id,\n                result: QueryResult::GetClosestPeers(Ok(GetClosestPeersOk { key: _key, peers })),\n                ..\n            } =\u003e {\n                let _ = self\n                    .pending_list_peers\n                    .remove(\u0026id)\n                    .expect(\"Completed query to be previously pending.\")\n                    .send(HashSet::from_iter(peers));\n            }\n            KademliaEvent::OutboundQueryCompleted {\n                id,\n                result: QueryResult::StartProviding(_),\n                ..\n            } =\u003e {\n                let sender: oneshot::Sender\u003c()\u003e = self\n                    .pending_start_providing\n                    .remove(\u0026id)\n                    .expect(\"Completed query to be previously pending.\");\n                let _ = sender.send(());\n            }\n            KademliaEvent::OutboundQueryCompleted {\n                id,\n                result:\n                    QueryResult::GetProviders(Ok(GetProvidersOk {\n                        key: _key,\n                        providers,\n                        ..\n                    })),\n                ..\n            } =\u003e {\n                let _ = self\n                    .pending_list_providers\n                    .remove(\u0026id)\n                    .expect(\"Completed query to be previously pending.\")\n                    .send(providers);\n            }\n            _ =\u003e {}\n        }\n    }\n\n    // Handles events from the `RequestResponse` for artifact exchange\n    // network behaviour.\n    async fn handle_request_response_event(\n        \u0026mut self,\n        event: RequestResponseEvent\u003cArtifactRequest, ArtifactResponse\u003e,\n    ) {\n        trace!(\"Handle RequestResponseEvent: {:?}\", event);\n        match event {\n            RequestResponseEvent::Message { message, .. } =\u003e match message {\n                RequestResponseMessage::Request {\n                    request, channel, ..\n                } =\u003e {\n                    self.event_sender\n                        .send(PyrsiaEvent::RequestArtifact {\n                            artifact_type: request.0,\n                            artifact_hash: request.1,\n                            channel,\n                        })\n                        .await\n                        .expect(\"Event receiver not to be dropped.\");\n                }\n                RequestResponseMessage::Response {\n                    request_id,\n                    response,\n                } =\u003e {\n                    let _ = self\n                        .pending_request_artifact\n                        .remove(\u0026request_id)\n                        .expect(\"Request to still be pending.\")\n                        .send(Ok(response.0));\n                }\n            },\n            RequestResponseEvent::InboundFailure { .. } =\u003e {}\n            RequestResponseEvent::OutboundFailure {\n                request_id, error, ..\n            } =\u003e {\n                let _ = self\n                    .pending_request_artifact\n                    .remove(\u0026request_id)\n                    .expect(\"Request to still be pending.\")\n                    .send(Err(From::from(error)));\n            }\n            RequestResponseEvent::ResponseSent { .. } =\u003e {}\n        }\n    }\n\n    // Handles events from the `RequestResponse` for peer metric exchange\n    // network behaviour.\n    async fn handle_idle_metric_request_response_event(\n        \u0026mut self,\n        event: RequestResponseEvent\u003cIdleMetricRequest, IdleMetricResponse\u003e,\n    ) {\n        trace!(\"Handle RequestResponseEvent: {:?}\", event);\n        match event {\n            RequestResponseEvent::Message { message, .. } =\u003e match message {\n                RequestResponseMessage::Request { channel, .. } =\u003e {\n                    self.event_sender\n                        .send(PyrsiaEvent::IdleMetricRequest { channel })\n                        .await\n                        .expect(\"Event receiver not to be dropped.\");\n                }\n                RequestResponseMessage::Response {\n                    request_id,\n                    response,\n                } =\u003e {\n                    let _ = self\n                        .pending_idle_metric_requests\n                        .remove(\u0026request_id)\n                        .expect(\"Request to still be pending.\")\n                        .send(Ok(response.0));\n                }\n            },\n            RequestResponseEvent::InboundFailure { .. } =\u003e {}\n            RequestResponseEvent::OutboundFailure {\n                request_id, error, ..\n            } =\u003e {\n                let _ = self\n                    .pending_idle_metric_requests\n                    .remove(\u0026request_id)\n                    .expect(\"Request to still be pending.\")\n                    .send(Err(From::from(error)));\n            }\n            RequestResponseEvent::ResponseSent { .. } =\u003e {}\n        }\n    }\n    // Handles all other events from the libp2p `Swarm`.\n    async fn handle_swarm_event(\u0026mut self, event: SwarmEvent\u003cPyrsiaNetworkEvent, impl Error\u003e) {\n        trace!(\"Handle SwarmEvent: {:?}\", event);\n        match event {\n            SwarmEvent::Behaviour(_) =\u003e {\n                debug!(\"Unmatched Behaviour swarm event found: {:?}\", event);\n            }\n            SwarmEvent::NewListenAddr { address, .. } =\u003e {\n                let local_peer_id = *self.swarm.local_peer_id();\n                info!(\n                    \"Local node is listening on {:?}\",\n                    address.with(Protocol::P2p(local_peer_id.into()))\n                );\n            }\n            SwarmEvent::ConnectionEstablished { .. } =\u003e {}\n            SwarmEvent::ConnectionClosed { .. } =\u003e {}\n            SwarmEvent::OutgoingConnectionError { .. } =\u003e {}\n            SwarmEvent::BannedPeer { .. } =\u003e {}\n            SwarmEvent::Dialing(peer_id) =\u003e {\n                debug!(\n                    \"Local Peer {} is dialing Peer {}...\",\n                    self.swarm.local_peer_id(),\n                    peer_id\n                );\n            }\n            SwarmEvent::ExpiredListenAddr { .. } =\u003e {}\n            SwarmEvent::IncomingConnection { .. } =\u003e {}\n            SwarmEvent::IncomingConnectionError { .. } =\u003e {}\n            SwarmEvent::ListenerClosed { .. } =\u003e {}\n            SwarmEvent::ListenerError { .. } =\u003e {}\n        }\n    }\n\n    // Handle incoming commands that are sent by the [`Client`].\n    async fn handle_command(\u0026mut self, command: Command) {\n        trace!(\"Handle Command: {}\", command);\n        match command {\n            Command::Listen { addr, sender } =\u003e {\n                let _ = match self.swarm.listen_on(addr) {\n                    Ok(_) =\u003e sender.send(Ok(())),\n                    Err(e) =\u003e sender.send(Err(From::from(e))),\n                };\n            }\n            Command::Dial { peer_addr, sender } =\u003e {\n                if let Vacant(_) = self.pending_dial.entry(peer_addr.clone()) {\n                    match self.swarm.dial(peer_addr.clone()) {\n                        Ok(()) =\u003e {\n                            self.pending_dial.insert(peer_addr, sender);\n                        }\n                        Err(e) =\u003e {\n                            let _ = sender.send(Err(From::from(e)));\n                        }\n                    }\n                }\n            }\n            Command::ListPeers { peer_id, sender } =\u003e {\n                let query_id = self\n                    .swarm\n                    .behaviour_mut()\n                    .kademlia\n                    .get_closest_peers(peer_id);\n                self.pending_list_peers.insert(query_id, sender);\n            }\n            Command::Provide {\n                artifact_type,\n                artifact_hash,\n                sender,\n            } =\u003e {\n                let kademlia_key = format!(\"{}|{}\", artifact_type, artifact_hash.hash);\n                let query_id = self\n                    .swarm\n                    .behaviour_mut()\n                    .kademlia\n                    .start_providing(kademlia_key.into_bytes().into())\n                    .expect(\"No store error.\");\n                self.pending_start_providing.insert(query_id, sender);\n            }\n            Command::ListProviders {\n                artifact_type,\n                artifact_hash,\n                sender,\n            } =\u003e {\n                let kademlia_key = format!(\"{}|{}\", artifact_type, artifact_hash.hash);\n                let query_id = self\n                    .swarm\n                    .behaviour_mut()\n                    .kademlia\n                    .get_providers(kademlia_key.into_bytes().into());\n                self.pending_list_providers.insert(query_id, sender);\n            }\n            Command::RequestArtifact {\n                artifact_type,\n                artifact_hash,\n                peer,\n                sender,\n            } =\u003e {\n                let request_id = self\n                    .swarm\n                    .behaviour_mut()\n                    .request_response\n                    .send_request(\u0026peer, ArtifactRequest(artifact_type, artifact_hash.hash));\n                self.pending_request_artifact.insert(request_id, sender);\n            }\n            Command::RespondArtifact { artifact, channel } =\u003e {\n                self.swarm\n                    .behaviour_mut()\n                    .request_response\n                    .send_response(channel, ArtifactResponse(artifact))\n                    .expect(\"Connection to peer to be still open.\");\n            }\n            Command::RequestIdleMetric { peer, sender } =\u003e {\n                let request_id = self\n                    .swarm\n                    .behaviour_mut()\n                    .idle_metric_request_response\n                    .send_request(\u0026peer, IdleMetricRequest());\n                self.pending_idle_metric_requests.insert(request_id, sender);\n            }\n            Command::RespondIdleMetric { metric, channel } =\u003e {\n                self.swarm\n                    .behaviour_mut()\n                    .idle_metric_request_response\n                    .send_response(channel, IdleMetricResponse(metric))\n                    .expect(\"Connection to peer to be still open.\");\n            }\n        }\n    }\n}\n\n#[derive(Debug)]\npub enum PyrsiaEvent {\n    RequestArtifact {\n        artifact_type: ArtifactType,\n        artifact_hash: String,\n        channel: ResponseChannel\u003cArtifactResponse\u003e,\n    },\n    IdleMetricRequest {\n        channel: ResponseChannel\u003cIdleMetricResponse\u003e,\n    },\n}\n","traces":[{"line":61,"address":[7219648,7220363],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":70,"address":[7219757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":[7219772],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[7219827],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[7219879],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[7219931],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[7219983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[7220384,7220406],"length":1,"stats":{"Line":0},"fn_name":"run"},{"line":103,"address":[7220464,7220500],"length":1,"stats":{"Line":0},"fn_name":"handle_identify_event"},{"line":131,"address":[7220560,7220598],"length":1,"stats":{"Line":0},"fn_name":"handle_kademlia_event"},{"line":178,"address":[7220672],"length":1,"stats":{"Line":0},"fn_name":"handle_request_response_event"},{"line":224,"address":[7220784],"length":1,"stats":{"Line":0},"fn_name":"handle_idle_metric_request_response_event"},{"line":295,"address":[7220880,7220916],"length":1,"stats":{"Line":0},"fn_name":"handle_command"}],"covered":0,"coverable":13},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","network","idle_metric_protocol.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse async_trait::async_trait;\nuse futures::prelude::*;\nuse libp2p::core::upgrade::{read_varint, write_length_prefixed, ProtocolName};\nuse libp2p::request_response::RequestResponseCodec;\nuse log::debug;\nuse serde::{Deserialize, Serialize};\nuse std::io;\n\n/// The `IdleMetricExchangeCodec` defines the request and response types\n/// for the [`RequestResponse`](crate::RequestResponse) protocol for\n/// exchanging peer metrics. The peer metric is passed through the framework\n/// in the PeerMetrics structure but over the network as the bytes needed\n/// for passing a floating point as bits of the idle metric field of the\n/// PeerMetrics structure.\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct PeerMetrics {\n    pub idle_metric: [u8; 8],\n}\n\nimpl PartialEq for PeerMetrics {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.idle_metric == other.idle_metric\n    }\n}\n\nimpl Eq for PeerMetrics {}\n\nimpl AsRef\u003c[u8]\u003e for PeerMetrics {\n    fn as_ref(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.idle_metric\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct IdleMetricExchangeProtocol();\n\n#[derive(Clone)]\npub struct IdleMetricExchangeCodec();\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct IdleMetricRequest();\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct IdleMetricResponse(pub PeerMetrics);\n\nimpl ProtocolName for IdleMetricExchangeProtocol {\n    fn protocol_name(\u0026self) -\u003e \u0026[u8] {\n        \"/metric-exchange/1\".as_bytes()\n    }\n}\n#[async_trait]\nimpl RequestResponseCodec for IdleMetricExchangeCodec {\n    type Protocol = IdleMetricExchangeProtocol;\n    type Request = IdleMetricRequest;\n    type Response = IdleMetricResponse;\n\n    //request for idle metric from a peer.\n    async fn read_request\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026IdleMetricExchangeProtocol,\n        _io: \u0026mut T,\n    ) -\u003e io::Result\u003cSelf::Request\u003e\n    where\n        T: AsyncRead + Unpin + Send,\n    {\n        debug!(\"p2p::idle_metric_protocol::read_request received from peer.\",);\n        //unlike the artifact, there is no has parameter there is only one metric possible\n        Ok(IdleMetricRequest()) //TODO: can I just return OK from here with no type\n    }\n\n    //reads the peer metric from the peer\n    async fn read_response\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026IdleMetricExchangeProtocol,\n        io: \u0026mut T,\n    ) -\u003e io::Result\u003cSelf::Response\u003e\n    where\n        T: AsyncRead + Unpin + Send,\n    {\n        let mut buff: [u8; 8] = [0; 8];\n        let mut size = read_varint(io).await?;\n        if size != 8 {\n            return Err(io::ErrorKind::InvalidData.into());\n        }\n\n        size = io.read(\u0026mut buff).await?;\n        if size != 8 {\n            return Err(io::ErrorKind::InvalidData.into());\n        }\n\n        let metric = PeerMetrics { idle_metric: buff };\n        debug!(\n            \"p2p::idle_metric_protocol::read_response Reading response to idle metric request with value ={:?}\",\n            metric.idle_metric\n        );\n        Ok(IdleMetricResponse(metric))\n    }\n\n    //this method request the idle metric from the peer\n    async fn write_request\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026IdleMetricExchangeProtocol,\n        io: \u0026mut T,\n        IdleMetricRequest(): IdleMetricRequest,\n    ) -\u003e io::Result\u003c()\u003e\n    where\n        T: AsyncWrite + Unpin + Send,\n    {\n        debug!(\n            \"p2p::idle_metric_protocol::write_request writing a request to peer for and idle metric\",\n        );\n        io.close().await?;\n        Ok(())\n    }\n\n    //this object writes the quality metric to the peer.\n    async fn write_response\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026IdleMetricExchangeProtocol,\n        io: \u0026mut T,\n        IdleMetricResponse(data): IdleMetricResponse,\n    ) -\u003e io::Result\u003c()\u003e\n    where\n        T: AsyncWrite + Unpin + Send,\n    {\n        debug!(\n            \"p2p::idle_metric_protocol::write_response sending PeerMetric metric value {:?}\",\n            data\n        );\n        write_length_prefixed(io, data.idle_metric).await?;\n        io.close().await?;\n\n        Ok(())\n    }\n}\n","traces":[{"line":37,"address":[4867808],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":38,"address":[4867822],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4867856],"length":1,"stats":{"Line":0},"fn_name":"as_ref"},{"line":61,"address":[4867872],"length":1,"stats":{"Line":0},"fn_name":"protocol_name"},{"line":80,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":24},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","network","p2p.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::network::artifact_protocol::{ArtifactExchangeCodec, ArtifactExchangeProtocol};\nuse crate::network::behaviour::PyrsiaNetworkBehaviour;\nuse crate::network::client::Client;\nuse crate::network::event_loop::{PyrsiaEvent, PyrsiaEventLoop};\nuse crate::network::idle_metric_protocol::{IdleMetricExchangeCodec, IdleMetricExchangeProtocol};\nuse crate::util::keypair_util;\n\nuse futures::channel::mpsc;\nuse futures::prelude::*;\nuse libp2p::core;\nuse libp2p::dns;\nuse libp2p::identify;\nuse libp2p::identity;\nuse libp2p::kad;\nuse libp2p::kad::record::store::{MemoryStore, MemoryStoreConfig};\nuse libp2p::mplex;\nuse libp2p::noise;\nuse libp2p::request_response::{ProtocolSupport, RequestResponse};\nuse libp2p::swarm::{Swarm, SwarmBuilder};\nuse libp2p::tcp;\nuse libp2p::yamux;\nuse libp2p::Transport;\nuse std::error::Error;\nuse std::iter;\n\n/// Sets up the libp2p [`Swarm`] with the necessary components, doing the following things:\n///\n/// * load a keypair that is used for the libp2p identity\n/// * create a libp2p swarm\n/// * create a mpsc channel for sending and receiving client commands\n/// * create a mpsc channel for sending and receiving custom events\n/// * create a [`Client`] for sending client commands\n/// * create an [`PyrsiaEventLoop`] to process swarm events and client commands\n///\n/// The Swarm is created with a [`NetworkBehaviour`] that is implemented by the\n/// [`PyrsiaNetworkBehaviour`]. The PyrsiaNetworkBehaviour contains the following\n/// components:\n///\n/// * Identify: a protocol for exchanging identity information between peers\n/// * Kademlia: a DHT to share information over the libp2p network\n/// * RequestResponse: a generic request/response protocol implementation for\n/// the [`FileExchangeProtocol`]\n///\n/// The maximum number of provided keys for the memory store that is used by\n/// Kademlia can be provided with the `max_provided_keys` parameter. This number\n/// should be equal to or higher than the total number of artifacts and manifests\n/// that the pyrsia node will be providing.\n///\n/// The Client uses the command channel to send commands that interact with the libp2p\n/// network. This is the main entry point for an application to perform actions on the\n/// libp2p network, i.e. dialing other peers, listing available providers, ...\n///\n/// The PyrsiaEventLoop uses the swarm and command channel for receiving swarm events\n/// and client commands respectively. It implements the actual logic of the commands\n/// by interacting with the libp2p swarm. The run method of the PyrsiaEventLoop must\n/// be called in order to start listening for swarm events and client commands.\n/// Ideally, this is done in a separate thread.\n///\n/// To get an idea of how these components are used, we explain this by following what\n/// happens when a client wants to announce itself as a provider of a specific hash.\n///\n/// 1. An application calls: `client.provide(\u0026some_hash)`.\n/// 2. The Client creates a oneshot channel.\n/// 3. The Client creates a [`Command::Provide`] that contains the hash and the sender\n///    of the oneshot channel.\n/// 4. The Client sends the command to the sender of the command channel.\n/// 5. The Client now awaits the receiver of the oneshot channel for the incoming\n///    response by the oneshot sender.\n/// 6. The PyrsiaEventLoop receives the command via the receiver of the command channel.\n/// 7. The PyrsiaEventLoop calls `handle_command` to start processing the command.\n/// 8. The implementation of Command::Provide will announce itself as a provider of\n///    `some_hash` on the Kademlia DHT and receives a QueryId.\n/// 9. The QueryId is stored in a map with the QueryId as the key and the sender of the\n///    oneshot channel as the value (which was passed down with the command).\n/// 10. The Kademlia DHT is doing its thing to make the peer known as a provider of the\n///     hash. When the operation has finished, Kademlia sends a Swarm event to notify\n///     the completion.\n/// 11. The PyrsiaEventLoop receives the event via the swarm listener.\n/// 12. The PyrsiaEventLoop calls `handle_kademlia_event` to start processing the event.\n/// 13. The Kademlia Event contains the QueryId and the Key that was provided.\n/// 14. The PyrsiaEventLoop looks up the oneshot sender in the map via the QueryId.\n/// 15. The PyrsiaEventLoop sends the result Ok() on the oneshot sender.\n/// 16. The Client receiver receives the incoming response and can now safely return\n///     to the application.\n///\n/// This function returns the following components:\n///  * the Client\n///  * the receiver part of the event channel\n///  * the PyrsiaEventLoop\npub fn setup_libp2p_swarm(\n    max_provided_keys: usize,\n) -\u003e Result\u003c(Client, impl Stream\u003cItem = PyrsiaEvent\u003e, PyrsiaEventLoop), Box\u003cdyn Error\u003e\u003e {\n    let local_keypair = keypair_util::load_or_generate_ed25519();\n\n    let (swarm, local_peer_id) = create_swarm(local_keypair, max_provided_keys)?;\n\n    let (command_sender, command_receiver) = mpsc::channel(32);\n    let (event_sender, event_receiver) = mpsc::channel(32);\n\n    Ok((\n        Client {\n            sender: command_sender,\n            local_peer_id,\n        },\n        event_receiver,\n        PyrsiaEventLoop::new(swarm, command_receiver, event_sender),\n    ))\n}\n\n// create the libp2p transport for the swarm\nfn create_transport(\n    keypair: identity::Keypair,\n) -\u003e std::io::Result\u003ccore::transport::Boxed\u003c(core::PeerId, core::muxing::StreamMuxerBox)\u003e\u003e {\n    let noise_keys = noise::Keypair::\u003cnoise::X25519Spec\u003e::new()\n        .into_authentic(\u0026keypair)\n        .expect(\"Signing libp2p-noise static DH keypair failed.\");\n\n    let tcp = tcp::TokioTcpConfig::new().nodelay(true);\n    let dns = dns::TokioDnsConfig::system(tcp)?;\n\n    Ok(dns\n        .upgrade(core::upgrade::Version::V1)\n        .authenticate(noise::NoiseConfig::xx(noise_keys).into_authenticated())\n        .multiplex(core::upgrade::SelectUpgrade::new(\n            yamux::YamuxConfig::default(),\n            mplex::MplexConfig::default(),\n        ))\n        .timeout(std::time::Duration::from_secs(20))\n        .boxed())\n}\n\n// create the libp2p swarm\nfn create_swarm(\n    keypair: identity::Keypair,\n    max_provided_keys: usize,\n) -\u003e Result\u003c(Swarm\u003cPyrsiaNetworkBehaviour\u003e, core::PeerId), Box\u003cdyn Error\u003e\u003e {\n    let peer_id = keypair.public().to_peer_id();\n\n    let identify_config =\n        identify::IdentifyConfig::new(String::from(\"ipfs/1.0.0\"), keypair.public());\n\n    let memory_store_config = MemoryStoreConfig {\n        max_provided_keys,\n        ..Default::default()\n    };\n\n    Ok((\n        SwarmBuilder::new(\n            create_transport(keypair)?,\n            PyrsiaNetworkBehaviour {\n                identify: identify::Identify::new(identify_config),\n                kademlia: kad::Kademlia::new(\n                    peer_id,\n                    MemoryStore::with_config(peer_id, memory_store_config),\n                ),\n                request_response: RequestResponse::new(\n                    ArtifactExchangeCodec(),\n                    iter::once((ArtifactExchangeProtocol(), ProtocolSupport::Full)),\n                    Default::default(),\n                ),\n                idle_metric_request_response: RequestResponse::new(\n                    IdleMetricExchangeCodec(),\n                    iter::once((IdleMetricExchangeProtocol(), ProtocolSupport::Full)),\n                    Default::default(),\n                ),\n            },\n            peer_id,\n        )\n        .executor(Box::new(|fut| {\n            tokio::spawn(fut);\n        }))\n        .build(),\n        peer_id,\n    ))\n}\n","traces":[{"line":106,"address":[6908672,6910047],"length":1,"stats":{"Line":0},"fn_name":"setup_libp2p_swarm"},{"line":109,"address":[6908708],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[6908758,6909063],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[6909051,6909122],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[6909199,6909247],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[6909735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[6909431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[6909311],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[6909351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[6909543],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[6909567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[6911445,6910080],"length":1,"stats":{"Line":0},"fn_name":"create_transport"},{"line":130,"address":[6910237,6910108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[6910288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[6910650,6910708,6910380],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[6911368,6910941,6910586,6911128,6911231,6910622,6911315],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[6910767,6910614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[6910775,6911015,6910880,6910980],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[6911093],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[6910996],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[6911033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[6911331,6911188,6911262],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[6913614,6911472],"length":1,"stats":{"Line":0},"fn_name":"create_swarm"},{"line":153,"address":[6911513,6911645],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[6911876,6911702],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[6913484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[6913317,6913154,6913436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[6911961,6912073,6912233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[6912981],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[6912158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[6912672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[6912386],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[6912463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[6912804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[6912717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[6912744],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[6912917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[6912830],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[6912857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[6913077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[6346864],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":186,"address":[6346907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":189,"address":[6913461],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":43},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","network.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod artifact_protocol;\npub mod behaviour;\npub mod client;\npub mod event_loop;\npub mod idle_metric_protocol;\npub mod p2p;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","node_api","handlers","swarm.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse super::{get_config, RegistryError, RegistryErrorCode};\nuse crate::artifact_service::handlers::*;\nuse crate::artifact_service::storage::ArtifactStorage;\nuse crate::network::client::Client;\nuse crate::node_api::model::cli::{ArtifactsSummary, Status};\n\nuse log::debug;\nuse std::collections::HashMap;\nuse warp::{http::StatusCode, Rejection, Reply};\n\npub async fn handle_get_peers(mut p2p_client: Client) -\u003e Result\u003cimpl Reply, Rejection\u003e {\n    let peers = p2p_client.list_peers().await.map_err(RegistryError::from)?;\n    debug!(\"Got received_peers: {:?}\", peers);\n\n    let str_peers: Vec\u003cString\u003e = peers.into_iter().map(|p| p.to_string()).collect();\n    let str_peers_as_json = serde_json::to_string(\u0026str_peers).unwrap();\n\n    Ok(warp::http::response::Builder::new()\n        .header(\"Content-Type\", \"application/octet-stream\")\n        .status(StatusCode::OK)\n        .body(str_peers_as_json)\n        .unwrap())\n}\n\npub async fn handle_get_status(\n    mut p2p_client: Client,\n    artifact_storage: ArtifactStorage,\n) -\u003e Result\u003cimpl Reply, Rejection\u003e {\n    let peers = p2p_client.list_peers().await.map_err(RegistryError::from)?;\n\n    let art_count_result = get_arts_summary(\u0026artifact_storage);\n    if art_count_result.is_err() {\n        return Err(warp::reject::custom(RegistryError {\n            code: RegistryErrorCode::Unknown(art_count_result.err().unwrap().to_string()),\n        }));\n    }\n\n    let disk_space_result = disk_usage(\u0026artifact_storage);\n    if disk_space_result.is_err() {\n        return Err(warp::reject::custom(RegistryError {\n            code: RegistryErrorCode::Unknown(disk_space_result.err().unwrap().to_string()),\n        }));\n    }\n\n    let cli_config = get_config();\n    if cli_config.is_err() {\n        return Err(warp::reject::custom(RegistryError {\n            code: RegistryErrorCode::Unknown(cli_config.err().unwrap().to_string()),\n        }));\n    }\n    let mut total_artifacts = 0;\n    let mut art_summ_map: HashMap\u003cString, usize\u003e = HashMap::new();\n    for (k, v) in art_count_result.unwrap().iter() {\n        if k == \"SHA256\" {\n            total_artifacts += v;\n            art_summ_map.insert(\"blobs\".to_string(), *v);\n        } else if k == \"SHA512\" {\n            total_artifacts += v;\n            art_summ_map.insert(\"manifests\".to_string(), *v);\n        }\n    }\n    let artifacts_summary = ArtifactsSummary {\n        total: total_artifacts.to_string(),\n        summary: art_summ_map,\n    };\n\n    let status = Status {\n        artifact_count: artifacts_summary,\n        peers_count: peers.len(),\n        peer_id: p2p_client.local_peer_id.to_string(),\n        disk_allocated: cli_config.unwrap().disk_allocated,\n        disk_usage: format!(\"{:.4}\", disk_space_result.unwrap()),\n    };\n\n    let status_as_json = serde_json::to_string(\u0026status).unwrap();\n\n    Ok(warp::http::response::Builder::new()\n        .header(\"Content-Type\", \"application/json\")\n        .status(StatusCode::OK)\n        .body(status_as_json)\n        .unwrap())\n}\n","traces":[{"line":27,"address":[4883089,4883072],"length":1,"stats":{"Line":0},"fn_name":"handle_get_peers"},{"line":41,"address":[4883152],"length":1,"stats":{"Line":0},"fn_name":"handle_get_status"}],"covered":0,"coverable":2},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","node_api","handlers.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod swarm;\npub use crate::cli_commands::config::*;\npub use crate::docker::error_util::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","node_api","model","cli.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct Status {\n    pub peers_count: usize,\n    pub peer_id: String,\n    pub artifact_count: ArtifactsSummary,\n    pub disk_allocated: String,\n    pub disk_usage: String,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ArtifactsSummary {\n    pub total: String,\n    pub summary: HashMap\u003cString, usize\u003e,\n}\n\nimpl std::fmt::Display for Status {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        writeln!(f, \"Connected Peers Count:       {}\", self.peers_count)?;\n        writeln!(f, \"Artifacts Count:             {}\", self.artifact_count)?;\n        writeln!(f, \"Total Disk Space Allocated:  {}\", self.disk_allocated)?;\n        write!(f, \"Disk Space Used:             {}%\", self.disk_usage)\n    }\n}\n\nimpl std::fmt::Display for ArtifactsSummary {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        write!(f, \"{} {:?}\", self.total, self.summary)\n    }\n}\n","traces":[{"line":36,"address":[6474352],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":37,"address":[6474549,6474385],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[6474528,6474746,6474595],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[6474934,6474780,6474724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[6474968,6474909],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[6475056],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":46,"address":[6475089],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","node_api","model.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod cli;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","node_api","routes.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse super::handlers::swarm::*;\nuse crate::artifact_service::storage::ArtifactStorage;\nuse crate::network::client::Client;\nuse warp::Filter;\n\npub fn make_node_routes(\n    p2p_client: Client,\n    artifact_storage: ArtifactStorage,\n) -\u003e impl Filter\u003cExtract = impl warp::Reply, Error = warp::Rejection\u003e + Clone {\n    let p2p_client_peers = p2p_client.clone();\n\n    let peers = warp::path!(\"peers\")\n        .and(warp::get())\n        .and(warp::path::end())\n        .and_then(move || handle_get_peers(p2p_client_peers.clone()));\n\n    let status = warp::path!(\"status\")\n        .and(warp::get())\n        .and(warp::path::end())\n        .and_then(move || handle_get_status(p2p_client.clone(), artifact_storage.clone()));\n\n    warp::any().and(peers.or(status))\n}\n","traces":[{"line":22,"address":[4884279,4883232],"length":1,"stats":{"Line":0},"fn_name":"make_node_routes"},{"line":26,"address":[4883254],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[4883590,4883314,4883411,4883465,4883447,4883366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[4883436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[4883454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[4883597,4883472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[4883718,4883837,4883605,4883664,4883700],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[4883689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[4883707],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[4883730,4883844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[4884184,4883852],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":11},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","node_api.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod handlers;\npub mod model;\npub mod routes;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","node_manager.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod handlers;\npub mod model;\n\npub use crate::artifacts_repository::artifact_manager::*;\npub use crate::artifacts_repository::hash_util::*;\npub use crate::cli_commands::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","transparency_log","log.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::util::env_util::read_var;\nuse log::debug;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::io::{self, Write};\nuse std::time::{SystemTime, UNIX_EPOCH};\nuse thiserror::Error;\n\n#[derive(Debug, Clone, Error, PartialEq)]\npub enum TransparencyLogError {\n    #[error(\"Duplicate ID {id:?} in transparency log\")]\n    DuplicateId { id: String },\n    #[error(\"ID {id:?} not found in transparency log\")]\n    NotFound { id: String },\n    #[error(\"Hash Verification failed for ID {id:?}: {invalid_hash:?} vs {actual_hash:?}\")]\n    InvalidHash {\n        id: String,\n        invalid_hash: String,\n        actual_hash: String,\n    },\n}\n\n#[derive(Debug, Clone, strum_macros::Display, Deserialize, Serialize, PartialEq)]\npub enum Operation {\n    AddArtifact,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct Payload {\n    id: String,\n    hash: String,\n    timestamp: u64,\n    operation: Operation,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct SignatureEnvelope {\n    /// The data that is integrity protected\n    payload: Payload,\n    /// The time at which the signature was generated. This is a part of signed attributes\n    signing_timestamp: u64,\n    /// The digital signature computed on payload and signed attributes\n    signature: Vec\u003cu8\u003e,\n    /// the public key of the signer\n    sign_identifier: [u8; 32], //this is identity::ed25519::PublicKey(a byte array in compressed form\n}\n\n#[derive(Clone)]\npub struct TransparencyLog {\n    payloads: HashMap\u003cString, Payload\u003e,\n}\n\nimpl TransparencyLog {\n    pub fn new() -\u003e Self {\n        TransparencyLog {\n            payloads: HashMap::new(),\n        }\n    }\n\n    pub fn add_artifact(\u0026mut self, id: \u0026str, hash: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n        let payload = Payload {\n            id: id.to_string(),\n            hash: hash.to_string(),\n            timestamp: SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            operation: Operation::AddArtifact,\n        };\n\n        write_payload(\u0026payload)?;\n        self.payloads.insert(id.into(), payload);\n\n        Ok(())\n    }\n\n    pub fn verify_artifact(\u0026mut self, id: \u0026str, hash: \u0026str) -\u003e Result\u003c(), TransparencyLogError\u003e {\n        if let Some(payload) = self.payloads.get(id) {\n            if payload.hash == hash {\n                Ok(())\n            } else {\n                Err(TransparencyLogError::InvalidHash {\n                    id: String::from(id),\n                    invalid_hash: String::from(hash),\n                    actual_hash: payload.hash.clone(),\n                })\n            }\n        } else {\n            Err(TransparencyLogError::NotFound {\n                id: String::from(id),\n            })\n        }\n    }\n\n    pub fn get_artifact(\u0026mut self, namespace_specific_id: \u0026str) -\u003e anyhow::Result\u003cString\u003e {\n        if let Some(payload) = self.payloads.get(namespace_specific_id) {\n            return Ok(String::from(\u0026payload.hash));\n        }\n\n        anyhow::bail!(\"No payload found with specified ID\");\n    }\n}\n\nfn write_payload(payload: \u0026Payload) -\u003e anyhow::Result\u003c()\u003e {\n    let payload_storage_path = get_payload_storage_path();\n    fs::create_dir_all(\u0026payload_storage_path)?;\n    let payload_filename = format!(\n        \"{}/{}.log\",\n        payload_storage_path,\n        str::replace(\u0026payload.id, \"/\", \"_\")\n    );\n    debug!(\n        \"Storing transparency log payload at: {:?}\",\n        payload_filename\n    );\n    match fs::File::options()\n        .write(true)\n        .create_new(true)\n        .open(\u0026payload_filename)\n    {\n        Ok(mut payload_file) =\u003e {\n            let json_payload = serde_json::to_string(payload)?;\n            payload_file.write_all(json_payload.as_bytes())?;\n            Ok(())\n        }\n        Err(e) =\u003e match e.kind() {\n            io::ErrorKind::AlreadyExists =\u003e Err(TransparencyLogError::DuplicateId {\n                id: payload.id.clone(),\n            }\n            .into()),\n            _ =\u003e Err(e.into()),\n        },\n    }\n}\n\nfn get_payload_storage_path() -\u003e String {\n    format!(\n        \"{}/{}\",\n        read_var(\"PYRSIA_ARTIFACT_PATH\", \"pyrsia\"),\n        \"transparency_log\"\n    )\n}\n\nimpl Default for TransparencyLog {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::util::test_util;\n    use assay::assay;\n\n    #[test]\n    fn create_payload() {\n        let id = \"id\";\n        let hash = \"hash\";\n        let timestamp = 1234567890;\n        let operation = Operation::AddArtifact;\n        let payload = Payload {\n            id: id.to_string(),\n            hash: hash.to_string(),\n            timestamp,\n            operation: Operation::AddArtifact,\n        };\n\n        assert_eq!(payload.id, id);\n        assert_eq!(payload.hash, hash);\n        assert_eq!(payload.timestamp, timestamp);\n        assert_eq!(payload.operation, operation);\n    }\n\n    #[assay(\n        env = [\n            (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-transparency-log\"),\n            (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    fn test_new_transparency_log_has_empty_payload() {\n        let log = TransparencyLog::new();\n\n        assert_eq!(log.payloads.len(), 0);\n    }\n\n    #[assay(\n        env = [\n            (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-transparency-log\"),\n            (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    fn test_with_default() {\n        let log: TransparencyLog = Default::default();\n\n        assert_eq!(log.payloads.len(), 0);\n    }\n\n    #[assay(\n        env = [\n            (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-transparency-log\"),\n            (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    fn test_add_artifact() {\n        let mut log = TransparencyLog::new();\n\n        let result = log.add_artifact(\"id\", \"hash\");\n        assert!(result.is_ok());\n\n        assert!(log.payloads.contains_key(\"id\"));\n    }\n\n    #[assay(\n        env = [\n            (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-transparency-log\"),\n            (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    fn test_add_artifact_with_id_containing_forward_slash() {\n        let mut log = TransparencyLog::new();\n\n        let result = log.add_artifact(\"id/with/slash\", \"hash\");\n        assert!(result.is_ok());\n\n        assert!(log.payloads.contains_key(\"id/with/slash\"));\n    }\n\n    #[assay(\n        env = [\n            (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-transparency-log\"),\n            (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    fn test_add_duplicate_artifact() {\n        let mut log = TransparencyLog::new();\n\n        let result = log.add_artifact(\"id\", \"hash\");\n        assert!(result.is_ok());\n\n        let result = log.add_artifact(\"id\", \"hash2\");\n        assert!(result.is_err());\n    }\n\n    #[assay(\n        env = [\n            (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-transparency-log\"),\n            (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    fn test_verify_artifact() {\n        let mut log = TransparencyLog::new();\n\n        log.add_artifact(\"id\", \"hash\")\n            .expect(\"Adding artifact failed.\");\n\n        let result = log.verify_artifact(\"id\", \"hash\");\n        assert!(result.is_ok());\n    }\n\n    #[assay(\n        env = [\n            (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-transparency-log\"),\n            (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    fn test_verify_unknown_artifact() {\n        let mut log = TransparencyLog::new();\n\n        let result = log.verify_artifact(\"id\", \"hash\");\n        assert!(result.is_err());\n        assert_eq!(\n            result,\n            Err(TransparencyLogError::NotFound {\n                id: String::from(\"id\")\n            })\n        );\n    }\n\n    #[assay(\n        env = [\n            (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-transparency-log\"),\n            (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    fn test_verify_artifact_with_invalid_hash() {\n        let mut log = TransparencyLog::new();\n\n        log.add_artifact(\"id\", \"hash\")\n            .expect(\"Adding artifact failed.\");\n\n        let result = log.verify_artifact(\"id\", \"invalid_hash\");\n        assert!(result.is_err());\n        assert_eq!(\n            result,\n            Err(TransparencyLogError::InvalidHash {\n                id: String::from(\"id\"),\n                invalid_hash: String::from(\"invalid_hash\"),\n                actual_hash: String::from(\"hash\"),\n            })\n        );\n    }\n}\n","traces":[{"line":71,"address":[6229232],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":73,"address":[6229246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":77,"address":[6229296,6229765],"length":1,"stats":{"Line":0},"fn_name":"add_artifact"},{"line":79,"address":[6229376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[6229407],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[6229414,6229581,6229486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[6229785,6229976,6229916,6229753,6229844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[6229897,6230029],"length":1,"stats":{"Line":0},"fn_name":null},{"line":91,"address":[6230147],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[6230192,6230822],"length":1,"stats":{"Line":0},"fn_name":"verify_artifact"},{"line":95,"address":[6230282],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[6230776,6230519,6230333,6230476],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[6230512],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[6230620],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[6230492],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[6230521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[6230551],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[6230381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[6230363],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[6230848],"length":1,"stats":{"Line":0},"fn_name":"get_artifact"},{"line":113,"address":[6230928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[6230974,6231084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[6230990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[6231120,6232510],"length":1,"stats":{"Line":0},"fn_name":"write_payload"},{"line":122,"address":[6231143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[6231172,6231401,6231331,6231263],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[6231296,6231572,6231872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[6231484],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[6231920,6232152,6231831,6231967,6232058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[6232525,6232122,6232335],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[6232535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[6232557,6232961,6233009,6233117,6233167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[6233296,6233100,6233226,6233454,6233384],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[6233350],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[6232567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[6232758],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[6232686],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[6232835],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[6232705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[6233906,6233616],"length":1,"stats":{"Line":0},"fn_name":"get_payload_storage_path"},{"line":154,"address":[6233939,6233671],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[6233633],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[6233984],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":163,"address":[6233992],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[5985237,5985232],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":175,"address":[4826887],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[4826908],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[4826929],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[4826941],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[4826964],"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":[4827208,4827077,4827345],"length":1,"stats":{"Line":2},"fn_name":null},{"line":187,"address":[4827395,4827510,4827253],"length":1,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[4827652,4827401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":189,"address":[4827738,4827707,4827565],"length":1,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[5985264,5985311,5985269,5985296,5986377,5986346,5985581,5985527,5986315,5986368],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":197,"address":[5986308],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[4827808],"length":1,"stats":{"Line":1},"fn_name":"test_new_transparency_log_has_empty_payload"},{"line":200,"address":[5985661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[5985676,5985849],"length":1,"stats":{"Line":0},"fn_name":null},{"line":205,"address":[4829359,4829568,4829744,4829051,4829941,4829677,4829454,4829552,4829130,4829309,4829582,4828903,4829018,4829751,4829866],"length":1,"stats":{"Line":11},"fn_name":"modify"},{"line":210,"address":[5987476],"length":1,"stats":{"Line":0},"fn_name":null},{"line":212,"address":[4828896],"length":1,"stats":{"Line":1},"fn_name":"test_with_default"},{"line":213,"address":[5986829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":215,"address":[5987017,5986844],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[4830832,4830670,4830954,4830765,4830656,4830106,4830218,4830397,4830839,4830447,4829991,4830139,4830542,4830640,4831029],"length":1,"stats":{"Line":11},"fn_name":"modify"},{"line":223,"address":[5988255],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[4829984],"length":1,"stats":{"Line":1},"fn_name":"test_add_artifact"},{"line":226,"address":[5987949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[5987956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":229,"address":[5988022,5988153,5988077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[5988210,5988122,5988189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[4831744,4831758,4831630,4831728,4832042,4831079,4832117,4831853,4831194,4831927,4831920,4831227,4831485,4831306,4831535],"length":1,"stats":{"Line":11},"fn_name":"modify"},{"line":239,"address":[5989023],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[4831072],"length":1,"stats":{"Line":1},"fn_name":"test_add_artifact_with_id_containing_forward_slash"},{"line":242,"address":[5988717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[5988724],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[5988921,5988790,5988845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[5988978,5988890,5988957],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[4832315,4832816,4832832,4832573,4832718,4832167,4832394,4832282,4832846,4833008,4833015,4832941,4833205,4832623,4833130],"length":1,"stats":{"Line":11},"fn_name":"modify"},{"line":255,"address":[5989900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[4832160],"length":1,"stats":{"Line":1},"fn_name":"test_add_duplicate_artifact"},{"line":258,"address":[5989488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[5989495],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[5989616,5989561,5989706],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[5989743,5989661],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[5989837,5989759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":267,"address":[4833920,4833661,4833711,4833255,4833934,4834096,4833403,4834218,4833482,4833370,4834029,4833904,4834103,4834293,4833806],"length":1,"stats":{"Line":11},"fn_name":"modify"},{"line":272,"address":[5990669],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[4833248],"length":1,"stats":{"Line":1},"fn_name":"test_verify_artifact"},{"line":275,"address":[5990365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[5990372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":280,"address":[5990488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":281,"address":[5990544,5990622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":284,"address":[4835306,4834749,4834343,4835022,4834799,4834491,4835381,4834894,4834570,4834992,4835191,4834458,4835117,4835184,4835008],"length":1,"stats":{"Line":11},"fn_name":"modify"},{"line":289,"address":[5992172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[4834336],"length":1,"stats":{"Line":1},"fn_name":"test_verify_unknown_artifact"},{"line":292,"address":[5991181],"length":1,"stats":{"Line":0},"fn_name":null},{"line":294,"address":[5991188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[5991299,5991244,5991371],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[5991535],"length":1,"stats":{"Line":0},"fn_name":null},{"line":298,"address":[5991403],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[5991344],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[4836272,4835579,4836394,4836110,4836205,4835546,4835982,4835658,4836279,4835887,4835431,4836469,4836080,4836096,4835837],"length":1,"stats":{"Line":11},"fn_name":"modify"},{"line":309,"address":[5993969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[4835424],"length":1,"stats":{"Line":1},"fn_name":"test_verify_artifact_with_invalid_hash"},{"line":312,"address":[5992701],"length":1,"stats":{"Line":0},"fn_name":null},{"line":314,"address":[5992708],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[5992824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[5992880,5992970],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[5993293,5993415],"length":1,"stats":{"Line":0},"fn_name":null},{"line":321,"address":[5993097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":322,"address":[5992943],"length":1,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[5993002],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[5993029],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":26,"coverable":114},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","transparency_log.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod log;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","util","env_util.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse std::env;\n\npub fn read_var(variable_name: \u0026str, default_value: \u0026str) -\u003e String {\n    match env::var(variable_name) {\n        Ok(v) =\u003e {\n            let tr = v.trim();\n            if !tr.is_empty() {\n                String::from(tr)\n            } else {\n                String::from(default_value)\n            }\n        }\n        Err(_err) =\u003e String::from(default_value),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use assay::assay;\n\n    #[assay(\n        env = [\n          (\"DEV_MODE\", \"on\")\n        ],)]\n    fn test_value_present() {\n        assert_eq!(\"on\", read_var(\"DEV_MODE\", \"off\"));\n    }\n\n    #[assay(\n        env = [\n          (\"DEV_MODE\", \"on \")\n        ],)]\n    fn test_value_present_trim() {\n        assert_eq!(\"on\", read_var(\"DEV_MODE\", \"off\"));\n    }\n\n    #[assay(\n        env = [\n            (\"DEV_MODE\", \"\")\n        ],)]\n    fn test_value_empty() {\n        assert_eq!(\"off\", read_var(\"DEV_MODE\", \"off\"));\n    }\n\n    #[assay]\n    fn test_value_absent() {\n        assert_eq!(\"absent\", read_var(\"DEV_MODE\", \"absent\"));\n    }\n}\n","traces":[{"line":19,"address":[6518064,6518306],"length":1,"stats":{"Line":0},"fn_name":"read_var"},{"line":20,"address":[6518123],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[6518150],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[6518184,6518344,6518409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[6518441],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[6518499],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[6518477,6518527],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[6518219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[6435552,6435815,6436576,6436624,6436607,6435584,6435599,6435557,6436633],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":42,"address":[6916432],"length":1,"stats":{"Line":1},"fn_name":"test_value_present"},{"line":43,"address":[6435869,6435950],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[6436688,6437760,6436720,6436735,6436693,6436951,6437712,6437743,6437769],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":50,"address":[6917520],"length":1,"stats":{"Line":1},"fn_name":"test_value_present_trim"},{"line":51,"address":[6437005,6437086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[6437829,6437871,6438847,6437824,6438896,6438878,6438905,6438086,6437856],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":58,"address":[6918608],"length":1,"stats":{"Line":1},"fn_name":"test_value_empty"},{"line":59,"address":[6438221,6438140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[6440009,6439007,6439950,6440000,6439370,6438960,6438965,6438992,6439200],"length":1,"stats":{"Line":7},"fn_name":"{closure#0}"},{"line":63,"address":[6919696],"length":1,"stats":{"Line":1},"fn_name":"test_value_absent"},{"line":64,"address":[6439160,6439286,6439415],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":8,"coverable":20},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","util","keypair_util.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::util::env_util::read_var;\n\nuse libp2p::identity;\nuse log::warn;\nuse std::error;\nuse std::fs;\nuse std::io::{self, Read, Write};\n\nconst KEYPAIR_FILENAME: \u0026str = \"p2p_keypair.ser\";\n\n/// Load a ed25519 keypair from disk. If a keypair file does not yet exist,\n/// a new keypair is generated and then saved to disk.\npub fn load_or_generate_ed25519() -\u003e identity::Keypair {\n    let keypair_path = get_keypair_path();\n    match load_ed25519(\u0026keypair_path) {\n        Ok(keypair) =\u003e identity::Keypair::Ed25519(keypair),\n        Err(_) =\u003e {\n            let keypair = identity::ed25519::Keypair::generate();\n            if let Err(e) = save_ed25519(\u0026keypair, \u0026keypair_path) {\n                warn!(\"Failed to persist newly generated keypair: {:?}\", e);\n            }\n            identity::Keypair::Ed25519(keypair)\n        }\n    }\n}\n\n// Load a keypair from the specified path. It only returns a Keypair if all\n// the following conditions are met:\n//\n//  * the file at the specified path exists\n//  * the size of the file is exactly 64 bytes\n//  * no io errors occured while reading from the file\nfn load_ed25519(keypair_path: \u0026str) -\u003e Result\u003cidentity::ed25519::Keypair, Box\u003cdyn error::Error\u003e\u003e {\n    let mut keypair_file = fs::File::open(keypair_path)?;\n    let keypair_metadata = fs::metadata(keypair_path)?;\n    if keypair_metadata.len() == 64 {\n        let mut buffer = vec![0; 64];\n        keypair_file.read_exact(\u0026mut buffer)?;\n        return Ok(identity::ed25519::Keypair::decode(\u0026mut buffer)?);\n    }\n\n    Err(Box::new(io::Error::from(io::ErrorKind::InvalidData)))\n}\n\n// Save the provided keypair to the specified path.\nfn save_ed25519(\n    keypair: \u0026identity::ed25519::Keypair,\n    keypair_path: \u0026str,\n) -\u003e Result\u003c(), Box\u003cdyn error::Error\u003e\u003e {\n    let mut keypair_file = fs::File::create(\u0026keypair_path)?;\n    keypair_file.write_all(\u0026keypair.encode())?;\n    Ok(())\n}\n\n// Get the path on disk where the keypair is stored.\nfn get_keypair_path() -\u003e String {\n    format!(\n        \"{}/{}\",\n        read_var(\"PYRSIA_ARTIFACT_PATH\", \"pyrsia\"),\n        KEYPAIR_FILENAME\n    )\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn load_non_existing_keypair_fails() {\n        let tmp_dir = tempfile::tempdir().unwrap();\n        let path = tmp_dir\n            .path()\n            .join(\"load_non_existing_keypair_fails\")\n            .join(KEYPAIR_FILENAME);\n\n        let keypair = load_ed25519(path.to_str().unwrap());\n        assert!(keypair.is_err());\n    }\n\n    #[test]\n    fn load_existing_keypair_with_wrong_size_fails() {\n        let tmp_file = tempfile::Builder::new().tempfile().unwrap();\n        tmp_file.as_file().write_all(\u0026vec![1; 32]).unwrap();\n\n        let keypair = load_ed25519(tmp_file.path().to_str().unwrap());\n        assert!(keypair.is_err());\n    }\n\n    #[test]\n    fn load_existing_keypair_succeeds() {\n        let tmp_file = tempfile::Builder::new().tempfile().unwrap();\n        tmp_file.as_file().write_all(\u0026vec![1; 64]).unwrap();\n\n        let keypair = load_ed25519(tmp_file.path().to_str().unwrap());\n        assert!(keypair.is_ok());\n    }\n\n    #[test]\n    fn saved_keypair_can_be_loaded() {\n        let tmp_file = tempfile::Builder::new().tempfile().unwrap();\n\n        let saved_keypair = identity::ed25519::Keypair::generate();\n        let save_result = save_ed25519(\u0026saved_keypair, tmp_file.path().to_str().unwrap());\n        assert!(save_result.is_ok());\n\n        let loaded_keypair = load_ed25519(tmp_file.path().to_str().unwrap()).unwrap();\n        assert_eq!(saved_keypair.encode(), loaded_keypair.encode());\n    }\n}\n","traces":[{"line":29,"address":[4611056,4611190],"length":1,"stats":{"Line":0},"fn_name":"load_or_generate_ed25519"},{"line":30,"address":[4611073],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[4611096,4611173,4611205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[4611207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[4611306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[4611468,4611403,4611330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[4611558,4611635,4611758,4611846,4611682],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[4612040],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[4612240,4613738],"length":1,"stats":{"Line":1},"fn_name":"load_ed25519"},{"line":50,"address":[4612529,4612317],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[4612792,4612824,4612575,4612669,4612502],"length":1,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[4612875,4612768],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[4612881],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[4613120,4613229,4613320,4613352],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[4613283,4613411],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[4612910,4613079],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[4613760,4614262],"length":1,"stats":{"Line":1},"fn_name":"save_ed25519"},{"line":66,"address":[4613795,4613957],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[4613938,4614012,4614089,4614235,4614162],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[4614137],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[4614288,4614578],"length":1,"stats":{"Line":0},"fn_name":"get_keypair_path"},{"line":73,"address":[4614611,4614343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[4614305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[6041397,6041392],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":86,"address":[4442583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[4442621,4442735],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[4442794],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[4442859,4442927],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[4443015,4443093],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[6041424,6041429],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":98,"address":[4443191],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[4443246,4443347],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[4443495],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[4443610,4443688],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[4444309,4443760],"length":1,"stats":{"Line":3},"fn_name":"load_existing_keypair_succeeds"},{"line":107,"address":[4443767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[4443923,4443822],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[4444071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[4444264,4444186],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[4445234,4444336],"length":1,"stats":{"Line":3},"fn_name":"saved_keypair_can_be_loaded"},{"line":116,"address":[4444343],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[4444407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[4444579,4444514,4444434],"length":1,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[4444676,4444764],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[4444806,4444747],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[4444916,4445019,4445137],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":34,"coverable":46},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","util","test_util.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n#[cfg(test)]\npub fn tear_down() {\n    if std::path::Path::new(\u0026std::env::var(\"PYRSIA_ARTIFACT_PATH\").unwrap()).exists() {\n        std::fs::remove_dir_all(std::env::var(\"PYRSIA_ARTIFACT_PATH\").unwrap()).expect(\u0026format!(\n            \"unable to remove test directory {}\",\n            std::env::var(\"PYRSIA_ARTIFACT_PATH\").unwrap()\n        ));\n    }\n}\n","traces":[{"line":18,"address":[6040448,6040603],"length":1,"stats":{"Line":0},"fn_name":"tear_down"},{"line":19,"address":[6040622,6040455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[6040636,6040809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[6040710],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","util.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod env_util;\npub mod keypair_util;\npub mod test_util;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","tests","string_manipulation","src","lib.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse std::io::BufRead;\n\n// Reads the first line from a BufRead\npub fn first_line\u003cR\u003e(mut rdr: R) -\u003e String\nwhere\n    R: BufRead,\n{\n    let mut first_line: String = String::new();\n    rdr.read_line(\u0026mut first_line).expect(\"Unable to read line\");\n    first_line\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3}]};
        var previousData = {"files":[{"path":["/","home","joeri","devel","github","tiainen","pyrsia","pyrsia_cli","build.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\nuse anyhow::Result;\nuse vergen::{vergen, Config};\n\nfn main() -\u003e Result\u003c()\u003e {\n    vergen(Config::default())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","pyrsia_cli","src","cli","handlers.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse super::config::*;\nuse super::node::*;\nuse std::collections::HashSet;\nuse std::io;\nuse std::io::BufRead;\n\npub fn config_add() {\n    println!(\"Enter host: \");\n    let mut new_cfg = CliConfig {\n        host: io::stdin().lock().lines().next().unwrap().unwrap(),\n        ..Default::default()\n    };\n\n    println!(\"Enter port: \");\n    new_cfg.port = io::stdin().lock().lines().next().unwrap().unwrap();\n\n    println!(\"Enter disk space to be allocated to pyrsia(Please enter with units ex: 10 GB): \");\n    new_cfg.disk_allocated = io::stdin().lock().lines().next().unwrap().unwrap();\n\n    let result = add_config(new_cfg);\n    match result {\n        Ok(_result) =\u003e {\n            println!(\"Node configuration Saved !!\");\n        }\n        Err(error) =\u003e {\n            println!(\"Error Saving Node Configuration:       {}\", error);\n        }\n    };\n}\n\npub fn config_show() {\n    let result = get_config();\n    match result {\n        Ok(config) =\u003e {\n            println!(\"{}\", config)\n        }\n        Err(error) =\u003e {\n            println!(\"No Node Configured:       {}\", error);\n        }\n    };\n}\n\npub async fn node_ping() {\n    let result = ping().await;\n    match result {\n        Ok(_resp) =\u003e {\n            println!(\"Connection Successful !!\")\n        }\n        Err(error) =\u003e {\n            println!(\"Error: {}\", error);\n        }\n    };\n}\n\npub async fn node_status() {\n    let result = status().await;\n    let _resp = match result {\n        Ok(resp) =\u003e {\n            println!(\"{}\", resp);\n        }\n        Err(error) =\u003e {\n            println!(\"Error: {}\", error);\n        }\n    };\n}\n\npub async fn node_list() {\n    let result = peers_connected().await;\n    let _resp = match result {\n        Ok(resp) =\u003e {\n            println!(\"Connected Peers:\");\n            let peers_split = resp.split(',');\n            let mut unique_peers = HashSet::new();\n            for peer in peers_split {\n                unique_peers.insert(peer);\n            }\n            unique_peers.iter().for_each(|p| println!(\"{}\", p));\n        }\n        Err(error) =\u003e {\n            println!(\"Error: {}\", error);\n        }\n    };\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","pyrsia_cli","src","cli","parser.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse clap::{arg, command, crate_version, AppSettings, ArgMatches, Command};\nuse const_format::formatcp;\n\npub fn cli_parser() -\u003e ArgMatches {\n    let version_string: \u0026str = formatcp!(\"{} ({})\", crate_version!(), env!(\"VERGEN_GIT_SHA\"));\n    command!()\n        .arg_required_else_help(true)\n        .global_setting(AppSettings::DeriveDisplayOrder)\n        .propagate_version(false)\n        // Config subcommand\n        .subcommands(vec![\n            Command::new(\"config\")\n                .short_flag('c')\n                .about(\"Pyrsia config commands\")\n                .arg_required_else_help(true)\n                .args(\u0026[\n                    arg!(-a --add      \"Adds a node configuration\"),\n                    arg!(-e --edit     \"Edits a node configuration\"),\n                    arg!(-r --remove   \"Removes the stored node configuration\").visible_alias(\"rm\"),\n                    arg!(-s --show     \"Shows the stored node configuration\"),\n                ]),\n            Command::new(\"list\")\n                .short_flag('l')\n                .about(\"Shows list of connected Peers\"),\n            Command::new(\"ping\").about(\"Pings configured pyrsia node\"),\n            Command::new(\"status\")\n                .short_flag('s')\n                .about(\"Shows node information\"),\n        ])\n        .version(version_string)\n        .get_matches()\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","pyrsia_cli","src","cli.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod handlers;\npub mod parser;\n\nuse pyrsia::cli_commands::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","pyrsia_cli","src","main.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod cli;\n\nuse cli::handlers::*;\nuse cli::parser::*;\n\n#[tokio::main]\nasync fn main() {\n    // parsing command line arguments\n    let matches = cli_parser();\n\n    // checking and preparing responses for each command and its arguments if applicable\n\n    match matches.subcommand() {\n        Some((\"config\", config_matches)) =\u003e {\n            if config_matches.is_present(\"add\") || config_matches.is_present(\"edit\") {\n                config_add();\n            }\n            if config_matches.is_present(\"show\") {\n                config_show();\n            }\n        }\n        Some((\"list\", _config_matches)) =\u003e {\n            node_list().await;\n        }\n        Some((\"ping\", _config_matches)) =\u003e {\n            node_ping().await;\n        }\n        Some((\"status\", _config_matches)) =\u003e {\n            node_status().await;\n        }\n        _ =\u003e {} //this should be handled by clap arg_required_else_help\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","pyrsia_node","src","args","parser.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse clap::Parser;\nuse libp2p::Multiaddr;\n\nconst DEFAULT_HOST: \u0026str = \"127.0.0.1\";\nconst DEFAULT_LISTEN_ADDRESS: \u0026str = \"/ip4/0.0.0.0/tcp/0\";\nconst DEFAULT_MAX_PROVIDED_KEYS: \u0026str = \"32768\";\nconst DEFAULT_PORT: \u0026str = \"7888\";\n\n/// Application to connect to and participate in the Pyrsia network\n#[derive(Debug, Parser)]\n#[clap(name = \"Pyrsia Node\")]\npub struct PyrsiaNodeArgs {\n    /// The host address to bind to for the Docker API\n    #[clap(long, short = 'H', default_value = DEFAULT_HOST)]\n    pub host: String,\n    /// The address to listen to for incoming requests from other pyrsia nodes\n    #[clap(long = \"listen\", short = 'L', default_value = DEFAULT_LISTEN_ADDRESS)]\n    pub listen_address: Multiaddr,\n    /// the port to listen to for the Docker API\n    #[clap(long, short, default_value = DEFAULT_PORT)]\n    pub port: String,\n    /// An address to connect with another Pyrsia Node (eg /ip4/127.0.0.1/tcp/45153/p2p/12D3KooWKsHbKbcVgyiRRgeXGCK4bp3MngnSU7ioeKTfQzd18B2v)\n    #[clap(long, short = 'P')]\n    pub peer: Option\u003cMultiaddr\u003e,\n    /// The maximum number of keys that can be provided on the network by this Pyrsia Node.\n    #[clap(long, default_value = DEFAULT_MAX_PROVIDED_KEYS)]\n    pub max_provided_keys: usize,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","pyrsia_node","src","args.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod parser;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","pyrsia_node","src","main.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod args;\npub mod network;\n\nuse anyhow::{bail, Result};\nuse args::parser::PyrsiaNodeArgs;\nuse network::handlers;\nuse pyrsia::artifact_service::storage::ArtifactStorage;\nuse pyrsia::docker::error_util::*;\nuse pyrsia::docker::v2::routes::make_docker_routes;\nuse pyrsia::logging::*;\nuse pyrsia::network::client::Client;\nuse pyrsia::network::p2p;\nuse pyrsia::node_api::routes::make_node_routes;\nuse pyrsia::transparency_log::log::TransparencyLog;\nuse pyrsia::util::keypair_util;\nuse pyrsia_blockchain_network::blockchain::Blockchain;\n\nuse clap::Parser;\nuse futures::lock::Mutex;\nuse futures::StreamExt;\nuse log::{debug, info, warn};\nuse std::error::Error;\nuse std::net::{IpAddr, Ipv4Addr, SocketAddr};\nuse std::sync::Arc;\nuse warp::Filter;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    pretty_env_logger::init();\n\n    debug!(\"Parse CLI arguments\");\n    let args = PyrsiaNodeArgs::parse();\n\n    debug!(\"Create transparency log\");\n    let transparency_log = TransparencyLog::new();\n\n    debug!(\"Create p2p components\");\n    let (p2p_client, mut p2p_events, event_loop) = p2p::setup_libp2p_swarm(args.max_provided_keys)?;\n\n    debug!(\"Create artifact storage\");\n    let artifact_storage = ArtifactStorage::new()?;\n\n    debug!(\"Create blockchain components\");\n    let _blockchain = setup_blockchain()?;\n\n    debug!(\"Start p2p event loop\");\n    tokio::spawn(event_loop.run());\n\n    debug!(\"Setup HTTP server\");\n    setup_http(\n        \u0026args,\n        transparency_log,\n        p2p_client.clone(),\n        artifact_storage.clone(),\n    );\n\n    debug!(\"Start p2p components\");\n    setup_p2p(p2p_client.clone(), args).await;\n\n    debug!(\"Listen for p2p events\");\n    loop {\n        if let Some(event) = p2p_events.next().await {\n            match event {\n                // Reply with the content of the artifact on incoming requests.\n                pyrsia::network::event_loop::PyrsiaEvent::RequestArtifact {\n                    artifact_type,\n                    artifact_hash,\n                    channel,\n                } =\u003e {\n                    if let Err(error) = handlers::handle_request_artifact(\n                        p2p_client.clone(),\n                        artifact_storage.clone(),\n                        \u0026artifact_type,\n                        \u0026artifact_hash,\n                        channel,\n                    )\n                    .await\n                    {\n                        warn!(\n                            \"This node failed to provide artifact with type {} and hash {}. Error: {:?}\",\n                            artifact_type, artifact_hash, error\n                        );\n                    }\n                }\n                pyrsia::network::event_loop::PyrsiaEvent::IdleMetricRequest { channel } =\u003e {\n                    if let Err(error) =\n                        handlers::handle_request_idle_metric(p2p_client.clone(), channel).await\n                    {\n                        warn!(\n                            \"This node failed to provide idle metrics. Error: {:?}\",\n                            error\n                        );\n                    }\n                }\n            }\n        }\n    }\n}\n\nfn setup_http(\n    args: \u0026PyrsiaNodeArgs,\n    transparency_log: TransparencyLog,\n    p2p_client: Client,\n    artifact_storage: ArtifactStorage,\n) {\n    // Get host and port from the settings. Defaults to DEFAULT_HOST and DEFAULT_PORT\n    debug!(\n        \"Pyrsia Docker Node will bind to host = {}, port = {}\",\n        args.host, args.port\n    );\n\n    let address = SocketAddr::new(\n        IpAddr::V4(args.host.parse::\u003cIpv4Addr\u003e().unwrap()),\n        args.port.parse::\u003cu16\u003e().unwrap(),\n    );\n\n    debug!(\"Setup HTTP routing\");\n    let docker_routes = make_docker_routes(\n        transparency_log,\n        p2p_client.clone(),\n        artifact_storage.clone(),\n    );\n    let node_api_routes = make_node_routes(p2p_client, artifact_storage);\n    let all_routes = docker_routes.or(node_api_routes);\n\n    debug!(\"Setup HTTP server\");\n    let (addr, server) = warp::serve(\n        all_routes\n            .and(http::log_headers())\n            .recover(custom_recover)\n            .with(warp::log(\"pyrsia_registry\")),\n    )\n    .bind_ephemeral(address);\n\n    info!(\n        \"Pyrsia Docker Node will start running on {}:{}\",\n        addr.ip(),\n        addr.port()\n    );\n\n    tokio::spawn(server);\n}\n\nasync fn setup_p2p(mut p2p_client: Client, args: PyrsiaNodeArgs) {\n    p2p_client\n        .listen(\u0026args.listen_address)\n        .await\n        .expect(\"Listening should not fail\");\n\n    if let Some(to_dial) = args.peer {\n        handlers::dial_other_peer(p2p_client.clone(), \u0026to_dial).await;\n    }\n}\n\npub fn setup_blockchain() -\u003e Result\u003cArc\u003cMutex\u003cBlockchain\u003e\u003e\u003e {\n    let local_keypair = keypair_util::load_or_generate_ed25519();\n\n    let ed25519_keypair = match local_keypair {\n        libp2p::identity::Keypair::Ed25519(v) =\u003e v,\n        _ =\u003e {\n            bail!(\"Keypair Format Error\");\n        }\n    };\n\n    Ok(Arc::new(Mutex::new(Blockchain::new(\u0026ed25519_keypair))))\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::setup_blockchain;\n\n    #[test]\n    fn setup_blockchain_success() {\n        let blockchain = setup_blockchain();\n        assert!(blockchain.is_ok());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","pyrsia_node","src","network","handlers.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse libp2p::request_response::ResponseChannel;\nuse libp2p::Multiaddr;\nuse log::{debug, info};\nuse pyrsia::artifact_service;\nuse pyrsia::artifact_service::storage::ArtifactStorage;\nuse pyrsia::network::artifact_protocol::ArtifactResponse;\nuse pyrsia::network::client::{ArtifactType, Client};\nuse pyrsia::network::idle_metric_protocol::{IdleMetricResponse, PeerMetrics};\n\n/// Reach out to another node with the specified address\npub async fn dial_other_peer(mut p2p_client: Client, to_dial: \u0026Multiaddr) {\n    p2p_client.dial(to_dial).await.expect(\"Dial to succeed.\");\n    info!(\"Dialed {:?}\", to_dial);\n}\n\n/// Respond to a RequestArtifact event by getting the artifact\n/// based on the provided artifact type and hash.\npub async fn handle_request_artifact(\n    mut p2p_client: Client,\n    artifact_storage: ArtifactStorage,\n    artifact_type: \u0026ArtifactType,\n    artifact_id: \u0026str,\n    channel: ResponseChannel\u003cArtifactResponse\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n    debug!(\n        \"Handling request artifact: {:?}={:?}\",\n        artifact_type, artifact_id\n    );\n    let content = match artifact_type {\n        ArtifactType::Artifact =\u003e get_artifact(artifact_storage, artifact_id)?,\n    };\n\n    p2p_client.respond_artifact(content, channel).await\n}\n\n//Respond to the IdleMetricRequest event\npub async fn handle_request_idle_metric(\n    mut p2p_client: Client,\n    channel: ResponseChannel\u003cIdleMetricResponse\u003e,\n) -\u003e anyhow::Result\u003c()\u003e {\n    let metric = artifact_service::handlers::get_quality_metric();\n    let peer_metrics: PeerMetrics = PeerMetrics {\n        idle_metric: metric.to_le_bytes(),\n    };\n    p2p_client.respond_idle_metric(peer_metrics, channel).await\n}\n\n/// Get the artifact with the provided hash from the artifact manager.\nfn get_artifact(artifact_storage: ArtifactStorage, artifact_id: \u0026str) -\u003e anyhow::Result\u003cVec\u003cu8\u003e\u003e {\n    artifact_service::handlers::get_artifact_locally(\u0026artifact_storage, artifact_id)\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","pyrsia_node","src","network.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod handlers;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","artifact_service","handlers.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::artifact_service::service::{Hash, HashAlgorithm};\nuse crate::artifact_service::storage::ArtifactStorage;\nuse crate::cli_commands::config::get_config;\nuse crate::network::client::{ArtifactType, Client};\nuse crate::transparency_log::log::TransparencyLog;\nuse anyhow::{bail, Context};\nuse byte_unit::Byte;\nuse futures::lock::Mutex;\nuse libp2p::PeerId;\nuse log::{debug, info};\nuse multihash::Hasher;\nuse std::collections::HashMap;\nuse std::fs::File;\nuse std::io::{BufReader, Read};\nuse std::str;\nuse std::sync::Arc;\nuse sysinfo::{NetworkExt, ProcessExt, System, SystemExt};\n\n//TODO: read from CLI config file\npub const ALLOCATED_SPACE_FOR_ARTIFACTS: \u0026str = \"10.84 GB\";\n\n//peer metric constants\nconst CPU_STRESS_WEIGHT: f64 = 2_f64;\nconst NETWORK_STRESS_WEIGHT: f64 = 0.001_f64;\nconst DISK_STRESS_WEIGHT: f64 = 0.001_f64;\n\n//This structure is used as the entries to the quality metrics vector\n//#[derive(Debug, Clone, Copy)]\n\n//get_artifact: given artifact_hash(artifactName) pulls artifact for  artifact_manager and\n//              returns read object to read the bytes of artifact\npub async fn get_artifact(\n    transparency_log: Arc\u003cMutex\u003cTransparencyLog\u003e\u003e,\n    p2p_client: Client,\n    artifact_storage: \u0026ArtifactStorage,\n    namespace_specific_id: \u0026str,\n) -\u003e anyhow::Result\u003cVec\u003cu8\u003e\u003e {\n    let artifact_id = transparency_log\n        .lock()\n        .await\n        .get_artifact(namespace_specific_id)?;\n\n    let blob_content = match get_artifact_locally(artifact_storage, \u0026artifact_id) {\n        Ok(blob_content) =\u003e Ok(blob_content),\n        Err(_) =\u003e get_artifact_from_peers(p2p_client, artifact_storage, \u0026artifact_id).await,\n    }?;\n\n    let mut sha256 = multihash::Sha2_256::default();\n    sha256.update(\u0026blob_content);\n    let calculated_hash = hex::encode(sha256.finalize());\n    transparency_log\n        .lock()\n        .await\n        .verify_artifact(namespace_specific_id, \u0026calculated_hash)?;\n\n    Ok(blob_content)\n}\n\npub fn get_artifact_locally(\n    artifact_storage: \u0026ArtifactStorage,\n    artifact_id: \u0026str,\n) -\u003e Result\u003cVec\u003cu8\u003e, anyhow::Error\u003e {\n    let decoded_hash = hex::decode(artifact_id)?;\n    let hash: Hash = Hash::new(HashAlgorithm::SHA256, \u0026decoded_hash)?;\n    let result = artifact_storage.pull_artifact(\u0026hash)?;\n    let mut buf_reader: BufReader\u003cFile\u003e = BufReader::new(result);\n    let mut blob_content = Vec::new();\n    buf_reader.read_to_end(\u0026mut blob_content)?;\n    Ok(blob_content)\n}\n\nasync fn get_artifact_from_peers(\n    mut p2p_client: Client,\n    artifact_storage: \u0026ArtifactStorage,\n    artifact_id: \u0026str,\n) -\u003e Result\u003cVec\u003cu8\u003e, anyhow::Error\u003e {\n    let providers = p2p_client\n        .list_providers(ArtifactType::Artifact, artifact_id.into())\n        .await?;\n\n    match p2p_client.get_idle_peer(providers).await? {\n        Some(peer) =\u003e {\n            get_artifact_from_peer(p2p_client, artifact_storage, \u0026peer, artifact_id).await\n        }\n        None =\u003e bail!(\n            \"Artifact with id {} is not available on the p2p network.\",\n            artifact_id\n        ),\n    }\n}\n\nasync fn get_artifact_from_peer(\n    mut p2p_client: Client,\n    artifact_storage: \u0026ArtifactStorage,\n    peer_id: \u0026PeerId,\n    artifact_id: \u0026str,\n) -\u003e Result\u003cVec\u003cu8\u003e, anyhow::Error\u003e {\n    let artifact = p2p_client\n        .request_artifact(peer_id, ArtifactType::Artifact, artifact_id.into())\n        .await?;\n\n    let decoded_hash = hex::decode(artifact_id)?;\n    let hash: Hash = Hash::new(HashAlgorithm::SHA256, \u0026decoded_hash)?;\n    let cursor = Box::new(std::io::Cursor::new(artifact));\n    put_artifact(artifact_storage, \u0026hash, cursor)?;\n    get_artifact_locally(artifact_storage, artifact_id)\n}\n\n//put_artifact: given artifact_hash(artifactName) \u0026 artifact_path push artifact to artifact_manager\n//              and returns the boolean as true or false if it was able to create or not\npub fn put_artifact(\n    artifact_storage: \u0026ArtifactStorage,\n    artifact_hash: \u0026Hash,\n    art_reader: Box\u003cdyn Read\u003e,\n) -\u003e Result\u003c(), anyhow::Error\u003e {\n    info!(\"put_artifact hash: {}\", artifact_hash);\n    let mut buf_reader = BufReader::new(art_reader);\n    artifact_storage\n        .push_artifact(\u0026mut buf_reader, artifact_hash)\n        .context(\"Error from put_artifact\")\n}\n\npub fn get_arts_summary(\n    artifact_storage: \u0026ArtifactStorage,\n) -\u003e Result\u003cHashMap\u003cString, usize\u003e, anyhow::Error\u003e {\n    artifact_storage\n        .artifacts_count_bydir()\n        .context(\"Error while getting artifacts count\")\n}\n\npub fn get_space_available(artifact_storage: \u0026ArtifactStorage) -\u003e Result\u003cu64, anyhow::Error\u003e {\n    let disk_used_bytes = artifact_storage.space_used()?;\n\n    let mut available_space: u64 = 0;\n    let cli_config = get_config().context(\"Error getting cli config file\")?;\n\n    let total_allocated_size: u64 = Byte::from_str(cli_config.disk_allocated)\n        .unwrap()\n        .get_bytes();\n\n    if total_allocated_size \u003e disk_used_bytes {\n        available_space = total_allocated_size - disk_used_bytes;\n    }\n    Ok(available_space)\n}\n\npub fn disk_usage(artifact_storage: \u0026ArtifactStorage) -\u003e Result\u003cf64, anyhow::Error\u003e {\n    let disk_used_bytes = artifact_storage.space_used()?;\n    let cli_config = get_config().context(\"Error getting cli config file\")?;\n    let total_allocated_size: u64 = Byte::from_str(cli_config.disk_allocated)\n        .unwrap()\n        .get_bytes();\n    let mut disk_usage: f64 = 0.0;\n    debug!(\"disk_used: {}\", disk_used_bytes);\n    debug!(\"total_allocated_size: {}\", total_allocated_size);\n\n    if total_allocated_size \u003e disk_used_bytes {\n        disk_usage = (disk_used_bytes as f64 / total_allocated_size as f64) * 100_f64;\n    }\n    Ok(disk_usage)\n}\n\n/***************************************************\n * Peer Quality Metrics\n ***************************************************/\n// Get the local stress metric to advertise to peers\npub fn get_quality_metric() -\u003e f64 {\n    let mut qm = get_cpu_stress() * CPU_STRESS_WEIGHT;\n    qm += get_network_stress() * NETWORK_STRESS_WEIGHT;\n    qm + get_disk_stress() * DISK_STRESS_WEIGHT\n}\n\n// This function gets the current CPU load on the system.\nfn get_cpu_stress() -\u003e f64 {\n    let sys = System::new_all();\n    let load_avg = sys.load_average();\n    load_avg.one //using the average over the last 1 minute\n}\n\n//This function gets the current network load on the system\nfn get_network_stress() -\u003e f64 {\n    let mut sys = System::new_all();\n    sys.refresh_networks_list();\n    let networks = sys.networks();\n\n    let mut packets_in = 0;\n    let mut packets_out = 0;\n    for (_interface_name, network) in networks {\n        packets_in += network.received();\n        packets_out += network.transmitted();\n    }\n    (packets_in as f64) + (packets_out as f64)\n    //TODO: add network card capabilities to the metric. cards with \u003e network capacity should get a lower stress number.\n}\n\nfn get_disk_stress() -\u003e f64 {\n    let sys = System::new_all();\n    // Sum up the disk usage measured as total read and writes per process:\n    let mut total_usage = 0_u64;\n    for process in sys.processes().values() {\n        let usage = process.disk_usage();\n        total_usage = total_usage + usage.total_written_bytes + usage.total_read_bytes;\n    }\n    total_usage as f64\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::network::client::command::Command;\n    use crate::network::idle_metric_protocol::PeerMetrics;\n    use crate::util::test_util;\n    use anyhow::Context;\n    use assay::assay;\n    use futures::channel::mpsc;\n    use futures::executor;\n    use futures::prelude::*;\n    use libp2p::identity::Keypair;\n    use sha2::{Digest, Sha256};\n    use std::collections::HashSet;\n    use std::env;\n    use std::fs::File;\n    use std::path::PathBuf;\n\n    const VALID_ARTIFACT_HASH: [u8; 32] = [\n        0x86, 0x5c, 0x8d, 0x98, 0x8b, 0xe4, 0x66, 0x9f, 0x3e, 0x48, 0xf7, 0x3b, 0x98, 0xf9, 0xbc,\n        0x25, 0x7, 0xbe, 0x2, 0x46, 0xea, 0x35, 0xe0, 0x9, 0x8c, 0xf6, 0x5, 0x4d, 0x36, 0x44, 0xc1,\n        0x4f,\n    ];\n    const CPU_THREADS: usize = 200;\n    const NETWORK_THREADS: usize = 10;\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-node\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    #[tokio::test]\n    async fn test_put_and_get_artifact() {\n        let transparency_log = Arc::new(Mutex::new(TransparencyLog::new()));\n        let artifact_storage = ArtifactStorage::new()?;\n\n        let (sender, _) = mpsc::channel(1);\n        let p2p_client = Client {\n            sender,\n            local_peer_id: Keypair::generate_ed25519().public().to_peer_id(),\n        };\n\n        let artifact_id = \"an_artifact_id\";\n        transparency_log\n            .lock()\n            .await\n            .add_artifact(artifact_id, \u0026hex::encode(VALID_ARTIFACT_HASH))?;\n\n        let hash = Hash::new(HashAlgorithm::SHA256, \u0026VALID_ARTIFACT_HASH)?;\n        //put the artifact\n        put_artifact(\u0026artifact_storage, \u0026hash, Box::new(get_file_reader()?))\n            .context(\"Error from put_artifact\")?;\n\n        // pull artifact\n        let future = async {\n            get_artifact(\n                transparency_log,\n                p2p_client,\n                \u0026artifact_storage,\n                \u0026artifact_id,\n            )\n            .await\n            .context(\"Error from get_artifact\")\n        };\n        let file = executor::block_on(future)?;\n\n        //validate pulled artifact with the actual data\n        let mut s = String::new();\n        get_file_reader()?.read_to_string(\u0026mut s)?;\n\n        let s1 = match str::from_utf8(file.as_slice()) {\n            Ok(v) =\u003e v,\n            Err(e) =\u003e panic!(\"Invalid UTF-8 sequence: {}\", e),\n        };\n        assert_eq!(s, s1);\n    }\n\n    #[assay(\n        env = [\n            (\"PYRSIA_ARTIFACT_PATH\", \"PyrsiaTest\"),\n            (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    #[tokio::test]\n    async fn test_get_from_peers() {\n        let artifact_storage = ArtifactStorage::new()?;\n\n        let peer_id = Keypair::generate_ed25519().public().to_peer_id();\n\n        let (sender, mut receiver) = mpsc::channel(1);\n\n        tokio::spawn(async move {\n            loop {\n                match receiver.next().await {\n                    Some(Command::ListProviders { artifact_type: _artifact_type, artifact_hash: _artifact_hash, sender }) =\u003e {\n                        let mut set = HashSet::new();\n                        set.insert(peer_id);\n                        let _ = sender.send(set);\n                    },\n                    Some(Command::RequestIdleMetric { peer: _peer, sender }) =\u003e {\n                        let _ = sender.send(Ok(PeerMetrics {\n                            idle_metric: (0.1_f64).to_le_bytes()\n                        }));\n                    },\n                    Some(Command::RequestArtifact { artifact_type: _artifact_type, artifact_hash: _artifact_hash, peer: _peer, sender }) =\u003e {\n                        let _ = sender.send(Ok(b\"RANDOM\".to_vec()));\n                    },\n                    _ =\u003e panic!(\"Command must match Command::ListProviders, Command::RequestIdleMetric, Command::RequestArtifact\"),\n                }\n            }\n        });\n\n        let p2p_client = Client {\n            sender,\n            local_peer_id: peer_id,\n        };\n\n        let mut hasher = Sha256::new();\n        hasher.update(b\"RANDOM\");\n        let hash_bytes = hasher.finalize();\n        let artifact_id = hex::encode(hash_bytes);\n\n        let result = executor::block_on(async {\n            get_artifact_from_peers(p2p_client, \u0026artifact_storage, \u0026artifact_id).await\n        });\n        assert!(result.is_ok());\n    }\n\n    #[assay(\n        env = [\n            (\"PYRSIA_ARTIFACT_PATH\", \"PyrsiaTest\"),\n            (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    #[tokio::test]\n    async fn test_get_from_peers_with_no_providers() {\n        let artifact_storage = ArtifactStorage::new()?;\n\n        let peer_id = Keypair::generate_ed25519().public().to_peer_id();\n\n        let (sender, mut receiver) = mpsc::channel(1);\n\n        tokio::spawn(async move {\n            futures::select! {\n                command = receiver.next() =\u003e match command {\n                    Some(Command::ListProviders { artifact_type: _artifact_type, artifact_hash: _artifact_hash, sender }) =\u003e {\n                        let _ = sender.send(Default::default());\n                    },\n                    _ =\u003e panic!(\"Command must match Command::ListProviders\"),\n                }\n            }\n        });\n\n        let p2p_client = Client {\n            sender,\n            local_peer_id: peer_id,\n        };\n\n        let mut hasher = Sha256::new();\n        hasher.update(b\"RANDOM\");\n        let hash_bytes = hasher.finalize();\n        let artifact_id = hex::encode(hash_bytes);\n\n        let result = executor::block_on(async {\n            get_artifact_from_peers(p2p_client, \u0026artifact_storage, \u0026artifact_id).await\n        });\n        assert!(result.is_err());\n    }\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"PyrsiaTest\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    fn test_disk_usage() {\n        let artifact_storage = ArtifactStorage::new()?;\n\n        let usage_pct_before = disk_usage(\u0026artifact_storage).context(\"Error from disk_usage\")?;\n\n        create_artifact(\u0026artifact_storage).context(\"Error creating artifact\")?;\n\n        let usage_pct_after = disk_usage(\u0026artifact_storage).context(\"Error from disk_usage\")?;\n        assert!(usage_pct_before \u003c usage_pct_after);\n    }\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"PyrsiaTest\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    fn test_get_space_available() {\n        let artifact_storage = ArtifactStorage::new()?;\n\n        let space_available_before =\n            get_space_available(\u0026artifact_storage).context(\"Error from get_space_available\")?;\n\n        create_artifact(\u0026artifact_storage).context(\"Error creating artifact\")?;\n\n        let space_available_after =\n            get_space_available(\u0026artifact_storage).context(\"Error from get_space_available\")?;\n        debug!(\n            \"Before: {}; After: {}\",\n            space_available_before, space_available_after\n        );\n        assert!(space_available_after \u003c space_available_before);\n    }\n\n    fn get_file_reader() -\u003e Result\u003cFile, anyhow::Error\u003e {\n        // test artifact file in resources/test dir\n        let mut curr_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n        curr_dir.push(\"tests/resources/artifact_test.json\");\n\n        let path = String::from(curr_dir.to_string_lossy());\n        let reader = File::open(path.as_str()).unwrap();\n        Ok(reader)\n    }\n\n    fn create_artifact(artifact_storage: \u0026ArtifactStorage) -\u003e Result\u003c(), anyhow::Error\u003e {\n        let hash = Hash::new(HashAlgorithm::SHA256, \u0026VALID_ARTIFACT_HASH)?;\n        artifact_storage\n            .push_artifact(\u0026mut get_file_reader()?, \u0026hash)\n            .context(\"Error while pushing artifact\")\n    }\n\n    #[test]\n    fn cpu_load_test() {\n        use std::sync::atomic::{AtomicBool, Ordering};\n        use std::sync::Arc;\n        use std::thread;\n        use std::time::Duration;\n\n        let loading = Arc::new(AtomicBool::new(true));\n\n        //first measure of CPU for benchmark\n        let qm = get_cpu_stress() * CPU_STRESS_WEIGHT;\n        assert_ne!(0_f64, qm); //zero should never be returned here\n\n        //set CPU on fire to measure stress\n        let mut threads = vec![];\n        for _i in 0..CPU_THREADS {\n            threads.push(thread::spawn({\n                let mut cpu_fire = 0;\n                let loading_test = loading.clone();\n                move || {\n                    while loading_test.load(Ordering::Relaxed) {\n                        cpu_fire = cpu_fire + 1;\n                    }\n                }\n            }));\n        }\n\n        thread::sleep(Duration::from_millis(200)); //let cpu spin up\n\n        //second measure of CPU\n        let qm2 = get_cpu_stress() * CPU_STRESS_WEIGHT;\n        assert!(qm2 \u003e= qm);\n        loading.store(false, Ordering::Relaxed); //kill threads\n\n        //wait for threads\n        for thread in threads {\n            thread.join().unwrap();\n        }\n        //we could add another measure of CPU did no think it was that important\n    }\n\n    #[test]\n    fn network_load_test() {\n        use std::net::UdpSocket;\n        use std::sync::atomic::{AtomicBool, Ordering};\n        use std::sync::Arc;\n        use std::thread;\n\n        let loading = Arc::new(AtomicBool::new(true));\n\n        //fist measure of network for benchmark\n        let qm = get_network_stress() * NETWORK_STRESS_WEIGHT;\n\n        //shotgun the network with packets\n        let mut threads = vec![];\n        for i in 0..NETWORK_THREADS {\n            threads.push(thread::spawn({\n                let address: String = format_args!(\"127.0.0.1:3425{i}\").to_string();\n                let socket = UdpSocket::bind(address).expect(\"couldn't bind to address\");\n                let loading_test = loading.clone();\n                move || {\n                    while loading_test.load(Ordering::Relaxed) {\n                        socket\n                            .send_to(\u0026[0; 10], \"127.0.0.1:4242\")\n                            .expect(\"couldn't send data\");\n                    }\n                }\n            }));\n        }\n\n        let qm2 = get_network_stress() * NETWORK_STRESS_WEIGHT;\n        assert!(qm2 \u003e qm);\n        loading.store(false, Ordering::Relaxed); //kill threads\n\n        //wait for threads\n        for thread in threads {\n            thread.join().unwrap();\n        }\n        //we could add another measure of network did no think it was that important\n    }\n\n    #[test]\n    fn disk_load_test() {\n        use std::fs;\n        use std::fs::OpenOptions;\n        use std::io::Write;\n        use std::sync::atomic::{AtomicBool, Ordering};\n        use std::sync::Arc;\n        use std::thread;\n        use std::time::Duration;\n\n        let loading = Arc::new(AtomicBool::new(true));\n        let test_file = \"pyrsia_test.txt\";\n\n        // fist measure of network for benchmark\n        let qm = get_disk_stress() * DISK_STRESS_WEIGHT;\n\n        // write some data\n        let write_thread = thread::spawn({\n            let file_data = \"Some test data for the file!\\n\";\n            let except_str = format!(\"Unable to open file {}\", test_file).to_string();\n            let mut f = OpenOptions::new()\n                .append(true)\n                .create(true)\n                .open(test_file)\n                .expect(\u0026except_str);\n            let loading_test = loading.clone();\n            move || {\n                while loading_test.load(Ordering::Relaxed) {\n                    f.write_all(file_data.as_bytes())\n                        .expect(\"Unable to write data\");\n                }\n                drop(f);\n            }\n        });\n\n        thread::sleep(Duration::from_millis(400)); //let writes happen\n\n        // second measure of network\n        let qm2 = get_disk_stress() * DISK_STRESS_WEIGHT;\n        loading.store(false, Ordering::Relaxed); //kill thread\n        write_thread.join().unwrap();\n        fs::remove_file(test_file).unwrap_or_else(|why| {\n            assert!(false, \"{:?}\", why.kind());\n        });\n        assert!(qm2 \u003e qm);\n\n        //we could add another measure of disks did no think it was that important\n    }\n\n    #[test]\n    fn quality_metric_test() {\n        let quality_metric = get_quality_metric();\n        assert!(quality_metric != 0_f64);\n    }\n}\n","traces":[{"line":45,"address":[6153232],"length":1,"stats":{"Line":0},"fn_name":"get_artifact"},{"line":51,"address":[5351194,5351244,5351078,5350862,5351006],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[5351576,5351491,5351174,5351552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[5351583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":[5352012,5352055,5351746,5350893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[6154922,6153408],"length":1,"stats":{"Line":0},"fn_name":"get_artifact_locally"},{"line":63,"address":[6153647,6153480],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[6153937,6153812,6153969,6153732,6153605],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[6154258,6154025,6153915,6154290,6154140],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[6154219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[6154343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[6154812,6154419,6154484,6154604,6154763],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[6154676],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[6154944],"length":1,"stats":{"Line":0},"fn_name":"get_artifact_from_peers"},{"line":77,"address":[5353532,5353753,5353337,5353104,5353222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":78,"address":[5353465,5352791,5353239,5352983,5352850,5353172],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[5353777,5353737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[5353662,5354608,5352938,5352865,5353878,5353839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[5354651],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[5354736,5352880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[5355284,5354615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[6155104],"length":1,"stats":{"Line":0},"fn_name":"get_artifact_from_peer"},{"line":98,"address":[5356126,5356238,5356520,5356001,5356372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[5355862,5356076,5356302,5355809,5356143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[5356544,5356504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[5356617,5356665,5356475,5356785,5356857],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[5357193,5356748,5356913,5356993,5357153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[5357086,5357461],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[5357606,5357469,5357662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[5357567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[6155844,6155280],"length":1,"stats":{"Line":0},"fn_name":"put_artifact"},{"line":116,"address":[6155571,6155414,6155315,6155487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[6155530],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[6155735],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[6155722],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[6155872],"length":1,"stats":{"Line":0},"fn_name":"get_arts_summary"},{"line":126,"address":[6155891],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[6155952,6156870],"length":1,"stats":{"Line":0},"fn_name":"get_space_available"},{"line":132,"address":[6155967,6156149],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[6156125],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[6156537,6156236,6156134],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[6156474,6156620,6156690],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[6156736,6156811],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[6156786,6156813],"length":1,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[6156741],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[6158522,6156976],"length":1,"stats":{"Line":0},"fn_name":"disk_usage"},{"line":148,"address":[6157180,6156991],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[6157165,6157577,6157270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[6157660,6157733,6157514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[6157774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[6158009,6157786,6157910],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[6158253,6157968,6158335,6158171],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[6158311,6158693],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[6158600],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[6158557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[6158784],"length":1,"stats":{"Line":1},"fn_name":"get_quality_metric"},{"line":168,"address":[6158788],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[6158823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":[6158864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[6159033,6158928],"length":1,"stats":{"Line":1},"fn_name":"get_cpu_stress"},{"line":175,"address":[6158935],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[6158946],"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":[6158970],"length":1,"stats":{"Line":1},"fn_name":null},{"line":181,"address":[6159072,6159641],"length":1,"stats":{"Line":1},"fn_name":"get_network_stress"},{"line":182,"address":[6159079],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[6159090],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[6159170,6159106],"length":1,"stats":{"Line":2},"fn_name":null},{"line":186,"address":[6159178],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[6159190],"length":1,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[6159606,6159202,6159424],"length":1,"stats":{"Line":3},"fn_name":null},{"line":189,"address":[6159461,6159536],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[6159520,6159573,6159611],"length":1,"stats":{"Line":2},"fn_name":null},{"line":192,"address":[6159327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[6160137,6159680],"length":1,"stats":{"Line":1},"fn_name":"get_disk_stress"},{"line":197,"address":[6159687],"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":[6159698],"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":[6159809,6159710,6159969,6160102],"length":1,"stats":{"Line":4},"fn_name":null},{"line":201,"address":[6159985],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[6160107,6160004],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[6159904],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[5991056,5996301,5997209,5997200,5991024,5996332,5991029,5991077,5991371,5991317],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":238,"address":[5996240],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[8358528],"length":1,"stats":{"Line":1},"fn_name":"test_put_and_get_artifact"},{"line":241,"address":[5991451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[5991603,5991683,5991458,5991550],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[5991596,5991729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[5991884,5991948,5991824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":250,"address":[5992302],"length":1,"stats":{"Line":0},"fn_name":null},{"line":251,"address":[5992329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":253,"address":[5993054,5992971,5992799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[5993982,5992948,5993224,5993097,5993428,5993580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[5996628,5993724,5996702,5996787,5996352,5996395],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}"},{"line":261,"address":[5996448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[5996483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[5996573],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[5996580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[5994359,5994276,5994130],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[5994269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[5994594,5994386,5994856,5994466],"length":1,"stats":{"Line":0},"fn_name":null},{"line":275,"address":[5995304],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[5995396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[5995538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":279,"address":[5995711,5995683,5995452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":282,"address":[5997269,5998041,5998632,5997311,5997264,5998369,5997560,5997518,5998150,5998416,5997296,6003705,6003696,5998536,5998394,5998459,5997948,5998269,5997629,6000288],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":287,"address":[5998362],"length":1,"stats":{"Line":0},"fn_name":null},{"line":290,"address":[5998500],"length":1,"stats":{"Line":1},"fn_name":null},{"line":291,"address":[5998791,5998677,5998524,5998726,5998615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":293,"address":[5998704,5998875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":295,"address":[5999056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":297,"address":[6000549,5999342,5999127,6000613,6000433,6002796,6000400],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}"},{"line":298,"address":[6000475,6002774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":299,"address":[6000648,6000562,6000764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[6001084],"length":1,"stats":{"Line":0},"fn_name":null},{"line":301,"address":[6001153],"length":1,"stats":{"Line":0},"fn_name":null},{"line":302,"address":[6002100],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[6002384,6002244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":305,"address":[6001366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[6001467,6001751,6001618],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[6001491,6001594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":310,"address":[6001175],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[6001316,6002022,6001872],"length":1,"stats":{"Line":0},"fn_name":null},{"line":313,"address":[6001503,6001042],"length":1,"stats":{"Line":0},"fn_name":null},{"line":323,"address":[5999622],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[5999629],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[5999692],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[5999831],"length":1,"stats":{"Line":0},"fn_name":null},{"line":328,"address":[6003116,6002816,6002859,6003044,5999886,6003314],"length":1,"stats":{"Line":0},"fn_name":"{async_block#1}"},{"line":329,"address":[6002912,6003294,6003341,6003065,6003191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[6000213,6000138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":334,"address":[6004444,6009049,6003792,6004014,6004646,6004056,6004537,6004125,6003807,6004912,6004955,6005128,6003765,6006707,6004890,6004765,6004865,6003760,6009040,6005032],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":339,"address":[6004858],"length":1,"stats":{"Line":0},"fn_name":null},{"line":342,"address":[6004996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":343,"address":[6005222,6005020,6005287,6005173,6005111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[6005371,6005200],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[6005552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":349,"address":[6008077,6005761,6007022,6006950,6006849,6005623,6006816],"length":1,"stats":{"Line":0},"fn_name":"{async_block#0}"},{"line":350,"address":[6007174,6008040,6007602,6007100,6007398,6007841,6006971,6006899],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[6007322,6006923,6007424,6007097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[6007477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":353,"address":[6007665,6007541,6007771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":355,"address":[6007438,6007576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[6006041],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[6006048],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[6006111],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[6006250],"length":1,"stats":{"Line":0},"fn_name":null},{"line":370,"address":[6008460,6008203,6008160,6008658,6008388,6006305],"length":1,"stats":{"Line":0},"fn_name":"{async_block#1}"},{"line":371,"address":[6008409,6008535,6008638,6008256,6008685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":373,"address":[6006557,6006632],"length":1,"stats":{"Line":0},"fn_name":null},{"line":376,"address":[6009845,6010103,6009840,6010157,6009887,6009872,6011486,6011536,6011517,6011545],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":381,"address":[6011447],"length":1,"stats":{"Line":0},"fn_name":null},{"line":383,"address":[8361888],"length":1,"stats":{"Line":1},"fn_name":"test_disk_usage"},{"line":384,"address":[6010229,6010339,6010419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":386,"address":[6010316,6010771,6010842,6010481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":388,"address":[6010759,6010874,6011053,6010982],"length":1,"stats":{"Line":0},"fn_name":null},{"line":390,"address":[6011090,6010965,6011420,6011351],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[6011336,6011454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":394,"address":[6011863,6011600,6011917,6013792,6011632,6013801,6013766,6011647,6013735,6011605],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":399,"address":[6013696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":401,"address":[8362976],"length":1,"stats":{"Line":1},"fn_name":"test_get_space_available"},{"line":402,"address":[6011989,6012179,6012099],"length":1,"stats":{"Line":0},"fn_name":null},{"line":404,"address":[6012076,6012529,6012241,6012612],"length":1,"stats":{"Line":0},"fn_name":null},{"line":407,"address":[6012856,6012647,6012773,6012514],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[6012899,6012750,6013255,6013184],"length":1,"stats":{"Line":0},"fn_name":null},{"line":411,"address":[6013146,6013286,6013368,6013460],"length":1,"stats":{"Line":0},"fn_name":null},{"line":415,"address":[6013703,6013426],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[8357778,8357392],"length":1,"stats":{"Line":0},"fn_name":"get_file_reader"},{"line":420,"address":[8357399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[8357422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[8357455,8357528],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[8357564,8357660],"length":1,"stats":{"Line":0},"fn_name":null},{"line":425,"address":[8357737],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[8357824,8358213],"length":1,"stats":{"Line":0},"fn_name":"create_artifact"},{"line":429,"address":[8357844,8357998],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[8358385,8358448,8358269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[8357981,8358281,8358056,8358228,8358165],"length":1,"stats":{"Line":0},"fn_name":null},{"line":436,"address":[6013856,6013861],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":442,"address":[8364071],"length":1,"stats":{"Line":1},"fn_name":null},{"line":445,"address":[8364129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":446,"address":[8364319,8364169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":449,"address":[8364302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":450,"address":[8364604,8364506,8364368],"length":1,"stats":{"Line":3},"fn_name":null},{"line":451,"address":[8364684],"length":1,"stats":{"Line":1},"fn_name":null},{"line":452,"address":[8364620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":453,"address":[8364631],"length":1,"stats":{"Line":1},"fn_name":null},{"line":454,"address":[6014055,6013888],"length":1,"stats":{"Line":199},"fn_name":"{closure#0}"},{"line":455,"address":[6014021,6013980,6013901],"length":1,"stats":{"Line":398},"fn_name":null},{"line":456,"address":[6014023,6013998],"length":1,"stats":{"Line":2},"fn_name":null},{"line":462,"address":[8364585,8364751],"length":1,"stats":{"Line":2},"fn_name":null},{"line":465,"address":[8364762],"length":1,"stats":{"Line":1},"fn_name":null},{"line":466,"address":[8364802,8364841],"length":1,"stats":{"Line":1},"fn_name":null},{"line":467,"address":[8364879,8364820],"length":1,"stats":{"Line":2},"fn_name":null},{"line":470,"address":[8365254,8364904],"length":1,"stats":{"Line":1},"fn_name":null},{"line":471,"address":[8365169],"length":1,"stats":{"Line":1},"fn_name":null},{"line":477,"address":[6014080,6014085],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":483,"address":[8365367],"length":1,"stats":{"Line":1},"fn_name":null},{"line":486,"address":[8365428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":489,"address":[8365488],"length":1,"stats":{"Line":1},"fn_name":null},{"line":490,"address":[8365674,8365536,8365764],"length":1,"stats":{"Line":3},"fn_name":null},{"line":491,"address":[8366116,8366203],"length":1,"stats":{"Line":2},"fn_name":null},{"line":492,"address":[8365780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":493,"address":[8365901],"length":1,"stats":{"Line":1},"fn_name":null},{"line":494,"address":[8366057],"length":1,"stats":{"Line":1},"fn_name":null},{"line":495,"address":[6014350,6014112],"length":1,"stats":{"Line":8},"fn_name":"{closure#0}"},{"line":496,"address":[6014207,6014125],"length":1,"stats":{"Line":9},"fn_name":null},{"line":497,"address":[6014228],"length":1,"stats":{"Line":2},"fn_name":null},{"line":505,"address":[8365748,8366227],"length":1,"stats":{"Line":2},"fn_name":null},{"line":506,"address":[8366248,8366285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":507,"address":[8366261,8366322],"length":1,"stats":{"Line":2},"fn_name":null},{"line":510,"address":[8366697,8366347],"length":1,"stats":{"Line":1},"fn_name":null},{"line":511,"address":[8366612],"length":1,"stats":{"Line":1},"fn_name":null},{"line":517,"address":[6014368,6014373],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":526,"address":[8366807],"length":1,"stats":{"Line":1},"fn_name":null},{"line":527,"address":[8366876],"length":1,"stats":{"Line":1},"fn_name":null},{"line":530,"address":[8366903],"length":1,"stats":{"Line":1},"fn_name":null},{"line":533,"address":[8367847],"length":1,"stats":{"Line":1},"fn_name":null},{"line":534,"address":[8366958],"length":1,"stats":{"Line":1},"fn_name":null},{"line":535,"address":[8367077,8366985],"length":1,"stats":{"Line":2},"fn_name":null},{"line":536,"address":[8367466,8367651,8367274,8367568,8367358],"length":1,"stats":{"Line":5},"fn_name":null},{"line":539,"address":[8367525,8367450],"length":1,"stats":{"Line":2},"fn_name":null},{"line":540,"address":[8367610,8367541,8367658,8367690],"length":1,"stats":{"Line":2},"fn_name":null},{"line":541,"address":[8367714,8367666],"length":1,"stats":{"Line":2},"fn_name":null},{"line":542,"address":[6014400,6014687],"length":1,"stats":{"Line":2},"fn_name":"{closure#0}"},{"line":543,"address":[6014502,6014409],"length":1,"stats":{"Line":2},"fn_name":null},{"line":544,"address":[6014536,6014611],"length":1,"stats":{"Line":2},"fn_name":null},{"line":547,"address":[6014513],"length":1,"stats":{"Line":1},"fn_name":null},{"line":551,"address":[8367867],"length":1,"stats":{"Line":1},"fn_name":null},{"line":554,"address":[8367944],"length":1,"stats":{"Line":1},"fn_name":null},{"line":555,"address":[8367990],"length":1,"stats":{"Line":1},"fn_name":null},{"line":556,"address":[8368044],"length":1,"stats":{"Line":1},"fn_name":null},{"line":557,"address":[6014904,6014736],"length":1,"stats":{"Line":1},"fn_name":"{closure#1}"},{"line":558,"address":[6014836,6014753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":560,"address":[8368190,8368227],"length":1,"stats":{"Line":1},"fn_name":null},{"line":566,"address":[6014933,6014928],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":567,"address":[8368308],"length":1,"stats":{"Line":1},"fn_name":null},{"line":568,"address":[8368357,8368331],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":94,"coverable":235},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","artifact_service","service.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse anyhow::anyhow;\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest, Sha256, Sha512};\nuse std::fmt::{Display, Formatter};\nuse strum_macros::{EnumIter, EnumString};\n\n// We will provide implementations of this trait for each hash algorithm that we support.\npub trait Digester {\n    fn update_hash(\u0026mut self, input: \u0026[u8]);\n\n    fn finalize_hash(\u0026mut self, hash_buffer: \u0026mut [u8]);\n\n    fn hash_size_in_bytes(\u0026self) -\u003e usize;\n}\n\nimpl Digester for Sha256 {\n    fn update_hash(\u0026mut self, input: \u0026[u8]) {\n        self.update(input);\n    }\n\n    fn finalize_hash(\u0026mut self, hash_buffer: \u0026mut [u8]) {\n        hash_buffer.clone_from_slice(self.clone().finalize().as_slice());\n    }\n\n    fn hash_size_in_bytes(\u0026self) -\u003e usize {\n        256 / 8\n    }\n}\n\nimpl Digester for Sha512 {\n    fn update_hash(\u0026mut self, input: \u0026[u8]) {\n        self.update(input);\n    }\n\n    fn finalize_hash(\u0026mut self, hash_buffer: \u0026mut [u8]) {\n        hash_buffer.clone_from_slice(self.clone().finalize().as_slice());\n    }\n\n    fn hash_size_in_bytes(\u0026self) -\u003e usize {\n        512 / 8\n    }\n}\n\n/// The types of hash algorithms that the artifact service supports\n#[derive(EnumIter, Clone, Debug, PartialEq, EnumString, Serialize, Deserialize)]\npub enum HashAlgorithm {\n    SHA256,\n    SHA512,\n}\n\nimpl HashAlgorithm {\n    pub fn digest_factory(\u0026self) -\u003e Box\u003cdyn Digester\u003e {\n        match self {\n            HashAlgorithm::SHA256 =\u003e Box::new(Sha256::new()),\n            HashAlgorithm::SHA512 =\u003e Box::new(Sha512::new()),\n        }\n    }\n\n    /// Translate a HashAlgorithm to a string.\n    pub fn hash_algorithm_to_str(\u0026self) -\u003e \u0026'static str {\n        match self {\n            HashAlgorithm::SHA256 =\u003e \"SHA256\",\n            HashAlgorithm::SHA512 =\u003e \"SHA512\",\n        }\n    }\n\n    fn hash_length_in_bytes(\u0026self) -\u003e usize {\n        match self {\n            HashAlgorithm::SHA256 =\u003e 256 / 8,\n            HashAlgorithm::SHA512 =\u003e 512 / 8,\n        }\n    }\n}\n\nimpl Display for HashAlgorithm {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.write_str(HashAlgorithm::hash_algorithm_to_str(self))\n    }\n}\n\n#[derive(PartialEq, Debug)]\npub struct Hash {\n    pub algorithm: HashAlgorithm,\n    pub bytes: Vec\u003cu8\u003e,\n}\n\nimpl Hash {\n    pub fn new(algorithm: HashAlgorithm, bytes: \u0026[u8]) -\u003e Result\u003cSelf, anyhow::Error\u003e {\n        let expected_length: usize = algorithm.hash_length_in_bytes();\n        if bytes.len() == expected_length {\n            Ok(Hash {\n                algorithm,\n                bytes: bytes.to_vec(),\n            })\n        } else {\n            Err(anyhow!(format!(\"The hash value does not have the correct length for the algorithm. The expected length is {} bytes, but the length of the supplied hash is {}.\", expected_length, bytes.len())))\n        }\n    }\n}\n\nimpl Display for Hash {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.write_str(\u0026format!(\n            \"{}:{}\",\n            self.algorithm.hash_algorithm_to_str(),\n            hex::encode(\u0026self.bytes)\n        ))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    pub use super::*;\n    use strum::IntoEnumIterator;\n\n    const TEST_ARTIFACT_HASH_256: [u8; 32] = [\n        0x6b, 0x29, 0xf2, 0xf1, 0xe5, 0x02, 0x4c, 0x41, 0x95, 0x06, 0xe9, 0x50, 0x3e, 0x02, 0x4b,\n        0x3d, 0x8a, 0x5a, 0x08, 0xb6, 0xf6, 0xd5, 0x5b, 0x68, 0x88, 0x66, 0x79, 0x52, 0xd1, 0x04,\n        0x15, 0x54,\n    ];\n    const TEST_ARTIFACT_HASH_512: [u8; 64] = [\n        0x6b, 0x29, 0xf2, 0xf1, 0xe5, 0x02, 0x4c, 0x41, 0x95, 0x06, 0xe9, 0x50, 0x3e, 0x02, 0x4b,\n        0x3d, 0x8a, 0x5a, 0x08, 0xb6, 0xf6, 0xd5, 0x5b, 0x68, 0x88, 0x66, 0x79, 0x52, 0xd1, 0x04,\n        0x15, 0x54, 0x83, 0x74, 0x5a, 0xc0, 0x84, 0xfe, 0xf2, 0x12, 0x29, 0xd6, 0x57, 0x2c, 0xd4,\n        0x14, 0xf9, 0xb2, 0xa4, 0x82, 0x06, 0xd6, 0x47, 0x62, 0xc5, 0x26, 0x81, 0x11, 0xd1, 0xc4,\n        0x7a, 0x87, 0x4e, 0x71,\n    ];\n\n    const SHA256_HASH_ENCODED: \u0026str =\n        \"5e6009f8ce7a159884aa5e5132ce8c84fefc979f237a0bce4652f90bc77e5591\";\n    const SHA512_HASH_ENCODED: \u0026str = \"838d2542932c2545f222a4daf74e0e1dc1bd76ce5742b4e3a92aaff2e28b038adf50e0bbdfe6da50ff4fc19f8a23a77ce8fd28a38456b33d43a62b3c86978954\";\n\n    #[test]\n    pub fn test_digester_length() {\n        for algorithm in HashAlgorithm::iter() {\n            let digester = algorithm.digest_factory();\n\n            assert_eq!(\n                digester.hash_size_in_bytes(),\n                algorithm.hash_length_in_bytes()\n            );\n        }\n    }\n\n    #[test]\n    pub fn test_digester_256() {\n        let mut digester = HashAlgorithm::SHA256.digest_factory();\n        digester.update_hash(\u0026TEST_ARTIFACT_HASH_256);\n        let mut hash_buffer = [0; 32];\n        digester.finalize_hash(\u0026mut hash_buffer);\n        assert_eq!(hex::encode(hash_buffer), SHA256_HASH_ENCODED);\n    }\n\n    #[test]\n    pub fn test_digester_512() {\n        let mut digester = HashAlgorithm::SHA512.digest_factory();\n        digester.update_hash(\u0026TEST_ARTIFACT_HASH_256);\n        let mut hash_buffer = [0; 64];\n        digester.finalize_hash(\u0026mut hash_buffer);\n        assert_eq!(hex::encode(hash_buffer), SHA512_HASH_ENCODED);\n    }\n\n    #[test]\n    pub fn test_hash_new() {\n        let hash = Hash::new(HashAlgorithm::SHA256, \u0026TEST_ARTIFACT_HASH_256).unwrap();\n\n        assert_eq!(hash.algorithm, HashAlgorithm::SHA256);\n        assert_eq!(hash.bytes, TEST_ARTIFACT_HASH_256);\n    }\n\n    #[test]\n    pub fn test_hash_256_display() {\n        let hash = Hash::new(HashAlgorithm::SHA256, \u0026TEST_ARTIFACT_HASH_256).unwrap();\n        let display = format!(\"{}\", hash);\n        let to_string = format!(\n            \"{}:{}\",\n            hash.algorithm.hash_algorithm_to_str(),\n            hex::encode(hash.bytes)\n        );\n        assert_eq!(display, to_string);\n    }\n\n    #[test]\n    pub fn test_hash_512_display() {\n        let hash = Hash::new(HashAlgorithm::SHA512, \u0026TEST_ARTIFACT_HASH_512).unwrap();\n        let display = format!(\"{}\", hash);\n        let to_string = format!(\n            \"{}:{}\",\n            hash.algorithm.hash_algorithm_to_str(),\n            hex::encode(hash.bytes)\n        );\n        assert_eq!(display, to_string);\n    }\n\n    #[test]\n    pub fn hash_length_does_not_match_algorithm_test() {\n        assert!(\n            Hash::new(HashAlgorithm::SHA512, \u0026[0u8; 7]).is_err(),\n            \"A 56 bit hash value for SHA512 should be an error\"\n        )\n    }\n}\n","traces":[{"line":33,"address":[7462688],"length":1,"stats":{"Line":1},"fn_name":"update_hash"},{"line":34,"address":[7462706],"length":1,"stats":{"Line":1},"fn_name":null},{"line":37,"address":[7462720],"length":1,"stats":{"Line":1},"fn_name":"finalize_hash"},{"line":38,"address":[7462767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":41,"address":[7462864],"length":1,"stats":{"Line":1},"fn_name":"hash_size_in_bytes"},{"line":47,"address":[7462880],"length":1,"stats":{"Line":1},"fn_name":"update_hash"},{"line":48,"address":[7462898],"length":1,"stats":{"Line":1},"fn_name":null},{"line":51,"address":[7462912],"length":1,"stats":{"Line":1},"fn_name":"finalize_hash"},{"line":52,"address":[7462959],"length":1,"stats":{"Line":1},"fn_name":null},{"line":55,"address":[7463056],"length":1,"stats":{"Line":1},"fn_name":"hash_size_in_bytes"},{"line":68,"address":[6014960],"length":1,"stats":{"Line":1},"fn_name":"digest_factory"},{"line":69,"address":[6014975,6015129],"length":1,"stats":{"Line":2},"fn_name":null},{"line":70,"address":[6014988,6015235],"length":1,"stats":{"Line":2},"fn_name":null},{"line":71,"address":[6015112,6015003],"length":1,"stats":{"Line":2},"fn_name":null},{"line":76,"address":[6015280],"length":1,"stats":{"Line":1},"fn_name":"hash_algorithm_to_str"},{"line":77,"address":[6015289],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[6015302],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[6015324],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[6015360],"length":1,"stats":{"Line":1},"fn_name":"hash_length_in_bytes"},{"line":84,"address":[6015369],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[6015382],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[6015392],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[6015424],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":93,"address":[6015443],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[6015504,6016153],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":105,"address":[6015556],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[6015584,6016204],"length":1,"stats":{"Line":2},"fn_name":null},{"line":107,"address":[6015658],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[6015627],"length":1,"stats":{"Line":1},"fn_name":null},{"line":109,"address":[6015635],"length":1,"stats":{"Line":1},"fn_name":null},{"line":112,"address":[6016168,6015591,6015771],"length":1,"stats":{"Line":2},"fn_name":null},{"line":118,"address":[6016525,6016224],"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":119,"address":[6016324,6016282,6016540],"length":1,"stats":{"Line":3},"fn_name":null},{"line":121,"address":[6016257],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[6016311],"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":[5257989,5257984],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":151,"address":[6872941,6872839],"length":1,"stats":{"Line":2},"fn_name":null},{"line":152,"address":[6872954],"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":[6873174,6873072],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[6872969],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[6873064,6873010],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[6873248,6873634],"length":1,"stats":{"Line":3},"fn_name":"test_digester_256"},{"line":163,"address":[6873255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[6873277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[6873307],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[6873320],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[6873385],"length":1,"stats":{"Line":1},"fn_name":null},{"line":171,"address":[5258048,5258053],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":172,"address":[6873671],"length":1,"stats":{"Line":1},"fn_name":null},{"line":173,"address":[6873693],"length":1,"stats":{"Line":1},"fn_name":null},{"line":174,"address":[6873723],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[6873746],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[6873811],"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":[5258085,5258080],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":181,"address":[6874135],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[6874420,6874199],"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":[6874498,6874334,6874470],"length":1,"stats":{"Line":2},"fn_name":null},{"line":188,"address":[5258112,5258117],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":189,"address":[6874583],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[6874797,6874674],"length":1,"stats":{"Line":2},"fn_name":null},{"line":191,"address":[6874907,6875381,6875057],"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[6874856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[6874997],"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":[6875504,6875426,6875304],"length":1,"stats":{"Line":2},"fn_name":null},{"line":200,"address":[5258149,5258144],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":201,"address":[6875623],"length":1,"stats":{"Line":1},"fn_name":null},{"line":202,"address":[6875837,6875714],"length":1,"stats":{"Line":2},"fn_name":null},{"line":203,"address":[6875947,6876097,6876421],"length":1,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[6875896],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[6876037],"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":[6876544,6876466,6876344],"length":1,"stats":{"Line":2},"fn_name":null},{"line":212,"address":[5258176,5258181],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":213,"address":[6876789,6876778,6876716],"length":1,"stats":{"Line":2},"fn_name":null},{"line":214,"address":[6876660],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":72,"coverable":74},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","artifact_service","storage.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::artifact_service::service::{Digester, Hash, HashAlgorithm};\nuse crate::util::env_util::read_var;\nuse anyhow::{anyhow, bail, Context, Error, Result};\nuse lazy_static::lazy_static;\nuse log::{debug, error, info, warn};\nuse std::collections::HashMap;\nuse std::ffi::{OsStr, OsString};\nuse std::fs::{File, OpenOptions};\nuse std::io::{BufWriter, Read, Write};\nuse std::panic::UnwindSafe;\nuse std::path::{Path, PathBuf};\nuse strum::IntoEnumIterator;\nuse walkdir::{DirEntry, WalkDir};\n\nconst FILE_EXTENSION: \u0026str = \"file\";\n\nlazy_static! {\n    pub static ref ARTIFACTS_DIR: String = {\n        let pyrsia_artifact_path = read_var(\"PYRSIA_ARTIFACT_PATH\", \"pyrsia\");\n        let dev_mode = read_var(\"DEV_MODE\", \"off\");\n        if dev_mode.to_lowercase() == \"on\" {\n            log_static_initialization_failure(\n                \"Pyrsia Artifact directory\",\n                std::fs::create_dir_all(\u0026pyrsia_artifact_path).with_context(|| {\n                    format!(\n                        \"Failed to create artifact manager directory {:?} in dev mode\",\n                        pyrsia_artifact_path\n                    )\n                }),\n            );\n        }\n        pyrsia_artifact_path\n    };\n}\n\nfn log_static_initialization_failure\u003cT: UnwindSafe\u003e(\n    label: \u0026str,\n    result: Result\u003cT, anyhow::Error\u003e,\n) -\u003e T {\n    let panic_wrapper = std::panic::catch_unwind(|| match result {\n        Ok(unwrapped) =\u003e unwrapped,\n        Err(error) =\u003e {\n            let msg = format!(\"Error initializing {}, error is: {}\", label, error);\n            error!(\"{}\", msg);\n            panic!(\"{}\", msg)\n        }\n    });\n    match panic_wrapper {\n        Ok(normal) =\u003e normal,\n        Err(partially_unwound_panic) =\u003e {\n            error!(\"Initialization of {} panicked!\", label);\n            std::panic::resume_unwind(partially_unwound_panic)\n        }\n    }\n}\n\nfn encode_bytes_as_file_name(bytes: \u0026[u8]) -\u003e String {\n    hex::encode(bytes)\n}\n\n// The base file path (no extension on the file name) that will correspond to this hash.\n// The structure of the path is\n// repo_root_dir/hash_algorithm/hash\n// This consists of the artifact repository root directory, a directory whose name is the\n// algorithm used to compute the hash and a file name that is the hash, encoded as hex\n// (base64 is more compact, but hex is easier for troubleshooting). For example\n// pyrsia-artifacts/SHA256/680fade3184f20557aa2bbf4432386eb79836902a1e5aea1ff077e323e6cab34\n// TODO To support nodes that will store many files, we need a scheme that will start separating files by subdirectories under the hash algorithm directory based on the first n bytes of the hash value.\nfn base_file_path(hash: \u0026Hash, repo_dir: \u0026Path) -\u003e PathBuf {\n    let mut buffer: PathBuf = PathBuf::from(repo_dir);\n    buffer.push(hash.algorithm.hash_algorithm_to_str());\n    buffer.push(encode_bytes_as_file_name(\u0026hash.bytes));\n    buffer\n}\n\n// It is possible, though unlikely, for SHA512, SHA3_512 and BLAKE3 to generate the same\n// hash for different content. Separating files by algorithm avoids this type of collision.\n// This function ensures that there is a directory under the repository root for each one of\n// the supported hash algorithms.\nfn ensure_directories_for_hash_algorithms_exist(\n    repository_path: \u0026Path,\n) -\u003e Result\u003c(), anyhow::Error\u003e {\n    let mut path_buf = PathBuf::new();\n    path_buf.push(repository_path);\n    for algorithm in HashAlgorithm::iter() {\n        ensure_subdirectory_exists(\u0026path_buf, algorithm)?;\n    }\n    Ok(())\n}\n\nfn ensure_subdirectory_exists(\n    path_buf: \u0026Path,\n    algorithm: HashAlgorithm,\n) -\u003e Result\u003c(), anyhow::Error\u003e {\n    let mut this_buf = path_buf.to_path_buf();\n    this_buf.push(algorithm.hash_algorithm_to_str());\n    info!(\n        \"Creating directory {}\",\n        this_buf\n            .as_os_str()\n            .to_str()\n            .unwrap_or(\"*** Unable to convert artifact directory path to UTF-8!\")\n    );\n    std::fs::create_dir_all(this_buf.as_os_str())\n        .with_context(|| format!(\"Error creating directory {}\", this_buf.display()))?;\n    Ok(())\n}\n\n// This is a decorator for the Write trait that allows the bytes written by the writer to be\n// used to compute a hash\nstruct WriteHashDecorator\u003c'a\u003e {\n    writer: \u0026'a mut dyn Write,\n    digester: \u0026'a mut Box\u003cdyn Digester\u003e,\n}\n\nimpl\u003c'a\u003e WriteHashDecorator\u003c'a\u003e {\n    fn new(writer: \u0026'a mut impl Write, digester: \u0026'a mut Box\u003cdyn Digester\u003e) -\u003e Self {\n        WriteHashDecorator { writer, digester }\n    }\n}\n\n// Decorator logic is supplied only for the methods that we expect to be called by io::copy\nimpl\u003c'a\u003e Write for WriteHashDecorator\u003c'a\u003e {\n    fn write(\u0026mut self, buf: \u0026[u8]) -\u003e std::io::Result\u003cusize\u003e {\n        let bytes_written = self.writer.write(buf)?;\n        self.digester.update_hash(\u0026buf[..bytes_written]);\n        Ok(bytes_written)\n    }\n\n    fn flush(\u0026mut self) -\u003e std::io::Result\u003c()\u003e {\n        self.writer.flush()\n    }\n\n    fn write_all(\u0026mut self, buf: \u0026[u8]) -\u003e std::io::Result\u003c()\u003e {\n        if self.writer.write(buf).is_ok() {\n            self.digester.update_hash(buf)\n        }\n        Ok(())\n    }\n}\n\n#[derive(Clone)]\npub struct ArtifactStorage {}\n\nimpl ArtifactStorage {\n    pub fn new() -\u003e Result\u003cArtifactStorage, anyhow::Error\u003e {\n        let absolute_path = get_repository_path()?;\n        if is_accessible_directory(\u0026absolute_path) {\n            ensure_directories_for_hash_algorithms_exist(\u0026absolute_path)?;\n\n            Ok(ArtifactStorage {})\n        } else {\n            error!(\n                \"Unable to create ArtifactManager with inaccessible directory: {}\",\n                ARTIFACTS_DIR.as_str()\n            );\n            Err(anyhow!(\n                \"Not an accessible directory: {}\",\n                ARTIFACTS_DIR.as_str()\n            ))\n        }\n    }\n\n    pub fn artifacts_count_bydir(\u0026self) -\u003e Result\u003cHashMap\u003cString, usize\u003e, Error\u003e {\n        let mut dirs_map: HashMap\u003cString, usize\u003e = HashMap::new();\n\n        let repository_path = get_repository_path()?;\n        for file in WalkDir::new(repository_path)\n            .into_iter()\n            .filter_entry(is_directory_or_artifact_file)\n            .filter_map(|file| file.ok())\n        {\n            let path = file.path().display().to_string();\n\n            let dir_1 = match path.rfind('/') {\n                Some(x) =\u003e \u0026path[0..x],\n                None =\u003e \"\",\n            };\n\n            if !dir_1.is_empty() {\n                let len = dir_1.len();\n                if let Some(x) = dir_1.rfind('/') {\n                    *dirs_map.entry(dir_1[x + 1..len].to_string()).or_insert(0) += 1;\n                }\n            }\n        }\n        Ok(dirs_map)\n    }\n\n    /// Calculate the repository size by recursively adding size of each directory inside it.\n    /// Returns the size\n    pub fn space_used(\u0026self) -\u003e Result\u003cu64, Error\u003e {\n        let repository_path = get_repository_path()?;\n        fs_extra::dir::get_size(repository_path.as_os_str())\n            .context(\"Error while calculating the size of artifact manager\")\n    }\n\n    fn file_path_for_new_artifact(\u0026self, expected_hash: \u0026Hash) -\u003e std::io::Result\u003cPathBuf\u003e {\n        let repository_path = get_repository_path()?;\n        let mut base_path: PathBuf = base_file_path(expected_hash, \u0026repository_path);\n        // for now all artifacts are unstructured\n        base_path.set_extension(FILE_EXTENSION);\n        Ok(base_path)\n    }\n\n    /// Push an artifact to this node's local repository.\n    /// Parameters are:\n    /// * reader — An object that this method will use to read the bytes of the artifact being\n    ///            pushed.\n    /// * expected_hash — The hash value that the pushed artifact is expected to have.\n    /// Returns true if it created the artifact local or false if the artifact already existed.\n    pub fn push_artifact(\n        \u0026self,\n        reader: \u0026mut impl Read,\n        expected_hash: \u0026Hash,\n    ) -\u003e Result\u003c(), anyhow::Error\u003e {\n        info!(\n            \"An artifact is being pushed to the artifact manager {}\",\n            expected_hash\n        );\n        let base_path = self.file_path_for_new_artifact(expected_hash)?;\n        debug!(\"Pushing artifact to {}\", base_path.display());\n        // Write to a temporary name that won't be mistaken for a valid file. If the hash checks out, rename it to the base name; otherwise delete it.\n        let tmp_path = tmp_path_from_base(\u0026base_path);\n\n        let out = create_artifact_file(\u0026tmp_path)?;\n        debug!(\"hash is {}\", expected_hash);\n        let mut hash_buffer = [0; HASH_BUFFER_SIZE];\n        let actual_hash = \u0026*do_push(reader, expected_hash, \u0026tmp_path, out, \u0026mut hash_buffer)?;\n        if actual_hash == expected_hash.bytes {\n            rename_to_permanent(expected_hash, \u0026base_path, \u0026tmp_path)\n        } else {\n            handle_wrong_hash(expected_hash, tmp_path, actual_hash)\n        }\n    }\n\n    /// Pull an artifact. The current implementation only looks in the local node's repository.\n    pub fn pull_artifact(\u0026self, hash: \u0026Hash) -\u003e Result\u003cFile, anyhow::Error\u003e {\n        info!(\n            \"An artifact is being pulled from the artifact manager {}\",\n            hash\n        );\n        let repository_path = get_repository_path()?;\n        let mut base_path: PathBuf = base_file_path(hash, \u0026repository_path);\n        // for now all artifacts are unstructured\n        base_path.set_extension(FILE_EXTENSION);\n        debug!(\"Pulling artifact from {}\", base_path.display());\n        File::open(base_path.as_path())\n            .with_context(|| format!(\"{} not found.\", base_path.display()))\n    }\n}\n\nfn get_repository_path() -\u003e std::io::Result\u003cPathBuf\u003e {\n    PathBuf::from(ARTIFACTS_DIR.as_str()).canonicalize()\n}\n\n// return true if the given repository path leads to an accessible directory.\nfn is_accessible_directory(repository_path: \u0026Path) -\u003e bool {\n    match std::fs::metadata(repository_path) {\n        Err(_) =\u003e false,\n        Ok(metadata) =\u003e metadata.is_dir(),\n    }\n}\n\n// Return a temporary file name to use for the file until we have verified that the hash is correct.\n// The temporary file name is guaranteed to be as unique as the hash and not to be mistaken for a\n// file whose name is its has code.\n//\n// The reason for doing this is so that a file whose actual hash is not equal to the expected\n// hash will not be found in the local repository from the time it is created and not fully\n// written until the time its hash is verified. After that, the file is renamed to its permanent\n// name that will match the actual hash value.\nfn tmp_path_from_base(base: \u0026Path) -\u003e PathBuf {\n    let mut tmp_buf = base.to_path_buf();\n    let file_name: \u0026OsStr = base.file_name().unwrap();\n    tmp_buf.set_file_name(format!(\"l0-{}\", file_name.to_str().unwrap()));\n    tmp_buf\n}\n\nfn is_directory_or_artifact_file(entry: \u0026DirEntry) -\u003e bool {\n    let not_hidden = entry\n        .file_name()\n        .to_str()\n        .map(|s| entry.depth() == 0 || !s.starts_with('.'))\n        .unwrap_or(false);\n    not_hidden\n        \u0026\u0026 (entry.file_type().is_dir()\n            || entry\n                .path()\n                .extension()\n                .map(|extension| extension == OsString::from(FILE_EXTENSION).as_os_str())\n                .unwrap_or(false))\n}\n\nfn create_artifact_file(tmp_path: \u0026Path) -\u003e std::io::Result\u003cFile\u003e {\n    OpenOptions::new()\n        .write(true)\n        .create_new(true)\n        .open(tmp_path)\n}\n\nfn handle_wrong_hash(\n    expected_hash: \u0026Hash,\n    tmp_path: PathBuf,\n    actual_hash: \u0026[u8],\n) -\u003e Result\u003c(), Error\u003e {\n    std::fs::remove_file(tmp_path.clone()).with_context(|| {\n        format!(\n            \"Attempted to remove {} because its content has the wrong hash.\",\n            tmp_path.to_str().unwrap()\n        )\n    })?;\n    let msg = format!(\"Contents of artifact did not have the expected hash value of {}. The actual hash was {}:{}\",\n                      expected_hash, expected_hash.algorithm, hex::encode(actual_hash));\n    warn!(\"{}\", msg);\n    bail!(\"{}\", msg)\n}\n\nfn rename_to_permanent(\n    expected_hash: \u0026Hash,\n    base_path: \u0026Path,\n    tmp_path: \u0026Path,\n) -\u003e Result\u003c(), anyhow::Error\u003e {\n    std::fs::rename(tmp_path, base_path).with_context(|| {\n        format!(\n            \"Attempting to rename from temporary file name{} to permanent{}\",\n            tmp_path.to_str().unwrap(),\n            base_path.to_str().unwrap()\n        )\n    })?;\n    debug!(\n        \"Artifact has the expected hash available locally {}\",\n        expected_hash\n    );\n    Ok(())\n}\n\nfn do_push\u003c'b\u003e(\n    reader: \u0026mut impl Read,\n    expected_hash: \u0026Hash,\n    path: \u0026Path,\n    out: File,\n    hash_buffer: \u0026'b mut [u8; HASH_BUFFER_SIZE],\n) -\u003e Result\u003c\u0026'b [u8], Error\u003e {\n    let mut buf_writer: BufWriter\u003cFile\u003e = BufWriter::new(out);\n    let mut digester = expected_hash.algorithm.digest_factory();\n    let mut writer = WriteHashDecorator::new(\u0026mut buf_writer, \u0026mut digester);\n\n    copy_from_reader_to_writer(reader, path, \u0026mut writer)\n        .with_context(|| format!(\"Error writing contents of {}\", expected_hash))?;\n    Ok(actual_hash(hash_buffer, \u0026mut digester))\n}\n\nconst HASH_BUFFER_SIZE: usize = 128;\n\nfn actual_hash\u003c'b\u003e(\n    hash_buffer: \u0026'b mut [u8; HASH_BUFFER_SIZE],\n    digester: \u0026mut Box\u003cdyn Digester\u003e,\n) -\u003e \u0026'b mut [u8] {\n    let buffer_slice: \u0026mut [u8] = \u0026mut hash_buffer[..digester.hash_size_in_bytes()];\n    digester.finalize_hash(buffer_slice);\n    buffer_slice\n}\n\nfn copy_from_reader_to_writer(\n    reader: \u0026mut impl Read,\n    path: \u0026Path,\n    mut writer: \u0026mut impl Write,\n) -\u003e Result\u003c(), Error\u003e {\n    std::io::copy(reader, \u0026mut writer).with_context(|| {\n        format!(\n            \"Error while copying artifact contents to {}\",\n            path.display()\n        )\n    })?;\n    writer.flush().with_context(|| {\n        format!(\n            \"Error while flushing last of artifact contents to {}\",\n            path.display()\n        )\n    })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::util::test_util;\n    use assay::assay;\n    use sha2::{Digest, Sha256};\n    use std::path::PathBuf;\n    use stringreader::StringReader;\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-node\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    pub fn new_artifact_storage_with_valid_directory() {\n        ArtifactStorage::new().expect(\"ArtifactStorage should be created.\");\n\n        let repository_path = get_repository_path()?;\n        let mut sha256_path = repository_path.clone();\n        sha256_path.push(HashAlgorithm::SHA256.hash_algorithm_to_str());\n        let meta256 = std::fs::metadata(sha256_path.as_path())\n            .expect(format!(\"unable to get metadata for {}\", sha256_path.display()).as_str());\n        assert!(meta256.is_dir());\n\n        let mut sha512_path = repository_path.clone();\n        sha512_path.push(HashAlgorithm::SHA512.hash_algorithm_to_str());\n        let meta512 = std::fs::metadata(sha512_path.as_path())\n            .expect(format!(\"unable to get metadata for {}\", sha512_path.display()).as_str());\n        assert!(meta512.is_dir());\n        std::fs::remove_dir_all(repository_path.as_path()).expect(\u0026format!(\n            \"unable to remove temp directory {}\",\n            repository_path.display()\n        ));\n    }\n\n    const TEST_ARTIFACT_DATA: \u0026str = \"Incumbent nonsense text, sesquipedalian and obfuscatory. Exhortations to the mother lode. Dendrites for all.\";\n    const TEST_ARTIFACT_HASH: [u8; 32] = [\n        0x6b, 0x29, 0xf2, 0xf1, 0xe5, 0x02, 0x4c, 0x41, 0x95, 0x06, 0xe9, 0x50, 0x3e, 0x02, 0x4b,\n        0x3d, 0x8a, 0x5a, 0x08, 0xb6, 0xf6, 0xd5, 0x5b, 0x68, 0x88, 0x66, 0x79, 0x52, 0xd1, 0x04,\n        0x15, 0x54,\n    ];\n    const WRONG_ARTIFACT_HASH: [u8; 32] = [\n        0x2d, 0x8c, 0x2f, 0x6d, 0x97, 0x8c, 0xa2, 0x17, 0x12, 0xb5, 0xf6, 0xde, 0x36, 0xc9, 0xd3,\n        0x1f, 0xa8, 0xe9, 0x6a, 0x4f, 0xa5, 0xd8, 0xff, 0x8b, 0x01, 0x88, 0xdf, 0xb9, 0xe7, 0xc1,\n        0x71, 0xbb,\n    ];\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-bogus-path\"),\n          (\"DEV_MODE\", \"off\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    pub fn new_artifact_storage_with_bad_directory() {\n        if let Ok(_) = ArtifactStorage::new() {\n            panic!(\"new should have returned an error because of an invalid directory\");\n        }\n    }\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-node\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    pub fn push_artifact_then_pull_it() {\n        let mut string_reader = StringReader::new(TEST_ARTIFACT_DATA);\n        let hash = Hash::new(HashAlgorithm::SHA256, \u0026TEST_ARTIFACT_HASH)?;\n        let artifact_storage = ArtifactStorage::new().expect(\"Error creating ArtifactManager\");\n\n        // Check the space before pushing artifact\n        let space_before = artifact_storage\n            .space_used()\n            .context(\"Error getting space used by ArtifactManager\")?;\n        assert_eq!(0, space_before);\n\n        artifact_storage\n            .push_artifact(\u0026mut string_reader, \u0026hash)\n            .context(\"Error from push_artifact\")?;\n\n        let mut repository_path = get_repository_path()?;\n        check_artifact_is_written_correctly(\u0026mut repository_path)?;\n\n        // Currently the space_used method does not include the size of directories in the directory tree, so this is how we obtain an independent result to check it.\n        let size_of_files_in_directory_tree = fs_extra::dir::get_size(\u0026repository_path)?;\n        // Check the space used after pushing artifact\n        let space_after = artifact_storage\n            .space_used()\n            .context(\"Error getting space used by ArtifactManager\")?;\n        assert_eq!(\n            size_of_files_in_directory_tree, space_after,\n            \"expect correct result from space_used\"\n        );\n\n        check_able_to_pull_artifact(\u0026hash, \u0026artifact_storage)?;\n    }\n\n    fn check_artifact_is_written_correctly(dir_name: \u0026mut PathBuf) -\u003e Result\u003c()\u003e {\n        dir_name.push(\"SHA256\");\n        dir_name.push(encode_bytes_as_file_name(\u0026TEST_ARTIFACT_HASH));\n        dir_name.set_extension(FILE_EXTENSION);\n        let content_vec = std::fs::read(dir_name.as_path()).context(\"reading pushed file\")?;\n        assert_eq!(content_vec.as_slice(), TEST_ARTIFACT_DATA.as_bytes());\n\n        Ok(())\n    }\n\n    fn check_able_to_pull_artifact(hash: \u0026Hash, artifact_storage: \u0026ArtifactStorage) -\u003e Result\u003c()\u003e {\n        let mut reader = artifact_storage\n            .pull_artifact(\u0026hash)\n            .context(\"Error from pull_artifact\")?;\n        let mut read_buffer = String::new();\n        reader.read_to_string(\u0026mut read_buffer)?;\n        assert_eq!(TEST_ARTIFACT_DATA, read_buffer);\n\n        Ok(())\n    }\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-node\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    pub fn push_wrong_hash_test() {\n        let mut string_reader = StringReader::new(TEST_ARTIFACT_DATA);\n        let hash = Hash::new(HashAlgorithm::SHA256, \u0026WRONG_ARTIFACT_HASH)?;\n        let artifact_storage = ArtifactStorage::new().expect(\"Error creating ArtifactManager\");\n        artifact_storage\n            .push_artifact(\u0026mut string_reader, \u0026hash)\n            .expect_err(\"push_artifact should have returned an error because of the wrong hash\");\n    }\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-node\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    pub fn pull_nonexistent_test() {\n        let hash = Hash::new(HashAlgorithm::SHA256, \u0026WRONG_ARTIFACT_HASH)?;\n        let artifact_storage = ArtifactStorage::new().expect(\"Error creating ArtifactManager\");\n        artifact_storage\n            .pull_artifact(\u0026hash)\n            .expect_err(\"pull_artifact should have failed with nonexistent hash\");\n    }\n\n    #[test]\n    pub fn test_write_hash_decorator() -\u003e anyhow::Result\u003c()\u003e {\n        let mut writer = Vec::new();\n        let mut digester = HashAlgorithm::SHA256.digest_factory();\n        let mut decorator = WriteHashDecorator::new(\u0026mut writer, \u0026mut digester);\n\n        let data = b\"sample_string\";\n        decorator.write(data)?;\n\n        let mut hash_bytes = [0; 32];\n        let mut hasher = Sha256::new();\n        hasher.update(\u0026data);\n\n        digester.finalize_hash(\u0026mut hash_bytes);\n        assert_eq!(hasher.finalize()[..], hash_bytes);\n\n        Ok(())\n    }\n}\n","traces":[{"line":35,"address":[8151540],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[8151586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[8151628,8151696,8151747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[8151905],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[4771280],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":41,"address":[4771312],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[8151829],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[4756120,4755584],"length":1,"stats":{"Line":0},"fn_name":"log_static_initialization_failure\u003c()\u003e"},{"line":56,"address":[4756177,4756160,4755609,4756884],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003c()\u003e"},{"line":57,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[4756207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[4756217,4756343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[4756638,4756562,4756473,4756721],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[4756696],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[4755657],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[4755687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":[4755715,4755874,4755961,4755798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[4755929],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[6340896],"length":1,"stats":{"Line":0},"fn_name":"encode_bytes_as_file_name"},{"line":74,"address":[6340917],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[6340944,6341176],"length":1,"stats":{"Line":0},"fn_name":"base_file_path"},{"line":86,"address":[6341010],"length":1,"stats":{"Line":0},"fn_name":null},{"line":87,"address":[6341021],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[6341105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[6341676,6341200],"length":1,"stats":{"Line":0},"fn_name":"ensure_directories_for_hash_algorithms_exist"},{"line":99,"address":[6341233],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[6341253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[6341334,6341455,6341586,6341269],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[6341478,6341591,6341649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[6341430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[6342705,6341712],"length":1,"stats":{"Line":0},"fn_name":"ensure_subdirectory_exists"},{"line":111,"address":[6341752],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[6341774],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[6341873,6342018,6342270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[6342124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[6342090,6342447,6342630,6342507],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[4756912,4756950],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":122,"address":[6342586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[4757152,4757104],"length":1,"stats":{"Line":1},"fn_name":"new\u003calloc::vec::Vec\u003cu8, alloc::alloc::Global\u003e\u003e"},{"line":140,"address":[6342736],"length":1,"stats":{"Line":1},"fn_name":"write"},{"line":141,"address":[6342782,6343010],"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":[6343121,6342954],"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":[6343128],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[6343152],"length":1,"stats":{"Line":0},"fn_name":"flush"},{"line":147,"address":[6343164],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[6343200,6343342],"length":1,"stats":{"Line":0},"fn_name":"write_all"},{"line":151,"address":[6343237,6343358],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[6343398],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[6343364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[6344659,6343424],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":163,"address":[6343580,6343431],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[6343904,6344654,6343650,6343557,6343712],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[6343906,6343973,6343770],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[6343892],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[6344108,6344255,6343718,6344026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[6344188],"length":1,"stats":{"Line":0},"fn_name":null},{"line":173,"address":[6344464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[6344166,6344421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[6346531,6344688],"length":1,"stats":{"Line":0},"fn_name":"artifacts_count_bydir"},{"line":181,"address":[6344719],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[6344749,6344989,6345043,6344824],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[6344918,6345170,6346396,6345086],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[4757230,4757200],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":189,"address":[6345532,6345401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[6345695,6345579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":192,"address":[6345759],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[6345730],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[6345869],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[6345928],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[6346339,6345969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[6346344,6346068],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[6346428],"length":1,"stats":{"Line":0},"fn_name":null},{"line":208,"address":[6346560,6346977],"length":1,"stats":{"Line":0},"fn_name":"space_used"},{"line":209,"address":[6346575,6346697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[6346867,6346794,6346680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[6347439,6346992],"length":1,"stats":{"Line":0},"fn_name":"file_path_for_new_artifact"},{"line":215,"address":[6347030,6347151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[6347129,6347214],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[6347259],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[6347291],"length":1,"stats":{"Line":0},"fn_name":null},{"line":228,"address":[4762880,4760080,4760051,4765651,4762851,4757280],"length":1,"stats":{"Line":0},"fn_name":"push_artifact\u003cstd::io::buffered::bufreader::BufReader\u003calloc::boxed::Box\u003cdyn std::io::Read, alloc::alloc::Global\u003e\u003e\u003e"},{"line":233,"address":[4757327,4760345,4757449,4762927,4760127,4757545,4763145,4763049,4760249],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[4760319,4757851,4757705,4760505,4763451,4763305,4763119,4757519,4760651],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[4760850,4757912,4760712,4763410,4760956,4758156,4757810,4763650,4763512,4760759,4760610,4763559,4757959,4763756,4758050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":240,"address":[4763722,4764047,4758122,4761247,4758447,4760922],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[4764400,4758800,4758589,4764456,4758470,4764070,4761656,4761389,4761600,4758856,4764189,4761270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":243,"address":[4758967,4764359,4764567,4762052,4761559,4761858,4761767,4764658,4758759,4758920,4761720,4764520,4764852,4759058,4759252],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[4761922,4759122,4764722],"length":1,"stats":{"Line":0},"fn_name":null},{"line":245,"address":[4765195,4764794,4765248,4762233,4759648,4762448,4761994,4765033,4759433,4759194,4759595,4762395],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[4759568,4765306,4759706,4762506,4762368,4765168],"length":1,"stats":{"Line":0},"fn_name":null},{"line":247,"address":[4759799,4762599,4765399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":249,"address":[4762512,4759957,4765312,4759712,4765557,4762757],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[6347456,6348889],"length":1,"stats":{"Line":0},"fn_name":"pull_artifact"},{"line":255,"address":[6347585,6347665,6347479],"length":1,"stats":{"Line":0},"fn_name":null},{"line":259,"address":[6347977,6347647,6347825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":260,"address":[6348111,6347930],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[6348159],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[6348272,6348354,6348186,6348448],"length":1,"stats":{"Line":0},"fn_name":null},{"line":264,"address":[6348689,6348768,6348420],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[4765680,4765718],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":269,"address":[6348912,6349070],"length":1,"stats":{"Line":0},"fn_name":"get_repository_path"},{"line":270,"address":[6348926],"length":1,"stats":{"Line":0},"fn_name":null},{"line":274,"address":[6349269,6349104],"length":1,"stats":{"Line":0},"fn_name":"is_accessible_directory"},{"line":275,"address":[6349133],"length":1,"stats":{"Line":0},"fn_name":null},{"line":276,"address":[6349210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":277,"address":[6349229,6349160],"length":1,"stats":{"Line":0},"fn_name":null},{"line":289,"address":[6349328,6349768],"length":1,"stats":{"Line":0},"fn_name":"tmp_path_from_base"},{"line":290,"address":[6349374],"length":1,"stats":{"Line":0},"fn_name":null},{"line":291,"address":[6349493,6349390],"length":1,"stats":{"Line":0},"fn_name":null},{"line":292,"address":[6349509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":296,"address":[6349792],"length":1,"stats":{"Line":0},"fn_name":"is_directory_or_artifact_file"},{"line":297,"address":[6349870,6349809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":300,"address":[4765901,4765872],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":302,"address":[6349916,6350000],"length":1,"stats":{"Line":0},"fn_name":null},{"line":303,"address":[6349937,6349995,6350080],"length":1,"stats":{"Line":0},"fn_name":null},{"line":304,"address":[6350022,6349977],"length":1,"stats":{"Line":0},"fn_name":null},{"line":307,"address":[4765984,4765998],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":311,"address":[6350112],"length":1,"stats":{"Line":0},"fn_name":"create_artifact_file"},{"line":312,"address":[6350136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":318,"address":[6351693,6350288],"length":1,"stats":{"Line":0},"fn_name":"handle_wrong_hash"},{"line":323,"address":[4766160],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":324,"address":[4766280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":326,"address":[4766198],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[6350545,6350696,6351091,6350788],"length":1,"stats":{"Line":0},"fn_name":null},{"line":330,"address":[6350781],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[6351259,6351053,6351349,6351183,6351136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":332,"address":[6351520,6351317],"length":1,"stats":{"Line":0},"fn_name":null},{"line":335,"address":[6351728],"length":1,"stats":{"Line":0},"fn_name":"rename_to_permanent"},{"line":340,"address":[4766400],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":341,"address":[4766580,4766486],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[4766422],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[4766515],"length":1,"stats":{"Line":0},"fn_name":null},{"line":347,"address":[6352082,6352152,6352022,6351935],"length":1,"stats":{"Line":0},"fn_name":null},{"line":351,"address":[6352138],"length":1,"stats":{"Line":0},"fn_name":null},{"line":354,"address":[4767939,4767968,4768563,4767344,4766720,4767315],"length":1,"stats":{"Line":0},"fn_name":"do_push\u003cstringreader::StringReader\u003e"},{"line":361,"address":[4767437,4766813,4768061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":362,"address":[4766827,4768075,4767451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[4766903,4768151,4767527],"length":1,"stats":{"Line":0},"fn_name":null},{"line":365,"address":[4768419,4768222,4767598,4767041,4767795,4766974,4767171,4767665,4768289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[4768592,4767200,4768848,4768624,4768403,4767779,4767824,4768752,4768720,4768448,4768880,4767155,4767033,4767657,4768281],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003cstringreader::StringReader\u003e"},{"line":367,"address":[4767269,4768381,4767757,4767893,4767133,4768517],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[6352304],"length":1,"stats":{"Line":0},"fn_name":"actual_hash"},{"line":376,"address":[6352328],"length":1,"stats":{"Line":0},"fn_name":null},{"line":377,"address":[6352411],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":381,"address":[4769360,4769744,4768976],"length":1,"stats":{"Line":0},"fn_name":"copy_from_reader_to_writer\u003cstringreader::StringReader, pyrsia::artifact_service::storage::WriteHashDecorator\u003e"},{"line":386,"address":[4770128,4769795,4769281,4769027,4770049,4770512,4769665,4769411,4770320],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}\u003cstd::io::buffered::bufreader::BufReader\u003calloc::boxed::Box\u003cdyn std::io::Read, alloc::alloc::Global\u003e\u003e, pyrsia::artifact_service::storage::WriteHashDecorator\u003e"},{"line":387,"address":[4770589,4770205,4770397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":389,"address":[4770571,4770379,4770187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":392,"address":[4770704,4769712,4770896,4771088,4769328,4769635,4770019,4769251,4770096],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}\u003cstd::fs::File, pyrsia::artifact_service::storage::WriteHashDecorator\u003e"},{"line":393,"address":[4770781,4771165,4770973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":395,"address":[4770763,4771147,4770955],"length":1,"stats":{"Line":0},"fn_name":null},{"line":409,"address":[4655614,4655486,4655973,4655050,4655783,4655776,4655083,4655341,4654935,4655162,4655600,4655898,4655584,4655709,4655391],"length":1,"stats":{"Line":11},"fn_name":"modify"},{"line":414,"address":[6909050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":416,"address":[4654928],"length":1,"stats":{"Line":1},"fn_name":"new_artifact_storage_with_valid_directory"},{"line":417,"address":[6906653],"length":1,"stats":{"Line":0},"fn_name":null},{"line":419,"address":[6906710,6906850,6906947],"length":1,"stats":{"Line":0},"fn_name":null},{"line":420,"address":[6906843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":421,"address":[6906974,6907061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":422,"address":[6907547,6907126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":423,"address":[6907200,6907585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":424,"address":[6907681,6907743],"length":1,"stats":{"Line":0},"fn_name":null},{"line":426,"address":[6907736],"length":1,"stats":{"Line":0},"fn_name":null},{"line":427,"address":[6907775],"length":1,"stats":{"Line":0},"fn_name":null},{"line":428,"address":[6907889,6908286],"length":1,"stats":{"Line":0},"fn_name":null},{"line":429,"address":[6907963,6908324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[6908420,6908478],"length":1,"stats":{"Line":0},"fn_name":null},{"line":431,"address":[6908461,6908677,6908521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":433,"address":[6908661,6908566],"length":1,"stats":{"Line":0},"fn_name":null},{"line":449,"address":[4656479,4656688,4656023,4656864,4656986,4656138,4656797,4656702,4656250,4656871,4656171,4656672,4657061,4656429,4656574],"length":1,"stats":{"Line":11},"fn_name":"modify"},{"line":454,"address":[6909614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":456,"address":[4656016],"length":1,"stats":{"Line":1},"fn_name":"new_artifact_storage_with_bad_directory"},{"line":457,"address":[6909509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":458,"address":[6909560,6909646],"length":1,"stats":{"Line":0},"fn_name":null},{"line":462,"address":[4657885,4657952,4657760,4657259,4657338,4657226,4657567,4657111,4657517,4657662,4658149,4657776,4657790,4657959,4658074],"length":1,"stats":{"Line":11},"fn_name":"modify"},{"line":467,"address":[6913997],"length":1,"stats":{"Line":0},"fn_name":null},{"line":469,"address":[4657104],"length":1,"stats":{"Line":1},"fn_name":"push_artifact_then_pull_it"},{"line":470,"address":[6910197],"length":1,"stats":{"Line":0},"fn_name":null},{"line":471,"address":[6910268,6910512,6910432],"length":1,"stats":{"Line":0},"fn_name":null},{"line":472,"address":[6910566,6910417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":475,"address":[6911060,6910640],"length":1,"stats":{"Line":0},"fn_name":null},{"line":478,"address":[6910944,6911211],"length":1,"stats":{"Line":0},"fn_name":null},{"line":480,"address":[6911756,6911882,6911193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":484,"address":[6911976,6911859,6912109,6912192],"length":1,"stats":{"Line":0},"fn_name":null},{"line":485,"address":[6912354,6912295,6912094,6912434,6912227],"length":1,"stats":{"Line":0},"fn_name":null},{"line":488,"address":[6912583,6912344,6912499,6912786],"length":1,"stats":{"Line":0},"fn_name":null},{"line":490,"address":[6912829,6913211,6912557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":493,"address":[6913336,6913094],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[6913321,6913813,6913955,6913886],"length":1,"stats":{"Line":0},"fn_name":null},{"line":501,"address":[4653296,4653987],"length":1,"stats":{"Line":0},"fn_name":"check_artifact_is_written_correctly"},{"line":502,"address":[4653316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":503,"address":[4653334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":504,"address":[4653376],"length":1,"stats":{"Line":0},"fn_name":null},{"line":505,"address":[4653398,4653596],"length":1,"stats":{"Line":0},"fn_name":null},{"line":506,"address":[4653654,4653941,4653793,4653570],"length":1,"stats":{"Line":0},"fn_name":null},{"line":508,"address":[4653907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":511,"address":[4654016,4654905],"length":1,"stats":{"Line":0},"fn_name":"check_able_to_pull_artifact"},{"line":512,"address":[4654303,4654054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":513,"address":[4654049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":515,"address":[4654283],"length":1,"stats":{"Line":0},"fn_name":null},{"line":516,"address":[4654537,4654688,4654335,4654752,4654417],"length":1,"stats":{"Line":0},"fn_name":null},{"line":517,"address":[4654604,4654799,4654843],"length":1,"stats":{"Line":0},"fn_name":null},{"line":519,"address":[4654805],"length":1,"stats":{"Line":0},"fn_name":null},{"line":522,"address":[4658750,4659162,4659237,4658878,4658864,4658848,4658605,4658655,4658973,4658426,4658347,4659047,4658314,4659040,4658199],"length":1,"stats":{"Line":11},"fn_name":"modify"},{"line":527,"address":[6915003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":529,"address":[4658192],"length":1,"stats":{"Line":1},"fn_name":"push_wrong_hash_test"},{"line":530,"address":[6914490],"length":1,"stats":{"Line":0},"fn_name":null},{"line":531,"address":[6914786,6914710,6914549],"length":1,"stats":{"Line":0},"fn_name":null},{"line":532,"address":[6914818,6914698],"length":1,"stats":{"Line":0},"fn_name":null},{"line":533,"address":[6914908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":538,"address":[4659435,4659838,4659287,4660250,4660128,4659743,4659693,4660325,4659936,4659966,4659402,4659952,4660061,4660135,4659514],"length":1,"stats":{"Line":11},"fn_name":"modify"},{"line":543,"address":[6915972],"length":1,"stats":{"Line":0},"fn_name":null},{"line":545,"address":[4659280],"length":1,"stats":{"Line":1},"fn_name":"pull_nonexistent_test"},{"line":546,"address":[6915707,6915470,6915631],"length":1,"stats":{"Line":0},"fn_name":null},{"line":547,"address":[6915619,6915739],"length":1,"stats":{"Line":0},"fn_name":null},{"line":548,"address":[6915821],"length":1,"stats":{"Line":0},"fn_name":null},{"line":554,"address":[4661427,4660368],"length":1,"stats":{"Line":3},"fn_name":"test_write_hash_decorator"},{"line":555,"address":[4660375],"length":1,"stats":{"Line":1},"fn_name":null},{"line":556,"address":[4660389],"length":1,"stats":{"Line":1},"fn_name":null},{"line":557,"address":[4660463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":559,"address":[4660511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":560,"address":[4660526,4660854,4660611,4660791],"length":1,"stats":{"Line":2},"fn_name":null},{"line":562,"address":[4660757],"length":1,"stats":{"Line":1},"fn_name":null},{"line":563,"address":[4660784],"length":1,"stats":{"Line":1},"fn_name":null},{"line":564,"address":[4660927],"length":1,"stats":{"Line":1},"fn_name":null},{"line":566,"address":[4660934],"length":1,"stats":{"Line":1},"fn_name":null},{"line":567,"address":[4660971,4661162,4661362],"length":1,"stats":{"Line":2},"fn_name":null},{"line":569,"address":[4661320],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":27,"coverable":229},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","artifact_service.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod handlers;\npub mod service;\npub mod storage;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","examples","simple_node.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse clap::Parser;\nuse dirs;\nuse futures::channel::{mpsc as futures_mpsc, oneshot};\nuse futures::StreamExt;\nuse libp2p::{identity, PeerId};\nuse log::{debug, info};\nuse std::{\n    error::Error,\n    fs,\n    io::{Read, Write},\n    os::unix::fs::OpenOptionsExt,\n    sync::{Arc, Mutex},\n};\nuse tokio::io;\n\n// use pyrsia_blockchain_network::blockchain::Blockchain;\nuse pyrsia_blockchain_network::args::parser::BlockchainNodeArgs;\nuse pyrsia_blockchain_network::crypto::hash_algorithm::HashDigest;\nuse pyrsia_blockchain_network::identities::{\n    authority_pen::AuthorityPen, authority_verifier::AuthorityVerifier, key_box::KeyBox,\n};\nuse pyrsia_blockchain_network::network::{Network, Spawner};\nuse pyrsia_blockchain_network::providers::{DataProvider, DataStore, FinalizationProvider};\nuse pyrsia_blockchain_network::structures::block::Block;\nuse pyrsia_blockchain_network::{\n    default_config, gen_chain_config, run_blockchain, run_session, NodeIndex,\n};\n\nconst TXS_PER_BLOCK: usize = 50000;\nconst TX_SIZE: usize = 300;\nconst BLOCK_TIME_MS: u128 = 500;\nconst INITIAL_DELAY_MS: u128 = 5000;\n\n#[tokio::main]\nasync fn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e {\n    pretty_env_logger::init();\n\n    let args = BlockchainNodeArgs::parse();\n\n    let key_path = get_keyfile_name(args.clone());\n\n    // If the key file exists, load the key pair. Otherwise, create a random keypair and save to the keypair file\n    let id_keys = create_ed25519_keypair(key_path);\n    let ed25519_pair = identity::Keypair::Ed25519(id_keys.clone());\n    let _peer_id = PeerId::from(ed25519_pair.public());\n\n    info!(\"Getting network up!\");\n    let n_members = 3;\n    let my_node_ix = NodeIndex(args.peer_index);\n\n    let pen = AuthorityPen::new(my_node_ix, id_keys.clone());\n    let verifier = AuthorityVerifier::new();\n\n    let keybox = KeyBox::new(pen, verifier);\n\n    let (authority_to_verifier, mut authority_from_network) = futures_mpsc::unbounded();\n    let (close_verifier, mut exit) = oneshot::channel();\n    tokio::spawn(async move {\n        loop {\n            futures::select! {\n                maybe_auth = authority_from_network.next() =\u003e {\n                    if let Some((_node_ix, _public_key)) = maybe_auth {\n                        // record_authority(node_ix, public_key);\n                    }\n                }\n               _ = \u0026mut exit  =\u003e break,\n            }\n        }\n    });\n\n    let (\n        network,\n        mut manager,\n        block_from_data_io_tx,\n        block_from_network_rx,\n        message_for_network,\n        message_from_network,\n    ) = Network::new(\n        my_node_ix,\n        id_keys.clone(),\n        Default::default(), // peers_by_index,\n        authority_to_verifier,\n    )\n    .await\n    .expect(\"Libp2p network set-up should succeed.\");\n    // Make the \"genesis\" blocks\n    let current_block: Arc\u003cMutex\u003cBlock\u003e\u003e = Arc::new(Mutex::new(Block::new(\n        HashDigest::new(b\"\"),\n        0,\n        vec![],\n        \u0026id_keys,\n    )));\n\n    let data_provider = DataProvider::new(current_block.clone()); // TODO(prince-chrismc): Blend this into blockchain API???\n    let (finalization_provider, mut finalized_rx) = FinalizationProvider::new();\n    let data_store = DataStore::new(current_block.clone(), message_for_network);\n\n    let (close_network, exit) = oneshot::channel();\n    tokio::spawn(async move { manager.run(exit).await });\n\n    let data_size: usize = TXS_PER_BLOCK * TX_SIZE;\n    let chain_config = gen_chain_config(\n        my_node_ix,\n        n_members,\n        data_size,\n        BLOCK_TIME_MS,\n        INITIAL_DELAY_MS,\n    );\n    let (close_chain, exit) = oneshot::channel();\n    tokio::spawn(async move {\n        run_blockchain(\n            chain_config,\n            data_store,\n            current_block,\n            block_from_network_rx,\n            block_from_data_io_tx,\n            message_from_network,\n            exit,\n        )\n        .await\n    });\n\n    let (close_member, exit) = oneshot::channel();\n    tokio::spawn(async move {\n        let config = default_config(n_members.into(), my_node_ix, 0);\n        run_session(\n            config,\n            network,\n            data_provider,\n            finalization_provider,\n            keybox,\n            Spawner {},\n            exit,\n        )\n        .await\n    });\n\n    let mut max_block_finalized = 0;\n    while let Some(block_num) = finalized_rx.next().await {\n        if max_block_finalized \u003c block_num.header.ordinal {\n            max_block_finalized = block_num.header.ordinal;\n        }\n        debug!(\n            \"🌟 Got new batch. Highest finalized = {:?}\",\n            max_block_finalized\n        );\n        if max_block_finalized \u003e= 100 as u128 {\n            break;\n        }\n    }\n    close_member.send(()).expect(\"should send\");\n    close_chain.send(()).expect(\"should send\");\n    close_network.send(()).expect(\"should send\");\n    close_verifier.send(()).expect(\"should send\");\n    Ok(())\n}\n\npub fn write_block(path: \u0026str, block: Block) {\n    let mut file = fs::OpenOptions::new()\n        .write(true)\n        .append(true)\n        .create(true)\n        .open(path)\n        .expect(\"cannot open file\");\n\n    file.write_all(serde_json::to_string(\u0026block).unwrap().as_bytes())\n        .expect(\"write failed\");\n    file.write_all(b\"\\n\").expect(\"write failed\");\n}\n\npub fn write_keypair(path: \u0026String, data: \u0026[u8; 64]) {\n    let mut file = fs::OpenOptions::new()\n        .write(true)\n        .create(true)\n        .mode(0o600)\n        .open(path)\n        .expect(\"cannot open file\");\n\n    file.write_all(data).expect(\"write failed\");\n}\n\npub fn read_keypair(path: \u0026String) -\u003e Result\u003c[u8; 64], Box\u003cdyn Error\u003e\u003e {\n    let mut file = std::fs::File::open(path)?;\n    let mut buf = [0u8; 64];\n    let n = file.read(\u0026mut buf)?;\n    if n == 64 {\n        Ok(buf)\n    } else {\n        Err(Box::new(io::Error::from(io::ErrorKind::InvalidData)))\n    }\n}\n\npub fn get_keyfile_name(args: BlockchainNodeArgs) -\u003e String {\n    let mut path = dirs::home_dir().unwrap();\n    path.push(args.key_filename);\n    let filepath = path.into_os_string().into_string().unwrap();\n    filepath\n}\n\npub fn create_ed25519_keypair(filename: String) -\u003e libp2p::identity::ed25519::Keypair {\n    match read_keypair(\u0026filename) {\n        Ok(v) =\u003e {\n            let data: \u0026mut [u8] = \u0026mut v.clone();\n            debug!(\"Load Keypair from {:?}\", filename);\n            libp2p::identity::ed25519::Keypair::decode(data).unwrap()\n        }\n        Err(_) =\u003e {\n            let id_keys = identity::ed25519::Keypair::generate();\n\n            let data = id_keys.encode();\n            debug!(\"Create Keypair\");\n            write_keypair(\u0026filename, \u0026data);\n            id_keys\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use pyrsia_blockchain_network::args::parser::DEFAULT_BLOCK_KEYPAIR_FILENAME;\n    const TEST_KEYPAIR_FILENAME: \u0026str = \"./test_keypair\";\n    #[test]\n    fn test_get_keyfile_name_succeeded() {\n        let mut path = dirs::home_dir().unwrap();\n\n        path.push(DEFAULT_BLOCK_KEYPAIR_FILENAME);\n        let args = BlockchainNodeArgs {\n            key_filename: DEFAULT_BLOCK_KEYPAIR_FILENAME.to_string(),\n            peer_index: 0,\n        };\n        assert_eq!(\n            path.into_os_string().into_string().unwrap(),\n            get_keyfile_name(args)\n        );\n    }\n\n    #[test]\n    fn test_write_keypair_succeeded() {\n        let file = String::from(TEST_KEYPAIR_FILENAME);\n        let data = [0u8; 64];\n        let result = std::panic::catch_unwind(|| write_keypair(\u0026file, \u0026data));\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_read_keypair_succeeded() {\n        let file = String::from(TEST_KEYPAIR_FILENAME);\n        let data = [0u8; 64];\n        write_keypair(\u0026file, \u0026data);\n        assert!(read_keypair(\u0026file).is_ok());\n    }\n\n    #[test]\n    fn test_create_keypair_succeeded() {\n        let args = BlockchainNodeArgs {\n            key_filename: DEFAULT_BLOCK_KEYPAIR_FILENAME.to_string(),\n            peer_index: 0,\n        };\n        let result = std::panic::catch_unwind(|| create_ed25519_keypair(args));\n        assert!(result.is_ok());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","args","parser.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse clap::Parser;\n\npub const DEFAULT_BLOCK_KEYPAIR_FILENAME: \u0026str = \".block_keypair\";\n\n/// Application to connect to and participate in the Pyrsia blockchain network\n#[derive(Debug, Parser, Clone)]\n#[clap(long_about = None)]\npub struct BlockchainNodeArgs {\n    /// A string to specify the keypair filename\n    #[clap(long, short = 'K', default_value = DEFAULT_BLOCK_KEYPAIR_FILENAME)]\n    pub key_filename: String,\n    /// An unsigned number to specify the node index on Aleph algorithm.\n    #[clap(long, short = 'I', required = true)]\n    pub peer_index: usize,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","args.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod parser;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","blockchain.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse libp2p::identity;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fmt::{self, Debug, Formatter};\n\nuse super::crypto::hash_algorithm::HashDigest;\nuse super::structures::{\n    block::Block,\n    chain::Chain,\n    header::Address,\n    transaction::{Transaction, TransactionType},\n};\n\n/// Define Supported Signature Algorithm\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub enum SignatureAlgorithm {\n    Ed25519,\n}\n\npub struct Blockchain {\n    // this should actually be a Map\u003cTransaction,Vec\u003cOnTransactionSettled\u003e\u003e but that's later\n    trans_observers: HashMap\u003cTransaction, Box\u003cdyn FnOnce(Transaction)\u003e\u003e,\n    block_observers: Vec\u003cBox\u003cdyn FnMut(Block)\u003e\u003e,\n    chain: Chain,\n}\n\nimpl Debug for Blockchain {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        f.debug_struct(\"Blockchain\")\n            .field(\"chain\", \u0026self.chain)\n            .field(\"trans_observers\", \u0026self.trans_observers.len())\n            .field(\"block_observers\", \u0026self.block_observers.len())\n            .finish()\n    }\n}\n\nimpl Blockchain {\n    pub fn new(keypair: \u0026identity::ed25519::Keypair) -\u003e Self {\n        let local_id = Address::from(identity::PublicKey::Ed25519(keypair.public()));\n        let transaction = Transaction::new(\n            TransactionType::AddAuthority,\n            local_id,\n            \"this needs to be the root authority\".as_bytes().to_vec(),\n            keypair,\n        );\n        // Make the \"genesis\" blocks\n        let block = Block::new(HashDigest::new(b\"\"), 0, Vec::from([transaction]), keypair);\n        let mut chain: Chain = Default::default();\n        chain.blocks.push(block);\n        Self {\n            trans_observers: Default::default(),\n            block_observers: vec![],\n            chain,\n        }\n    }\n\n    pub fn blocks(\u0026self) -\u003e Vec\u003cBlock\u003e {\n        self.chain.blocks.clone()\n    }\n\n    pub fn submit_transaction\u003cCallBack: 'static + FnOnce(Transaction)\u003e(\n        \u0026mut self,\n        trans: Transaction,\n        on_done: CallBack,\n    ) -\u003e \u0026mut Self {\n        self.trans_observers.insert(trans, Box::new(on_done));\n        self\n    }\n\n    pub fn notify_transaction_settled(\u0026mut self, trans: Transaction) {\n        // if there were no observers, we don't care\n        if let Some(on_settled) = self.trans_observers.remove(\u0026trans) {\n            on_settled(trans)\n        }\n    }\n\n    pub fn add_block_listener\u003cCallBack: 'static + FnMut(Block)\u003e(\n        \u0026mut self,\n        on_block: CallBack,\n    ) -\u003e \u0026mut Self {\n        self.block_observers.push(Box::new(on_block));\n        self\n    }\n\n    pub fn notify_block_event(\u0026mut self, block: Block) -\u003e \u0026mut Self {\n        self.block_observers\n            .iter_mut()\n            .for_each(|notify| notify(block.clone()));\n        self\n    }\n\n    #[warn(dead_code)]\n    pub fn add_block(\u0026mut self, block: Block) {\n        self.chain.blocks.push(block);\n        self.notify_block_event(self.chain.blocks.last().expect(\"block must exist\").clone());\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use std::cell::Cell;\n    use std::rc::Rc;\n\n    use super::*;\n\n    #[test]\n    fn test_build_blockchain() -\u003e Result\u003c(), String\u003e {\n        let keypair = identity::ed25519::Keypair::generate();\n        let local_id = Address::from(identity::PublicKey::Ed25519(keypair.public()));\n        let mut chain = Blockchain::new(\u0026keypair);\n\n        let mut transactions = vec![];\n        let data = \"Hello First Transaction\";\n        let transaction = Transaction::new(\n            TransactionType::Create,\n            local_id,\n            data.as_bytes().to_vec(),\n            \u0026keypair,\n        );\n        transactions.push(transaction);\n        chain.add_block(Block::new(\n            chain.blocks()[0].header.hash(),\n            chain.blocks()[0].header.ordinal + 1,\n            transactions,\n            \u0026keypair,\n        ));\n        assert_eq!(true, chain.blocks().last().unwrap().verify());\n        assert_eq!(2, chain.blocks().len());\n        Ok(())\n    }\n\n    #[test]\n    fn test_add_trans_listener() -\u003e Result\u003c(), String\u003e {\n        let keypair = identity::ed25519::Keypair::generate();\n        let local_id = Address::from(identity::PublicKey::Ed25519(keypair.public()));\n        let mut chain = Blockchain::new(\u0026keypair);\n\n        let transaction = Transaction::new(\n            TransactionType::Create,\n            local_id,\n            \"some transaction\".as_bytes().to_vec(),\n            \u0026keypair,\n        );\n        let called = Rc::new(Cell::new(false));\n        chain\n            .submit_transaction(transaction.clone(), {\n                let called = called.clone();\n                let transaction = transaction.clone();\n                move |t: Transaction| {\n                    assert_eq!(transaction, t);\n                    called.set(true)\n                }\n            })\n            .notify_transaction_settled(transaction);\n        assert!(called.get());\n        Ok(())\n    }\n\n    #[test]\n    fn test_add_block_listener() -\u003e Result\u003c(), String\u003e {\n        let keypair = identity::ed25519::Keypair::generate();\n        let block = Block::new(\n            HashDigest::new(b\"Hello World!\"),\n            1u128,\n            Vec::new(),\n            \u0026keypair,\n        );\n        let mut chain = Blockchain::new(\u0026keypair);\n        let called = Rc::new(Cell::new(false));\n\n        chain\n            .add_block_listener({\n                let called = called.clone();\n                let block = block.clone();\n                move |b: Block| {\n                    assert_eq!(block, b);\n                    called.set(true);\n                }\n            })\n            .add_block(block);\n\n        assert!(called.get()); // called is still false\n        Ok(())\n    }\n}\n","traces":[{"line":82,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","crypto","hash_algorithm.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse codec::{Decode, Encode};\nuse multihash::{Code, Multihash, MultihashDigest};\nuse serde::{Deserialize, Serialize};\n\n#[derive(\n    Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Eq, Hash, Decode, Encode, PartialOrd,\n)]\npub struct HashDigest {\n    multihash: Multihash,\n}\n\nimpl HashDigest {\n    pub fn new(msg: \u0026[u8]) -\u003e Self {\n        Self {\n            multihash: Code::Keccak256.digest(msg),\n        }\n    }\n\n    pub fn to_slice(\u0026self) -\u003e [u8; 32] {\n        self.multihash\n            .digest()\n            .try_into()\n            .expect(\"a valid Keccak256 to be 32 bytes\")\n    }\n}\n\nimpl aleph_bft::Hasher for HashDigest {\n    type Hash = [u8; 32];\n\n    fn hash(x: \u0026[u8]) -\u003e Self::Hash {\n        HashDigest::new(x).to_slice()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use aleph_bft::Hasher;\n\n    #[test]\n    fn test_hash_digest() {\n        let message = b\"hello world\";\n        let expected_digest = [\n            0x47, 0x17, 0x32, 0x85, 0xa8, 0xd7, 0x34, 0x1e, 0x5e, 0x97, 0x2f, 0xc6, 0x77, 0x28,\n            0x63, 0x84, 0xf8, 0x02, 0xf8, 0xef, 0x42, 0xa5, 0xec, 0x5f, 0x03, 0xbb, 0xfa, 0x25,\n            0x4c, 0xb0, 0x1f, 0xad,\n        ];\n\n        let hash = HashDigest::new(message);\n\n        assert_eq!(hash.to_slice(), expected_digest);\n        assert_eq!(HashDigest::hash(message), expected_digest);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","crypto.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod hash_algorithm;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","identities","authority_pen.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse aleph_bft::NodeIndex;\nuse libp2p::core::identity::ed25519::{Keypair, PublicKey};\n\nuse super::signature::Signature;\n\n#[derive(Clone)]\npub struct AuthorityPen {\n    index: NodeIndex,\n    keypair: Keypair,\n}\n\nimpl AuthorityPen {\n    pub fn new(index: NodeIndex, keypair: Keypair) -\u003e Self {\n        Self { index, keypair }\n    }\n    pub fn index(\u0026self) -\u003e NodeIndex {\n        self.index\n    }\n    pub fn public(\u0026self) -\u003e PublicKey {\n        self.keypair.public()\n    }\n    pub fn sign(\u0026self, msg: \u0026[u8]) -\u003e Signature {\n        Signature::new(msg, \u0026self.keypair)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_auth_pen_sign() {\n        let keypair = Keypair::generate();\n        let auth_pen = AuthorityPen::new(0.into(), keypair.clone());\n        let signed = auth_pen.sign(b\"hello world!\");\n\n        assert!(keypair.public().verify(b\"hello world!\", \u0026signed.to_bytes()));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","identities","authority_verifier.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse aleph_bft::{NodeCount, NodeIndex};\nuse libp2p::core::identity::ed25519::PublicKey;\nuse log::{trace, warn};\nuse std::collections::HashMap;\n\nuse super::signature::{MultiSignature, Signature};\n\n#[derive(Clone, Default)]\npub struct AuthorityVerifier {\n    authorities: HashMap\u003cNodeIndex, PublicKey\u003e,\n    // TODO(prince-chrismc): Re-introduce `NodeIndex` to associate with `PeerId` when adding `network`\n    // peers_by_index: HashMap\u003cNodeIndex, PeerId\u003e,\n}\n\nimpl AuthorityVerifier {\n    pub fn new() -\u003e AuthorityVerifier {\n        Default::default()\n    }\n    pub fn save(\u0026mut self, node_ix: NodeIndex, public_key: PublicKey) {\n        trace!(\n            \"Recording new authority {:?} with {:?}\",\n            node_ix,\n            public_key\n        );\n        self.authorities.insert(node_ix, public_key);\n    }\n    /// Verifies whether the message is correctly signed with the signature assumed to be made by a\n    /// node of the given index.\n    pub fn verify(\u0026self, msg: \u0026[u8], sgn: \u0026Signature, index: NodeIndex) -\u003e bool {\n        let sig = sgn.clone().to_bytes();\n        match self.authorities.get(\u0026index) {\n            Some(public_key) =\u003e public_key.verify(msg, \u0026sig),\n            None =\u003e {\n                warn!(\"No public key for {:?}\", index);\n                false\n            }\n        }\n    }\n\n    pub fn node_count(\u0026self) -\u003e NodeCount {\n        self.authorities.len().into()\n    }\n\n    fn threshold(\u0026self) -\u003e usize {\n        2 * self.node_count().0 / 3 + 1\n    }\n\n    /// Verifies whether the given signature set is a correct and complete multisignature of the\n    /// message. Completeness requires more than 2/3 of all authorities.\n    pub fn is_complete(\u0026self, msg: \u0026[u8], partial: \u0026MultiSignature) -\u003e bool {\n        let signature_count = partial.iter().count();\n        if signature_count \u003c self.threshold() {\n            return false;\n        }\n        partial.iter().all(|(i, sgn)| self.verify(msg, sgn, i))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use aleph_bft::PartialMultisignature;\n    use libp2p::core::identity::ed25519::Keypair;\n\n    #[test]\n    fn test_auth_verifier_nothing() {\n        let multi_signs = MultiSignature::with_size(0.into());\n        let verifier = AuthorityVerifier::new();\n\n        assert_eq!(verifier.node_count(), 0.into());\n        assert_eq!(verifier.threshold(), 1);\n        assert_eq!(verifier.is_complete(b\"hello world\", \u0026multi_signs), false);\n    }\n\n    #[test]\n    fn test_auth_verifier_empty() {\n        let keypair = Keypair::generate();\n        let signed = keypair.sign(b\"hello world!\");\n        let sign = Signature::from_bytes(\u0026signed).expect(\"signature to be valid\");\n        let multi_signs =\n            MultiSignature::add_signature(MultiSignature::with_size(1.into()), \u0026sign, 0.into());\n        let verifier = AuthorityVerifier::new();\n\n        assert_eq!(verifier.node_count(), 0.into());\n        assert_eq!(verifier.threshold(), 1);\n        assert_eq!(verifier.is_complete(b\"hello world\", \u0026multi_signs), false);\n    }\n\n    #[test]\n    fn test_auth_verifier_one_signature_valid() {\n        let keypair = Keypair::generate();\n        let signed = keypair.sign(b\"hello world!\");\n        let sign = Signature::from_bytes(\u0026signed).expect(\"signature to be valid\");\n        let node_index: NodeIndex = 0.into();\n        let multi_signs =\n            MultiSignature::add_signature(MultiSignature::with_size(1.into()), \u0026sign, node_index);\n\n        let mut verifier = AuthorityVerifier::new();\n        verifier.save(node_index, keypair.public());\n\n        assert_eq!(verifier.node_count(), 1.into());\n        assert_eq!(verifier.threshold(), 1);\n        assert_eq!(verifier.is_complete(b\"hello world\", \u0026multi_signs), false);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","identities","key_box.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse aleph_bft::{NodeCount, NodeIndex, PartialMultisignature};\nuse async_trait::async_trait;\nuse libp2p::core::identity::ed25519::PublicKey;\nuse log::trace;\n\nuse super::authority_pen::AuthorityPen;\nuse super::authority_verifier::AuthorityVerifier;\nuse super::signature::{MultiSignature, Signature};\n\n#[derive(Clone)]\npub struct KeyBox {\n    authority_pen: AuthorityPen,\n    authority_verifier: AuthorityVerifier,\n}\n\nimpl KeyBox {\n    pub fn new(authority_pen: AuthorityPen, authority_verifier: AuthorityVerifier) -\u003e Self {\n        let mut kb = Self {\n            authority_pen,\n            authority_verifier,\n        };\n        // Record the pen as a known authority -- always trust yourself\n        kb.record_authority(kb.authority_pen.index(), kb.authority_pen.public());\n        kb\n    }\n    pub fn record_authority(\u0026mut self, node_index: NodeIndex, public_key: PublicKey) {\n        self.authority_verifier.save(node_index, public_key);\n    }\n}\n\n#[async_trait]\nimpl aleph_bft::KeyBox for KeyBox {\n    type Signature = Signature;\n\n    fn node_count(\u0026self) -\u003e NodeCount {\n        self.authority_verifier.node_count()\n    }\n\n    async fn sign(\u0026self, msg: \u0026[u8]) -\u003e Self::Signature {\n        trace!(\"🖋️ {:?} signing message\", self.authority_pen.index());\n        self.authority_pen.sign(msg)\n    }\n\n    fn verify(\u0026self, msg: \u0026[u8], sgn: \u0026Self::Signature, index: NodeIndex) -\u003e bool {\n        trace!(\n            \"🔎 {:?} verifying message and signature from {:?}\",\n            self.authority_pen.index(),\n            index\n        );\n        self.authority_verifier.verify(msg, sgn, index)\n    }\n}\n\nimpl aleph_bft::MultiKeychain for KeyBox {\n    type PartialMultisignature = MultiSignature;\n\n    fn from_signature(\n        \u0026self,\n        signature: \u0026Signature,\n        index: NodeIndex,\n    ) -\u003e Self::PartialMultisignature {\n        MultiSignature::add_signature(\n            MultiSignature::with_size(self.authority_verifier.node_count()),\n            signature,\n            index,\n        )\n    }\n    fn is_complete(\u0026self, msg: \u0026[u8], partial: \u0026Self::PartialMultisignature) -\u003e bool {\n        self.authority_verifier.is_complete(msg, partial)\n    }\n}\n\nimpl aleph_bft::Index for KeyBox {\n    fn index(\u0026self) -\u003e NodeIndex {\n        self.authority_pen.index()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use aleph_bft::KeyBox as AlephKeyBox;\n    use libp2p::core::identity::ed25519::Keypair;\n\n    #[tokio::test]\n    async fn test_key_box_self_signed() {\n        let key_box = KeyBox::new(\n            AuthorityPen::new(0.into(), Keypair::generate()),\n            AuthorityVerifier::new(),\n        );\n        let sign: Signature = key_box.sign(b\"hello world!\").await;\n\n        assert_eq!(key_box.verify(b\"hello world\", \u0026sign, 0.into()), false);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","identities","verify_key.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse codec::{Decode, Encode, Error as CodecError, Input};\nuse libp2p::core::identity::ed25519::PublicKey;\nuse log::{debug, trace};\n\n// Convenience wrapper around a ed25519::PublicKey to support the parity scale coded required by aleph_bft\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct VerifyKey {\n    pub public: PublicKey,\n}\n\nimpl VerifyKey {\n    pub fn public(\u0026self) -\u003e PublicKey {\n        self.public.clone()\n    }\n}\n\nimpl Encode for VerifyKey {\n    fn using_encoded\u003cR, F: FnOnce(\u0026[u8]) -\u003e R\u003e(\u0026self, f: F) -\u003e R {\n        self.public().encode().using_encoded(f)\n    }\n\n    fn size_hint(\u0026self) -\u003e usize {\n        32\n    }\n}\n\nimpl Decode for VerifyKey {\n    fn decode\u003cI: Input\u003e(value: \u0026mut I) -\u003e Result\u003cSelf, CodecError\u003e {\n        let mut buf = [0u8; 32];\n        value.read(\u0026mut buf)?;\n        let public = PublicKey::decode(\u0026buf).map_err(|e| {\n            debug!(\"public key decode failed with: {:?}\", e);\n            trace!(\"Failed to decode public key: {}\", hex::encode(\u0026buf));\n            CodecError::from(\"public key decoded from_bytes\")\n        })?;\n        Ok(Self { public })\n    }\n}\n","traces":[{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":10},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","identities.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod authority_pen;\npub mod authority_verifier;\npub mod key_box;\npub mod verify_key;\nuse super::signature;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","lib.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod args;\npub mod blockchain;\npub mod crypto;\npub mod identities;\npub mod network;\npub mod providers;\npub mod signature;\npub mod structures;\n\nuse crate::network::NetworkData;\nuse crate::providers::DataStore;\nuse crate::structures::block::Block;\nuse crate::structures::header::Ordinal;\n\npub use aleph_bft::{default_config, run_session, NodeIndex};\nuse futures::{\n    channel::{\n        mpsc::{UnboundedReceiver, UnboundedSender},\n        oneshot,\n    },\n    FutureExt, StreamExt,\n};\nuse futures_timer::Delay;\nuse log::{debug, info, trace};\nuse std::sync::Mutex;\nuse std::{\n    sync::Arc,\n    time::{self, Duration},\n};\n\npub type BlockPlan = Arc\u003cdyn Fn(Ordinal) -\u003e NodeIndex + Sync + Send + 'static\u003e;\n\npub struct ChainConfig {\n    // Our NodeIndex.\n    pub node_ix: NodeIndex,\n    // Number of random bytes to include in the block.\n    pub data_size: usize,\n    // Delay between blocks\n    pub blocktime_ms: u128,\n    // Delay before the first block should be created\n    pub init_delay_ms: u128,\n    // f(k) means who should author the kth block\n    pub authorship_plan: BlockPlan,\n}\n\npub fn gen_chain_config(\n    node_ix: NodeIndex,\n    n_members: usize,\n    data_size: usize,\n    blocktime_ms: u128,\n    init_delay_ms: u128,\n) -\u003e ChainConfig {\n    //Round robin block authorship plan.\n    // let authorship_plan = Arc::new(move |num: u64| NodeIndex(((num as usize) % n_members) + 1));\n    let authorship_plan = Arc::new(move |num: u128| NodeIndex((num as usize) % n_members));\n    ChainConfig {\n        node_ix,\n        data_size,\n        blocktime_ms,\n        init_delay_ms,\n        authorship_plan,\n    }\n}\n\n// Runs a process that maintains a simple blockchain. The blocks are created every config.blocktime_ms\n// milliseconds and the block authors are determined by config.authorship_plan. The default config\n// uses round robin authorship: node k creates blocks number n if n%n_members = k.\n// A node will create a block n only if:\n// 1) it received the previous block (n-1)\n// 2) it is the nth block author\n// 3) enough time has passed -- to maintain blocktime of roughly config.blocktime_ms milliseconds.\n// This process holds two channel endpoints: block_rx to receive blocks from the network and\n// block_tx to push created blocks to the network (to send them to all the remaining nodes).\npub async fn run_blockchain(\n    config: ChainConfig,\n    mut data_store: DataStore,\n    current_block: Arc\u003cMutex\u003cBlock\u003e\u003e,\n    mut blocks_from_network: UnboundedReceiver\u003cBlock\u003e,\n    _blocks_for_network: UnboundedSender\u003cBlock\u003e,\n    mut messages_from_network: UnboundedReceiver\u003cNetworkData\u003e,\n    mut exit: oneshot::Receiver\u003c()\u003e,\n) {\n    let start_time = time::Instant::now();\n    for block_num in 1u128.. {\n        while current_block.lock().unwrap().header.ordinal \u003c block_num {\n            let curr_author = (config.authorship_plan)(block_num);\n            trace!(\"The current block author is {:?}\", curr_author);\n            if curr_author == config.node_ix {\n                // We need to create the block, but at the right time\n                info!(\n                    \"🔔 It's my turn to create a new block -- block_num {}\",\n                    block_num\n                );\n                let curr_time = time::Instant::now();\n                //TODO(prince-chrismc): This wants to be u64 so we need to do some magic here\n                let block_delay_ms = (block_num - 1) * config.blocktime_ms + config.init_delay_ms;\n                let block_creation_time =\n                    start_time + Duration::from_millis(block_delay_ms.try_into().unwrap());\n                if curr_time \u003e= block_creation_time {\n                    // TODO(prince-chrismc): Figure out how to generate new blocks and push them on the network\n                    // let block = Block::new(block_num, config.data_size);\n                    // blocks_for_network\n                    //     .unbounded_send(block)\n                    //     .expect(\"network should accept blocks\");\n                    info!(\"📝 Saving locally generated block\");\n                    // TODO(prince-chrismc): Generate blocks from \"known transactions\"\n                    // data_store.add_block(block_num);\n                }\n            }\n            // We tick every 125ms.\n            let mut delay_fut = Delay::new(Duration::from_millis(125)).fuse();\n\n            futures::select! {\n                maybe_block = blocks_from_network.next() =\u003e {\n                    if let Some(block) = maybe_block {\n                        info!(\"🧾 Adding new block {} from the network\", block.header.ordinal);\n                        data_store.add_block(block);\n                        //We drop the block at this point, only keep track of the fact that we received it.\n                    }\n                }\n                maybe_message = messages_from_network.next() =\u003e {\n                    if let Some(message) = maybe_message {\n                        trace!(\"recording new message from network\");\n                        data_store.add_message(message);\n                    }\n                }\n                _ = \u0026mut delay_fut =\u003e {\n                    //We do nothing, but this takes us out of the select.\n                }\n                _ = \u0026mut exit =\u003e {\n                    debug!(\"Received exit signal.\");\n                    return;\n                },\n            }\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","network.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse super::crypto::hash_algorithm::HashDigest;\nuse super::identities::verify_key::VerifyKey;\nuse super::signature::{MultiSignature, Signature};\nuse super::structures::block::Block;\n\nuse aleph_bft::{NodeIndex, Recipient, TaskHandle};\nuse codec::{Decode, Encode};\nuse futures::{\n    channel::{\n        mpsc::{self, UnboundedReceiver, UnboundedSender},\n        oneshot,\n    },\n    prelude::*,\n    Future, FutureExt, StreamExt,\n};\nuse libp2p::core::identity::ed25519::PublicKey;\nuse libp2p::{\n    core::upgrade,\n    identity,\n    mdns::{Mdns, MdnsEvent},\n    mplex, noise,\n    request_response::{\n        ProtocolSupport, RequestResponse, RequestResponseCodec, RequestResponseConfig,\n        RequestResponseEvent, RequestResponseMessage,\n    },\n    swarm::{NetworkBehaviourEventProcess, SwarmBuilder},\n    tcp::TokioTcpConfig,\n    NetworkBehaviour, PeerId, Swarm, Transport,\n};\nuse log::{debug, info, trace, warn};\nuse std::{collections::HashMap, error::Error, io, iter, time::Duration};\n\n#[derive(Clone)]\npub struct Spawner;\n\nimpl aleph_bft::SpawnHandle for Spawner {\n    fn spawn(\u0026self, _: \u0026str, task: impl Future\u003cOutput = ()\u003e + Send + 'static) {\n        tokio::spawn(task);\n    }\n    fn spawn_essential(\n        \u0026self,\n        _: \u0026str,\n        task: impl Future\u003cOutput = ()\u003e + Send + 'static,\n    ) -\u003e TaskHandle {\n        Box::pin(async move { tokio::spawn(task).await.map_err(|_| ()) })\n    }\n}\n\nconst PYRSIA_BLOCKCHAIN_PROTOCOL_NAME: \u0026str = \"/pyrsia/blockchain/1\";\n\npub type NetworkData = aleph_bft::NetworkData\u003cHashDigest, Block, Signature, MultiSignature\u003e;\n\n#[allow(clippy::large_enum_variant)]\n#[derive(Clone, Encode, Decode)]\nenum Message {\n    Auth(NodeIndex),\n    Consensus(NetworkData),\n    Block(Block),\n    PublicKey(NodeIndex, VerifyKey),\n}\n\n/// Implements the libp2p [`RequestResponseCodec`] trait.\n/// GenericCodec is a suitably adjusted version of the GenericCodec implemented in sc-network in substrate.\n/// Defines how streams of bytes are turned into requests and responses and vice-versa.\n#[derive(Debug, Clone)]\npub struct GenericCodec {}\n\ntype Request = Vec\u003cu8\u003e;\n// The Response type is empty -- we use RequestResponse just to send regular messages (requests).\ntype Response = ();\n\n#[async_trait::async_trait]\nimpl RequestResponseCodec for GenericCodec {\n    type Protocol = Vec\u003cu8\u003e;\n    type Request = Request;\n    type Response = Response;\n\n    async fn read_request\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026Self::Protocol,\n        mut io: \u0026mut T,\n    ) -\u003e io::Result\u003cSelf::Request\u003e\n    where\n        T: AsyncRead + Unpin + Send,\n    {\n        let length = unsigned_varint::aio::read_usize(\u0026mut io)\n            .await\n            .map_err(|err| io::Error::new(io::ErrorKind::InvalidInput, err))?;\n        let mut buffer = vec![0; length];\n        io.read_exact(\u0026mut buffer).await?;\n        Ok(buffer)\n    }\n\n    async fn read_response\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026Self::Protocol,\n        mut _io: \u0026mut T,\n    ) -\u003e io::Result\u003cSelf::Response\u003e\n    where\n        T: AsyncRead + Unpin + Send,\n    {\n        Ok(())\n    }\n\n    async fn write_request\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026Self::Protocol,\n        io: \u0026mut T,\n        req: Self::Request,\n    ) -\u003e io::Result\u003c()\u003e\n    where\n        T: AsyncWrite + Unpin + Send,\n    {\n        let mut buffer = unsigned_varint::encode::usize_buffer();\n        io.write_all(unsigned_varint::encode::usize(req.len(), \u0026mut buffer))\n            .await?;\n\n        io.write_all(\u0026req).await?;\n\n        io.close().await?;\n        Ok(())\n    }\n\n    async fn write_response\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026Self::Protocol,\n        _io: \u0026mut T,\n        _res: Self::Response,\n    ) -\u003e io::Result\u003c()\u003e\n    where\n        T: AsyncWrite + Unpin + Send,\n    {\n        Ok(())\n    }\n}\n\n#[derive(NetworkBehaviour)]\n#[behaviour(event_process = true)]\npub struct Behaviour {\n    mdns: Mdns,\n    rq_rp: RequestResponse\u003cGenericCodec\u003e,\n\n    #[behaviour(ignore)]\n    peers: Vec\u003cPeerId\u003e,\n    #[behaviour(ignore)]\n    peer_by_index: HashMap\u003cNodeIndex, PeerId\u003e,\n    #[behaviour(ignore)]\n    consensus_tx: mpsc::UnboundedSender\u003cNetworkData\u003e,\n    #[behaviour(ignore)]\n    block_tx: mpsc::UnboundedSender\u003cBlock\u003e,\n    #[behaviour(ignore)]\n    node_ix: NodeIndex,\n    #[behaviour(ignore)]\n    public_key: VerifyKey,\n    #[behaviour(ignore)]\n    new_authority_tx: UnboundedSender\u003c(NodeIndex, PublicKey)\u003e,\n}\n\nimpl Behaviour {\n    fn send_consensus_message(\u0026mut self, message: NetworkData, recipient: Recipient) {\n        let message: Vec\u003cu8\u003e = Message::Consensus(message).encode();\n        trace!(\"Dispatching consensus message: {}\", hex::encode(\u0026message));\n        use Recipient::*;\n        match recipient {\n            Node(node_ix) =\u003e {\n                if let Some(peer_id) = self.peer_by_index.get(\u0026node_ix) {\n                    self.rq_rp.send_request(peer_id, message);\n                } else {\n                    warn!(\"No peer_id known for node {:?}.\", node_ix);\n                }\n            }\n            Everyone =\u003e {\n                for peer_id in self.peers.iter() {\n                    self.rq_rp.send_request(peer_id, message.clone());\n                }\n            }\n        }\n    }\n\n    fn send_block_message(\u0026mut self, block: Block) {\n        info!(\"✈️ Sending block {}\", block.header.ordinal);\n        let message = Message::Block(block).encode();\n        for peer_id in self.peers.iter() {\n            self.rq_rp.send_request(peer_id, message.clone());\n        }\n    }\n}\n\nimpl NetworkBehaviourEventProcess\u003cMdnsEvent\u003e for Behaviour {\n    fn inject_event(\u0026mut self, event: MdnsEvent) {\n        if let MdnsEvent::Discovered(list) = event {\n            trace!(\"Processing discovery event with new list {:?}\", list);\n            let auth_message = Message::Auth(self.node_ix).encode();\n            let key_message = Message::PublicKey(self.node_ix, self.public_key.clone()).encode();\n            for (peer, _) in list {\n                if self.peers.iter().any(|p| *p == peer) {\n                    continue;\n                }\n                self.peers.push(peer);\n                trace!(\"Sending authentication message to {:?}\", peer);\n                self.rq_rp.send_request(\u0026peer, auth_message.clone());\n\n                trace!(\"Sending public key message to {:?}\", peer);\n                self.rq_rp.send_request(\u0026peer, key_message.clone());\n            }\n        }\n    }\n}\n\nimpl NetworkBehaviourEventProcess\u003cRequestResponseEvent\u003cRequest, Response\u003e\u003e for Behaviour {\n    fn inject_event(\u0026mut self, event: RequestResponseEvent\u003cRequest, Response\u003e) {\n        if let RequestResponseEvent::Message {\n            peer: peer_id,\n            message,\n        } = event\n        {\n            match message {\n                RequestResponseMessage::Request {\n                    request_id: _,\n                    request,\n                    channel: _,\n                } =\u003e {\n                    if !self.peers.iter().any(|p| *p == peer_id) {\n                        info!(\"An unknown {:?} has sent us a message!\", peer_id);\n                        self.peers.push(peer_id);\n\n                        trace!(\"Sending authentication message to {:?}\", peer_id);\n                        let auth_message = Message::Auth(self.node_ix).encode();\n                        self.rq_rp.send_request(\u0026peer_id, auth_message);\n\n                        trace!(\"Sending public key message to {:?}\", peer_id);\n                        let key_message =\n                            Message::PublicKey(self.node_ix, self.public_key.clone()).encode();\n                        self.rq_rp.send_request(\u0026peer_id, key_message);\n                    }\n\n                    let result = Message::decode(\u0026mut \u0026request[..]);\n                    match result {\n                        Err(e) =\u003e warn!(\n                            \"Failed to decode inbound request as Message: {} -- {}\",\n                            e,\n                            hex::encode(\u0026request)\n                        ),\n                        Ok(message) =\u003e match message {\n                            Message::Consensus(msg) =\u003e {\n                                debug!(\"📌 New consensus message: {:?}\", msg);\n\n                                self.consensus_tx\n                                    .unbounded_send(msg)\n                                    .expect(\"Network must listen\");\n                            }\n                            Message::Auth(node_ix) =\u003e {\n                                debug!(\"🖇️ Authenticated peer: {:?} {:?}\", node_ix, peer_id);\n\n                                if self.peer_by_index.get(\u0026node_ix).is_none() {\n                                    trace!(\"Sending authentication message to {:?}\", peer_id);\n                                    let auth_message = Message::Auth(self.node_ix).encode();\n                                    self.rq_rp.send_request(\u0026peer_id, auth_message);\n\n                                    trace!(\"Sending public key message to {:?}\", peer_id);\n                                    let key_message =\n                                        Message::PublicKey(self.node_ix, self.public_key.clone())\n                                            .encode();\n                                    self.rq_rp.send_request(\u0026peer_id, key_message);\n                                }\n\n                                self.peer_by_index.insert(node_ix, peer_id);\n                            }\n                            Message::Block(block) =\u003e {\n                                debug!(\n                                    \"Received block num {:?} from {:?}\",\n                                    block.header.ordinal, peer_id\n                                );\n                                self.block_tx\n                                    .unbounded_send(block)\n                                    .expect(\"Blockchain process must listen\");\n                            }\n                            Message::PublicKey(node_ix, key) =\u003e {\n                                debug!(\"📑 Received a new public key from {:?}\", node_ix);\n                                self.new_authority_tx\n                                    .unbounded_send((node_ix, key.public()))\n                                    .expect(\"PublicKey process must listen\");\n                            }\n                        }, // We do not send back a response to a request. We treat them simply as one-way messages.}\n                    }\n                }\n                RequestResponseMessage::Response { .. } =\u003e {\n                    //We ignore the response, as it is empty anyway.\n                }\n            }\n        }\n    }\n}\n\npub struct Network {\n    msg_to_manager_tx: mpsc::UnboundedSender\u003c(NetworkData, Recipient)\u003e,\n    msg_from_manager_rx: mpsc::UnboundedReceiver\u003cNetworkData\u003e,\n}\n\n#[async_trait::async_trait]\nimpl aleph_bft::Network\u003cHashDigest, Block, Signature, MultiSignature\u003e for Network {\n    fn send(\u0026self, data: NetworkData, recipient: Recipient) {\n        trace!(\"Sending a message to: {:?}\", recipient);\n        if let Err(e) = self.msg_to_manager_tx.unbounded_send((data, recipient)) {\n            warn!(\"Failed network send: {:?}\", e);\n        }\n    }\n    async fn next_event(\u0026mut self) -\u003e Option\u003cNetworkData\u003e {\n        let msg = self.msg_from_manager_rx.next().await;\n        msg.map(|m| {\n            trace!(\n                \"New event received of network data {}\",\n                hex::encode(m.encode())\n            );\n            m\n        })\n    }\n}\n\npub struct NetworkManager {\n    swarm: Swarm\u003cBehaviour\u003e,\n    consensus_rx: UnboundedReceiver\u003c(NetworkData, Recipient)\u003e,\n    block_rx: UnboundedReceiver\u003cBlock\u003e,\n}\n\nimpl Network {\n    pub async fn new(\n        node_ix: NodeIndex,\n        key_pair: identity::ed25519::Keypair,\n        peer_by_index: HashMap\u003cNodeIndex, PeerId\u003e,\n        new_authority_tx: UnboundedSender\u003c(NodeIndex, PublicKey)\u003e,\n    ) -\u003e Result\u003c\n        (\n            Self,\n            NetworkManager,\n            UnboundedSender\u003cBlock\u003e,\n            UnboundedReceiver\u003cBlock\u003e,\n            UnboundedSender\u003cNetworkData\u003e,\n            UnboundedReceiver\u003cNetworkData\u003e,\n        ),\n        Box\u003cdyn Error\u003e,\n    \u003e {\n        let local_key: identity::Keypair = identity::Keypair::Ed25519(key_pair.clone());\n        let public_key: libp2p::identity::ed25519::PublicKey = key_pair.public();\n        let local_peer_id = PeerId::from(local_key.public());\n        info!(\"Local peer id: {:?}\", local_peer_id);\n\n        // Create a keypair for authenticated encryption of the transport.\n        let noise_keys = noise::Keypair::\u003cnoise::X25519Spec\u003e::new()\n            .into_authentic(\u0026local_key)\n            .expect(\"Signing libp2p-noise static DH keypair failed.\");\n\n        // Create a tokio-based TCP transport use noise for authenticated\n        // encryption and Mplex for multiplexing of substreams on a TCP stream.\n        let transport = TokioTcpConfig::new()\n            .nodelay(true)\n            .upgrade(upgrade::Version::V1)\n            .authenticate(noise::NoiseConfig::xx(noise_keys).into_authenticated())\n            .multiplex(mplex::MplexConfig::new())\n            .boxed();\n\n        let (msg_to_manager_tx, msg_to_manager_rx) = mpsc::unbounded();\n        let (msg_for_store, msg_from_manager) = mpsc::unbounded();\n        let (msg_for_network, msg_from_store) = mpsc::unbounded();\n        let (block_to_data_io_tx, block_to_data_io_rx) = mpsc::unbounded();\n        let (block_from_data_io_tx, block_from_data_io_rx) = mpsc::unbounded();\n        let mut swarm = {\n            let mut rr_cfg = RequestResponseConfig::default();\n            rr_cfg.set_connection_keep_alive(Duration::from_secs(10));\n            rr_cfg.set_request_timeout(Duration::from_secs(4));\n            let protocol_support = ProtocolSupport::Full;\n            let rq_rp = RequestResponse::new(\n                GenericCodec {},\n                iter::once((\n                    PYRSIA_BLOCKCHAIN_PROTOCOL_NAME.as_bytes().to_vec(),\n                    protocol_support,\n                )),\n                rr_cfg,\n            );\n\n            let mdns = Mdns::new(Default::default()).await?;\n            let behaviour = Behaviour {\n                rq_rp,\n                mdns,\n                peers: vec![],\n                peer_by_index,\n                consensus_tx: msg_for_store,\n                block_tx: block_to_data_io_tx,\n                node_ix,\n                public_key: VerifyKey { public: public_key },\n                new_authority_tx,\n            };\n            SwarmBuilder::new(transport, behaviour, local_peer_id)\n                .executor(Box::new(|fut| {\n                    tokio::spawn(fut);\n                }))\n                .build()\n        };\n\n        swarm.listen_on(\"/ip4/0.0.0.0/tcp/0\".parse()?)?;\n\n        let network = Network {\n            msg_to_manager_tx,\n            msg_from_manager_rx: msg_from_store,\n        };\n\n        let network_manager = NetworkManager {\n            swarm,\n            consensus_rx: msg_to_manager_rx,\n            block_rx: block_from_data_io_rx,\n        };\n\n        Ok((\n            network,\n            network_manager,\n            block_from_data_io_tx,\n            block_to_data_io_rx,\n            msg_for_network,\n            msg_from_manager,\n        ))\n    }\n}\n\nimpl NetworkManager {\n    pub async fn run(\u0026mut self, mut exit: oneshot::Receiver\u003c()\u003e) {\n        loop {\n            futures::select! {\n                maybe_msg = self.consensus_rx.next() =\u003e {\n                    if let Some((consensus_msg, recipient)) = maybe_msg {\n                        let handle = \u0026mut self.swarm.behaviour_mut();\n                        handle.send_consensus_message(consensus_msg, recipient);\n                    }\n                }\n                maybe_block = self.block_rx.next() =\u003e {\n                    if let Some(block) = maybe_block {\n                        let handle = \u0026mut self.swarm.behaviour_mut();\n                        handle.send_block_message(block);\n                    }\n                }\n                event = self.swarm.next().fuse() =\u003e {\n                    match event {\n                        Some(event) =\u003e {\n                            trace!(\"Received a swarm event: {:?}\", event);\n                        }\n                        None =\u003e {\n                            panic!(\"Swarm stream ended\");\n                        }\n                    }\n                }\n               _ = \u0026mut exit  =\u003e break,\n            }\n        }\n    }\n}\n","traces":[{"line":102,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":14},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","providers.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse super::{network::NetworkData, structures::block::Block, structures::header::Ordinal};\nuse async_trait::async_trait;\nuse futures::channel::{\n    mpsc,\n    mpsc::{UnboundedReceiver, UnboundedSender},\n};\nuse log::{debug, error};\nuse std::{\n    collections::{HashMap, HashSet},\n    sync::{Arc, Mutex},\n};\n\npub struct DataStore {\n    next_message_id: u32,\n    current_block: Arc\u003cMutex\u003cBlock\u003e\u003e,\n    available_blocks: HashSet\u003cOrdinal\u003e,\n    message_requirements: HashMap\u003cu32, usize\u003e,\n    dependent_messages: HashMap\u003cBlock, Vec\u003cu32\u003e\u003e,\n    pending_messages: HashMap\u003cu32, NetworkData\u003e,\n    messages_for_member: UnboundedSender\u003cNetworkData\u003e,\n}\n\nimpl DataStore {\n    pub fn new(\n        current_block: Arc\u003cMutex\u003cBlock\u003e\u003e,\n        messages_for_member: UnboundedSender\u003cNetworkData\u003e,\n    ) -\u003e Self {\n        let available_blocks = (0..=current_block.lock().unwrap().header.ordinal).collect();\n        DataStore {\n            next_message_id: 0,\n            current_block,\n            available_blocks,\n            message_requirements: HashMap::new(),\n            dependent_messages: HashMap::new(),\n            pending_messages: HashMap::new(),\n            messages_for_member,\n        }\n    }\n\n    fn add_pending_message(\u0026mut self, message: NetworkData, requirements: Vec\u003cBlock\u003e) {\n        let message_id = self.next_message_id;\n        // Whatever test you are running should end before this becomes a problem.\n        self.next_message_id += 1;\n        for block in requirements.iter() {\n            self.dependent_messages\n                .entry(block.clone())\n                .or_insert_with(Vec::new)\n                .push(message_id);\n        }\n        self.message_requirements\n            .insert(message_id, requirements.len());\n        self.pending_messages.insert(message_id, message);\n    }\n\n    pub fn add_message(\u0026mut self, message: NetworkData) {\n        let requirements: Vec\u003c_\u003e = message\n            .included_data()\n            .into_iter()\n            .filter(|b| !self.available_blocks.contains(\u0026b.header.ordinal))\n            .collect();\n        if requirements.is_empty() {\n            self.messages_for_member\n                .unbounded_send(message)\n                .expect(\"member accept messages\");\n        } else {\n            self.add_pending_message(message, requirements.into_iter().collect());\n        }\n    }\n\n    fn push_messages(\u0026mut self, block: Block) {\n        for message_id in self\n            .dependent_messages\n            .entry(block.clone())\n            .or_insert_with(Vec::new)\n            .iter()\n        {\n            *self\n                .message_requirements\n                .get_mut(message_id)\n                .expect(\"there are some requirements\") -= 1;\n            if self.message_requirements[message_id] == 0 {\n                let message = self\n                    .pending_messages\n                    .remove(message_id)\n                    .expect(\"there is a pending message\");\n                self.messages_for_member\n                    .unbounded_send(message)\n                    .expect(\"member accept messages\");\n                self.message_requirements.remove(message_id);\n            }\n        }\n        self.dependent_messages.remove(\u0026block);\n    }\n\n    pub fn add_block(\u0026mut self, block: Block) {\n        debug!(\"Added block {:?}.\", block);\n        self.available_blocks.insert(block.header.ordinal);\n        self.push_messages(block);\n        while self\n            .available_blocks\n            .contains(\u0026(self.current_block.lock().unwrap().header.ordinal + 1))\n        {\n            self.current_block.lock().unwrap().header.ordinal += 1;\n        }\n        debug!(\"Updated chain {:?}\", self.available_blocks);\n    }\n}\n\n#[derive(Clone)]\npub struct DataProvider {\n    current_block: Arc\u003cMutex\u003cBlock\u003e\u003e,\n}\n\n#[async_trait]\nimpl aleph_bft::DataProvider\u003cBlock\u003e for DataProvider {\n    async fn get_data(\u0026mut self) -\u003e Block {\n        self.current_block.lock().unwrap().clone()\n    }\n}\n\nimpl DataProvider {\n    // TODO(prince-chrismc): Initial Block?\n    pub fn new(initial_block: Arc\u003cMutex\u003cBlock\u003e\u003e) -\u003e Self {\n        DataProvider {\n            current_block: initial_block,\n        }\n    }\n}\n\npub struct FinalizationProvider {\n    tx: UnboundedSender\u003cBlock\u003e,\n}\n\n#[async_trait]\nimpl aleph_bft::FinalizationHandler\u003cBlock\u003e for FinalizationProvider {\n    async fn data_finalized(\u0026mut self, d: Block) {\n        if let Err(e) = self.tx.unbounded_send(d) {\n            error!(\"Error when sending data from FinalizationProvider {:?}.\", e);\n        }\n    }\n}\n\nimpl FinalizationProvider {\n    pub fn new() -\u003e (Self, UnboundedReceiver\u003cBlock\u003e) {\n        let (tx, rx) = mpsc::unbounded();\n\n        (Self { tx }, rx)\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","signature.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse aleph_bft::SignatureSet;\nuse codec::{Decode, Encode};\nuse libp2p::core::identity::ed25519::Keypair;\nuse serde::{Deserialize, Serialize};\nuse std::hash::{Hash, Hasher};\n\npub type Error = ed25519_dalek::SignatureError;\n\n#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Eq, Decode)]\npub struct Signature {\n    #[codec(encoded_as = \"[u8; ed25519_dalek::Signature::BYTE_SIZE]\")]\n    signature: ed25519_dalek::Signature,\n}\n\n#[allow(clippy::derive_hash_xor_eq)] // https://github.com/rust-lang/rust-clippy/issues/7666\nimpl Hash for Signature {\n    fn hash\u003cH: Hasher\u003e(\u0026self, state: \u0026mut H) {\n        self.signature.to_bytes().hash(state);\n    }\n}\n\nimpl Signature {\n    pub fn from_bytes(msg: \u0026[u8]) -\u003e Result\u003cSelf, Error\u003e {\n        let sig = ed25519_dalek::Signature::from_bytes(msg)?;\n        Ok(Self { signature: sig })\n    }\n    pub fn to_bytes(self) -\u003e [u8; ed25519_dalek::Signature::BYTE_SIZE] {\n        self.signature.to_bytes()\n    }\n    pub fn new(msg: \u0026[u8], keypair: \u0026Keypair) -\u003e Self {\n        let signed: Vec\u003cu8\u003e = keypair.sign(msg);\n        Signature::from_bytes(\u0026signed).expect(\"signed data should always be valid\")\n    }\n}\n\nimpl Encode for Signature {\n    fn using_encoded\u003cR, F: FnOnce(\u0026[u8]) -\u003e R\u003e(\u0026self, f: F) -\u003e R {\n        self.signature.to_bytes().using_encoded(f)\n    }\n\n    fn size_hint(\u0026self) -\u003e usize {\n        ed25519_dalek::Signature::BYTE_SIZE\n    }\n}\n\npub type MultiSignature = SignatureSet\u003cSignature\u003e;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_signature_encode() {\n        let bytes: [u8; ed25519_dalek::Signature::BYTE_SIZE] = [\n            0x6d, 0xd3, 0x55, 0x66, 0x7f, 0xae, 0x4e, 0xb4, 0x3c, 0x6e, 0x0a, 0xb9, 0x2e, 0x87,\n            0x0e, 0xdb, 0x2d, 0xe0, 0xa8, 0x8c, 0xae, 0x12, 0xdb, 0xd8, 0x59, 0x15, 0x07, 0xf5,\n            0x84, 0xfe, 0x49, 0x12, 0xba, 0xbf, 0xf4, 0x97, 0xf1, 0xb8, 0xed, 0xf9, 0x56, 0x7d,\n            0x24, 0x83, 0xd5, 0x4d, 0xdc, 0x64, 0x59, 0xbe, 0xa7, 0x85, 0x52, 0x81, 0xb7, 0xa2,\n            0x46, 0xa6, 0x09, 0xe3, 0x00, 0x1a, 0x4e, 0x08,\n        ];\n        let sign = Signature::from_bytes(\u0026bytes).unwrap();\n        println!(\"{:?}\", sign.encode());\n\n        assert_eq!(\n            sign.encode(),\n            vec![\n                109, 211, 85, 102, 127, 174, 78, 180, 60, 110, 10, 185, 46, 135, 14, 219, 45, 224,\n                168, 140, 174, 18, 219, 216, 89, 21, 7, 245, 132, 254, 73, 18, 186, 191, 244, 151,\n                241, 184, 237, 249, 86, 125, 36, 131, 213, 77, 220, 100, 89, 190, 167, 133, 82,\n                129, 183, 162, 70, 166, 9, 227, 0, 26, 78, 8\n            ]\n        );\n    }\n\n    #[test]\n    fn test_signature_decode() {\n        let bytes: [u8; ed25519_dalek::Signature::BYTE_SIZE] = [\n            0x6d, 0xd3, 0x55, 0x66, 0x7f, 0xae, 0x4e, 0xb4, 0x3c, 0x6e, 0x0a, 0xb9, 0x2e, 0x87,\n            0x0e, 0xdb, 0x2d, 0xe0, 0xa8, 0x8c, 0xae, 0x12, 0xdb, 0xd8, 0x59, 0x15, 0x07, 0xf5,\n            0x84, 0xfe, 0x49, 0x12, 0xba, 0xbf, 0xf4, 0x97, 0xf1, 0xb8, 0xed, 0xf9, 0x56, 0x7d,\n            0x24, 0x83, 0xd5, 0x4d, 0xdc, 0x64, 0x59, 0xbe, 0xa7, 0x85, 0x52, 0x81, 0xb7, 0xa2,\n            0x46, 0xa6, 0x09, 0xe3, 0x00, 0x1a, 0x4e, 0x08,\n        ];\n        let expected = Signature::from_bytes(\u0026bytes).unwrap();\n\n        let mut da: \u0026[u8] = \u0026bytes;\n        let sign = Signature::decode(\u0026mut da);\n\n        assert_eq!(sign.ok(), Some(expected));\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","structures","block.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse codec::{Decode, Encode};\nuse libp2p::identity;\nuse serde::{Deserialize, Serialize};\nuse std::cmp::Ordering;\nuse std::fmt::{Display, Formatter};\n\nuse super::header::{Address, Header};\nuse super::transaction::Transaction;\nuse crate::crypto::hash_algorithm::HashDigest;\nuse crate::signature::Signature;\n\npub type BlockSignature = Signature;\n\n#[derive(Serialize, Deserialize, Debug, Clone, Eq, PartialEq, Decode, Encode, Hash)]\npub struct Block {\n    pub header: Header,\n    // TODO(fishseabowl): Should be a Merkle Tree to speed up validation with root hash\n    pub transactions: Vec\u003cTransaction\u003e,\n    signature: BlockSignature,\n}\n\nimpl Block {\n    pub fn new(\n        parent_hash: HashDigest,\n        ordinal: u128,\n        transactions: Vec\u003cTransaction\u003e,\n        signing_key: \u0026identity::ed25519::Keypair,\n    ) -\u003e Self {\n        let transaction_root = HashDigest::new(\u0026bincode::serialize(\u0026transactions).unwrap());\n        let header = Header::new(\n            parent_hash,\n            transaction_root,\n            Address::from(identity::PublicKey::Ed25519(signing_key.public())),\n            ordinal,\n        );\n        Self {\n            header,\n            transactions,\n            signature: Signature::new(\u0026bincode::serialize(\u0026header.hash()).unwrap(), signing_key),\n        }\n    }\n\n    pub fn signature(\u0026self) -\u003e BlockSignature {\n        self.signature.clone()\n    }\n\n    // After merging Aleph consensus algorithm, it would be implemented\n    pub fn verify(\u0026self) -\u003e bool {\n        true\n    }\n}\n\nimpl PartialOrd for Block {\n    fn partial_cmp(\u0026self, other: \u0026Self) -\u003e Option\u003cOrdering\u003e {\n        self.header.ordinal.partial_cmp(\u0026other.header.ordinal)\n    }\n}\n\nimpl Display for Block {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let json = serde_json::to_string_pretty(\u0026self).expect(\"json format error\");\n        write!(f, \"{}\", json)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n\n    use super::super::transaction::TransactionType;\n    use super::*;\n\n    #[test]\n    fn test_build_block() -\u003e Result\u003c(), String\u003e {\n        let keypair = identity::ed25519::Keypair::generate();\n        let local_id = Address::from(identity::PublicKey::Ed25519(keypair.public()));\n\n        let transactions = vec![Transaction::new(\n            TransactionType::Create,\n            local_id,\n            b\"Hello First Transaction\".to_vec(),\n            \u0026keypair,\n        )];\n        let block = Block::new(HashDigest::new(b\"\"), 1, transactions.to_vec(), \u0026keypair);\n        let expected_signature =\n            Signature::new(\u0026bincode::serialize(\u0026block.header.hash()).unwrap(), \u0026keypair);\n\n        assert_eq!(1, block.header.ordinal);\n        assert_eq!(expected_signature, block.signature());\n        Ok(())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","structures","chain.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse codec::{Decode, Encode};\nuse serde::{Deserialize, Serialize};\n\nuse super::block::Block;\n\n#[derive(Serialize, Deserialize, Debug, Default, Clone, Decode, Encode, Hash, PartialEq, Eq)]\npub struct Chain {\n    // TODO(prince-chrismc): This eventually needs to be an ordered set so block sequence is always sorted by ordinal\n    pub blocks: Vec\u003cBlock\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","structures","header.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse codec::{Decode, Encode};\nuse libp2p::{identity, PeerId};\nuse multihash::Multihash;\nuse rand::Rng;\nuse serde::{Deserialize, Serialize};\nuse std::time::{SystemTime, UNIX_EPOCH};\n\nuse crate::crypto::hash_algorithm::HashDigest;\n\n#[derive(Serialize, Deserialize, Debug, Clone, Hash, PartialEq, Eq, Copy, Decode, Encode)]\npub struct Address {\n    // This can not be libp2p's PeerId as it is missing the SCALE codec support for Aleph,\n    // internally it's a https://github.com/libp2p/rust-libp2p/blob/6cc3b4ec52c922bfcf562a29b5805c3150e37c75/core/src/peer_id.rs#L40\n    // So we will stick with that.\n    peer_id: Multihash,\n}\n\nimpl From\u003cidentity::PublicKey\u003e for Address {\n    fn from(key: identity::PublicKey) -\u003e Address {\n        Self {\n            peer_id: PeerId::from_public_key(\u0026key).into(),\n        }\n    }\n}\n\nimpl From\u003cPeerId\u003e for Address {\n    fn from(peer_id: PeerId) -\u003e Address {\n        Self {\n            peer_id: peer_id.into(),\n        }\n    }\n}\n\npub type Ordinal = u128;\n\n// this struct exists only for generating a hash\n#[derive(Serialize)]\nstruct PartialHeader {\n    parent_hash: HashDigest,\n    transactions_hash: HashDigest,\n    committer: Address,\n    timestamp: u64,\n    ordinal: Ordinal,\n    nonce: u128,\n}\n\nimpl From\u003cHeader\u003e for PartialHeader {\n    fn from(header: Header) -\u003e Self {\n        PartialHeader {\n            parent_hash: header.parent_hash,\n            transactions_hash: header.transactions_hash,\n            committer: header.committer,\n            timestamp: header.timestamp,\n            ordinal: header.ordinal,\n            nonce: header.nonce,\n        }\n    }\n}\n\nfn calculate_hash(incomplete_header: \u0026PartialHeader) -\u003e Result\u003cHashDigest, bincode::Error\u003e {\n    let bytes = bincode::serialize(incomplete_header)?;\n    Ok(HashDigest::new(\u0026bytes))\n}\n\n/// struct Header define the header of a block\n#[derive(Serialize, Deserialize, Debug, Clone, Hash, PartialEq, Eq, Copy, Decode, Encode)]\npub struct Header {\n    /// 256-bit Keccak Hash of the parent block (previous [`Block`][block]'s [`hash`][hash])\n    ///\n    /// [block]: crate::structures::block::Block\n    /// [hash]: crate::structures::header::Header::hash\n    pub parent_hash: HashDigest,\n    /// 256-bit Keccak Hash of the [`Block`][block]'s [`transactions`][transactions]\n    ///\n    /// [block]: crate::structures::block::Block\n    /// [transactions]: crate::structures::block::Block::transactions\n    pub transactions_hash: HashDigest,\n    /// the committer node's PeerId\n    pub committer: Address,\n    /// Unix timestamp in seconds, see \u003chttps://en.wikipedia.org/wiki/Unix_time\u003e for more.\n    pub timestamp: u64,\n    /// block sequence number, the current block number should be the parent (previous) block number plus 1\n    pub ordinal: Ordinal,\n    /// Adds a salt to harden\n    nonce: u128,\n    /// The block id, 256-bit Keccak Hash of the Current Block Header, excluding itself\n    hash: HashDigest,\n}\n\nimpl Header {\n    pub fn new(\n        parent_hash: HashDigest,\n        transactions_hash: HashDigest,\n        committer: Address,\n        ordinal: u128,\n    ) -\u003e Self {\n        let partial = PartialHeader {\n            parent_hash,\n            transactions_hash,\n            committer,\n            timestamp: SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            ordinal,\n            nonce: rand::thread_rng().gen::\u003cu128\u003e(),\n        };\n        Self {\n            parent_hash: partial.parent_hash,\n            transactions_hash: partial.transactions_hash,\n            committer: partial.committer,\n            timestamp: partial.timestamp,\n            ordinal: partial.ordinal,\n            nonce: partial.nonce,\n            hash: calculate_hash(\u0026partial).unwrap(),\n        }\n    }\n\n    pub fn hash(\u0026self) -\u003e HashDigest {\n        self.hash\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use libp2p::identity;\n\n    #[test]\n    fn test_build_block_header() {\n        let keypair = identity::ed25519::Keypair::generate();\n        let local_id = Address::from(identity::PublicKey::Ed25519(keypair.public()));\n\n        let header = Header::new(HashDigest::new(b\"\"), HashDigest::new(b\"\"), local_id, 5);\n\n        let partial: PartialHeader = header.clone().into();\n        let expected_hash = calculate_hash(\u0026partial).unwrap();\n\n        assert_eq!(5, header.ordinal);\n        assert_eq!(expected_hash, header.hash());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","structures","transaction.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse codec::{Decode, Encode};\nuse libp2p::identity;\nuse rand::Rng;\nuse serde::{Deserialize, Serialize};\nuse std::time::{SystemTime, UNIX_EPOCH};\n\nuse super::header::Address;\nuse crate::crypto::hash_algorithm::HashDigest;\nuse crate::signature::Signature;\n\n#[derive(Serialize, Deserialize, Debug, Clone, Hash, PartialEq, Eq, Copy, Decode, Encode)]\npub enum TransactionType {\n    Create,\n    AddAuthority,\n    RevokeAuthority,\n}\n\n// Temporary structure to be able to calculate the hash of a transaction\n#[derive(Serialize)]\nstruct PartialTransaction {\n    type_id: TransactionType,\n    submitter: Address,\n    timestamp: u64,\n    payload: Vec\u003cu8\u003e,\n    nonce: u128,\n}\n\nimpl PartialTransaction {\n    fn convert_to_transaction(\n        self,\n        ed25519_keypair: \u0026identity::ed25519::Keypair,\n    ) -\u003e Result\u003cTransaction, bincode::Error\u003e {\n        let hash = calculate_hash(\u0026self)?;\n        Ok(Transaction {\n            type_id: self.type_id,\n            submitter: self.submitter,\n            timestamp: self.timestamp,\n            payload: self.payload,\n            nonce: self.nonce,\n            hash,\n            signature: Signature::new(\u0026bincode::serialize(\u0026hash)?, ed25519_keypair),\n        })\n    }\n}\n\nimpl From\u003cTransaction\u003e for PartialTransaction {\n    fn from(transaction: Transaction) -\u003e Self {\n        PartialTransaction {\n            type_id: transaction.type_id,\n            submitter: transaction.submitter,\n            timestamp: transaction.timestamp,\n            payload: transaction.payload,\n            nonce: transaction.nonce,\n        }\n    }\n}\n\nfn calculate_hash(\n    incomplete_transaction: \u0026PartialTransaction,\n) -\u003e Result\u003cHashDigest, bincode::Error\u003e {\n    let bytes = bincode::serialize(incomplete_transaction)?;\n    Ok(HashDigest::new(\u0026bytes))\n}\n\npub type TransactionSignature = Signature;\n\n#[derive(Serialize, Deserialize, Debug, Clone, Hash, PartialEq, Eq, Decode, Encode)]\npub struct Transaction {\n    type_id: TransactionType,\n    submitter: Address,\n    timestamp: u64,\n    payload: Vec\u003cu8\u003e,\n    nonce: u128, // Adds a salt to harden\n    hash: HashDigest,\n    signature: TransactionSignature,\n}\nimpl Transaction {\n    pub fn new(\n        type_id: TransactionType,\n        submitter: Address,\n        payload: Vec\u003cu8\u003e,\n        ed25519_keypair: \u0026identity::ed25519::Keypair,\n    ) -\u003e Self {\n        let partial_transaction = PartialTransaction {\n            type_id,\n            submitter,\n            timestamp: SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            payload,\n            nonce: rand::thread_rng().gen::\u003cu128\u003e(),\n        };\n        partial_transaction\n            .convert_to_transaction(ed25519_keypair)\n            .unwrap()\n    }\n    pub fn hash(\u0026self) -\u003e HashDigest {\n        self.hash\n    }\n    pub fn signature(\u0026self) -\u003e TransactionSignature {\n        self.signature.clone()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_transaction_new() {\n        let keypair = identity::ed25519::Keypair::generate();\n        let local_id = Address::from(identity::PublicKey::Ed25519(keypair.public()));\n\n        let transaction = Transaction::new(\n            TransactionType::Create,\n            local_id,\n            b\"Hello First Transaction\".to_vec(),\n            \u0026keypair,\n        );\n        let partial: PartialTransaction = transaction.clone().into();\n        let expected_hash = calculate_hash(\u0026partial).unwrap();\n        let expected_signature =\n            Signature::new(\u0026bincode::serialize(\u0026expected_hash).unwrap(), \u0026keypair);\n\n        assert_eq!(expected_hash, transaction.hash());\n        assert_eq!(expected_signature, transaction.signature());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","blockchain","src","structures.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod block;\npub mod chain;\npub mod header;\npub mod transaction;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","build_service","service.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub struct BuildService {}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","build_service.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod service;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","cli_commands","config.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse anyhow::Result;\nuse serde::{Deserialize, Serialize};\nuse std::fmt::{Display, Formatter};\n\nconst CONF_FILE: \u0026str = \"pyrsia-cli\";\n\n#[derive(Clone, Debug, Serialize, Deserialize)]\npub struct CliConfig {\n    pub host: String,\n    pub port: String,\n    pub disk_allocated: String,\n}\n\nimpl Default for CliConfig {\n    fn default() -\u003e Self {\n        CliConfig {\n            host: \"localhost\".to_string(),\n            port: \"7888\".to_string(),\n            disk_allocated: \"5.84 GB\".to_string(),\n        }\n    }\n}\n\nimpl Display for CliConfig {\n    fn fmt(\u0026self, f: \u0026mut Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        let config_toml = toml::to_string_pretty(\u0026self).expect(\"toml format error\");\n        write!(f, \"{}\", config_toml)\n    }\n}\n\npub fn add_config(new_cfg: CliConfig) -\u003e Result\u003c()\u003e {\n    let mut cfg: CliConfig = confy::load(CONF_FILE)?;\n    if !new_cfg.host.is_empty() {\n        cfg.host = new_cfg.host\n    }\n\n    if !new_cfg.port.is_empty() {\n        cfg.port = new_cfg.port\n    }\n    // need more validation for checking units\n    if !new_cfg.disk_allocated.is_empty() {\n        cfg.disk_allocated = new_cfg.disk_allocated\n    }\n\n    confy::store(CONF_FILE, \u0026cfg)?;\n\n    Ok(())\n}\n\npub fn get_config() -\u003e Result\u003cCliConfig\u003e {\n    let cfg: CliConfig = confy::load(CONF_FILE)?;\n\n    Ok(cfg)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use assay::assay;\n    use directories::ProjectDirs;\n    use std::path::PathBuf;\n\n    fn tear_down() {\n        let config_dir_str = get_configuration_directory();\n\n        let path: PathBuf = [\n            config_dir_str.to_owned(),\n            format!(\"{}.toml\", CONF_FILE.to_owned()),\n        ]\n        .iter()\n        .collect();\n\n        if path.exists() {\n            std::fs::remove_dir_all(path.parent().unwrap()).expect(\"Failed to remove directory\");\n        }\n    }\n\n    #[assay(teardown = tear_down())]\n    fn test_config_file_update() {\n        let cfg: CliConfig = get_config().expect(\"could not get conf file\");\n        let cfg2: CliConfig = CliConfig {\n            port: \"7888\".to_string(),\n            ..cfg.clone()\n        };\n        let cfg3: CliConfig = CliConfig {\n            port: \"7878\".to_string(),\n            ..cfg.clone()\n        };\n\n        add_config(cfg2.clone()).expect(\"could not update conf file\");\n        assert_eq!(cfg2.port, \"7888\".to_string());\n        add_config(cfg3).expect(\"could not update conf file\");\n        let new_cfg: CliConfig = get_config().expect(\"could not get conf file\");\n        assert_eq!(new_cfg.port, \"7878\".to_string());\n    }\n\n    fn get_configuration_directory() -\u003e String {\n        let project = ProjectDirs::from(\"rs\", \"\", CONF_FILE).expect(\"bad config dir\");\n\n        let config_dir_option = project.config_dir().to_str();\n\n        if let Some(x) = config_dir_option {\n            return x.to_string();\n        } else {\n            return \"\".to_string();\n        }\n    }\n}\n","traces":[{"line":31,"address":[6868785,6868544],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":33,"address":[6868557],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[6868579],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[6868603],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[6868800,6869036],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":42,"address":[6868825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[6868875,6869003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[6870613,6869072],"length":1,"stats":{"Line":0},"fn_name":"add_config"},{"line":48,"address":[6869223,6869409,6869084,6869544],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[6869395,6869594,6869753],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[6869755,6869667],"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":[6869644,6869946,6869825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[6869859,6869948],"length":1,"stats":{"Line":0},"fn_name":null},{"line":57,"address":[6870018,6869836,6870151],"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":[6870156,6870064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[6870238,6870024,6870441,6870295],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[6870271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":66,"address":[6870960],"length":1,"stats":{"Line":0},"fn_name":"get_config"},{"line":67,"address":[6871147,6870976],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[6871085],"length":1,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[4634429,4633568],"length":1,"stats":{"Line":0},"fn_name":"tear_down"},{"line":80,"address":[4633575],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[4633924,4634081],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[4633585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":84,"address":[4634022,4633609,4633751,4633674],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[4634151,4634219],"length":1,"stats":{"Line":0},"fn_name":null},{"line":90,"address":[4634270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":94,"address":[4636190,4636352,4636359,4636160,4635511,4636176,4636165],"length":1,"stats":{"Line":7},"fn_name":"modify"},{"line":95,"address":[4635504],"length":1,"stats":{"Line":1},"fn_name":"test_config_file_update"},{"line":96,"address":[7682789,7682882],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[7682965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[7683208],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[7683478,7683534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[7683583],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[7684343],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[7684496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[7684545,7684711],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[4634798,4634464],"length":1,"stats":{"Line":0},"fn_name":"get_configuration_directory"},{"line":114,"address":[4634481],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[4634571,4634672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[4634688],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[4634796,4634751],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[4634763],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":43},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","cli_commands","node.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse super::config::get_config;\nuse crate::node_api::model::cli::Status;\n\npub async fn ping() -\u003e Result\u003cString, reqwest::Error\u003e {\n    //TODO: implement ping api in Node\n    let node_url = format!(\"http://{}/v2\", get_url());\n    let response = reqwest::get(node_url).await?.text().await?;\n    Ok(response)\n}\n\npub async fn peers_connected() -\u003e Result\u003cString, reqwest::Error\u003e {\n    let node_url = format!(\"http://{}/peers\", get_url());\n    let response = reqwest::get(node_url).await?.text().await?;\n    Ok(response)\n}\n\npub async fn status() -\u003e Result\u003cStatus, reqwest::Error\u003e {\n    let node_url = format!(\"http://{}/status\", get_url());\n\n    let response = reqwest::get(node_url).await?.json::\u003cStatus\u003e().await?;\n    Ok(response)\n}\n\npub fn get_url() -\u003e String {\n    let result = get_config();\n    let mut host = String::new();\n    let mut port = String::new();\n    match result {\n        Ok(data) =\u003e {\n            host = data.host;\n            port = data.port;\n        }\n        Err(error) =\u003e {\n            println!(\"Error: {}\", error);\n        }\n    };\n\n    format!(\"{}:{}\", host, port)\n}\n","traces":[{"line":20,"address":[5637982,5637968],"length":1,"stats":{"Line":0},"fn_name":"ping"},{"line":27,"address":[5638030,5638016],"length":1,"stats":{"Line":0},"fn_name":"peers_connected"},{"line":33,"address":[5638078,5638064],"length":1,"stats":{"Line":0},"fn_name":"status"},{"line":40,"address":[5638112,5639317],"length":1,"stats":{"Line":0},"fn_name":"get_url"},{"line":41,"address":[5638129],"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":[5638187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[5638202],"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":[5638303,5638248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[5638305],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[5638708,5638799,5638392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[5638938,5638740,5638887],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[5638446],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[5638597,5638475],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[5638654,5639085],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":14},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","cli_commands.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod config;\npub mod node;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","docker","constants.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub const MEDIA_TYPE_BLOB_GZIPPED: \u0026str = \"application/vnd.docker.image.rootfs.diff.tar.gzip\";\npub const MEDIA_TYPE_SCHEMA_1: \u0026str = \"application/vnd.docker.distribution.manifest.v1+json\";\npub const MEDIA_TYPE_IMAGE_MANIFEST: \u0026str = \"application/vnd.docker.distribution.manifest.v2+json\";\npub const MEDIA_TYPE_MANIFEST_LIST: \u0026str =\n    \"application/vnd.docker.distribution.manifest.list.v2+json\";\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","docker","error_util.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::transparency_log::log::TransparencyLogError;\nuse log::debug;\nuse serde::{Deserialize, Serialize};\nuse std::convert::Infallible;\nuse std::error::Error;\nuse std::fmt;\nuse warp::http::StatusCode;\nuse warp::reject::Reject;\nuse warp::{Rejection, Reply};\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ErrorMessage {\n    code: RegistryErrorCode,\n    message: String,\n}\n#[derive(Debug, Deserialize, Serialize)]\npub struct ErrorMessages {\n    errors: Vec\u003cErrorMessage\u003e,\n}\n\n#[derive(Debug, Deserialize, Serialize, PartialEq)]\npub enum RegistryErrorCode {\n    BlobUnknown,\n    BlobDoesNotExist(String),\n    ManifestUnknown,\n    Unknown(String),\n}\n\nimpl fmt::Display for RegistryErrorCode {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        let printable = match \u0026self {\n            RegistryErrorCode::BlobUnknown =\u003e \"BLOB_UNKNOWN\".to_string(),\n            RegistryErrorCode::BlobDoesNotExist(hash) =\u003e format!(\"BLOB_DOES_NOT_EXIST({})\", hash),\n            RegistryErrorCode::ManifestUnknown =\u003e \"MANIFEST_UNKNOWN\".to_string(),\n            RegistryErrorCode::Unknown(m) =\u003e format!(\"UNKNOWN({})\", m),\n        };\n        write!(f, \"{}\", printable)\n    }\n}\n\n#[derive(Debug, PartialEq)]\npub struct RegistryError {\n    pub code: RegistryErrorCode,\n}\n\nimpl From\u003canyhow::Error\u003e for RegistryError {\n    fn from(err: anyhow::Error) -\u003e RegistryError {\n        RegistryError {\n            code: RegistryErrorCode::Unknown(err.to_string()),\n        }\n    }\n}\n\nimpl From\u003cTransparencyLogError\u003e for RegistryError {\n    fn from(err: TransparencyLogError) -\u003e RegistryError {\n        RegistryError {\n            code: RegistryErrorCode::Unknown(err.to_string()),\n        }\n    }\n}\n\nimpl From\u003chex::FromHexError\u003e for RegistryError {\n    fn from(err: hex::FromHexError) -\u003e RegistryError {\n        RegistryError {\n            code: RegistryErrorCode::Unknown(err.to_string()),\n        }\n    }\n}\n\nimpl From\u003creqwest::Error\u003e for RegistryError {\n    fn from(err: reqwest::Error) -\u003e RegistryError {\n        RegistryError {\n            code: RegistryErrorCode::Unknown(err.to_string()),\n        }\n    }\n}\n\nimpl From\u003cstd::io::Error\u003e for RegistryError {\n    fn from(err: std::io::Error) -\u003e RegistryError {\n        RegistryError {\n            code: RegistryErrorCode::Unknown(err.to_string()),\n        }\n    }\n}\n\nimpl From\u003cBox\u003cdyn Error\u003e\u003e for RegistryError {\n    fn from(err: Box\u003cdyn Error\u003e) -\u003e RegistryError {\n        RegistryError {\n            code: RegistryErrorCode::Unknown(err.to_string()),\n        }\n    }\n}\n\nimpl From\u003cBox\u003cdyn Error + Send\u003e\u003e for RegistryError {\n    fn from(err: Box\u003cdyn Error + Send\u003e) -\u003e RegistryError {\n        RegistryError {\n            code: RegistryErrorCode::Unknown(err.to_string()),\n        }\n    }\n}\n\nimpl Reject for RegistryError {}\n\npub async fn custom_recover(err: Rejection) -\u003e Result\u003cimpl Reply, Infallible\u003e {\n    let mut status_code = StatusCode::INTERNAL_SERVER_ERROR;\n    let mut error_message = ErrorMessage {\n        code: RegistryErrorCode::Unknown(\"\".to_string()),\n        message: \"\".to_string(),\n    };\n\n    debug!(\"Rejection: {:?}\", err);\n    if let Some(e) = err.find::\u003cRegistryError\u003e() {\n        match \u0026e.code {\n            RegistryErrorCode::BlobUnknown =\u003e {\n                status_code = StatusCode::NOT_FOUND;\n                error_message.code = RegistryErrorCode::BlobUnknown;\n            }\n            RegistryErrorCode::BlobDoesNotExist(hash) =\u003e {\n                status_code = StatusCode::NOT_FOUND;\n                error_message.code = RegistryErrorCode::BlobDoesNotExist(hash.to_string());\n            }\n            RegistryErrorCode::ManifestUnknown =\u003e {\n                status_code = StatusCode::NOT_FOUND;\n                error_message.code = RegistryErrorCode::ManifestUnknown;\n            }\n            RegistryErrorCode::Unknown(m) =\u003e {\n                error_message.message = m.clone();\n            }\n        }\n    } else if let Some(e) = err.find::\u003cwarp::reject::InvalidHeader\u003e() {\n        status_code = StatusCode::BAD_REQUEST;\n        error_message.message = format!(\"{}\", e);\n    }\n\n    debug!(\"ErrorMessage: {:?}\", error_message);\n    Ok(warp::reply::with_status(\n        warp::reply::json(\u0026ErrorMessages {\n            errors: vec![error_message],\n        }),\n        status_code,\n    )\n    .into_response())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::io;\n    use std::str;\n    use warp::reply::Response;\n\n    #[test]\n    fn from_io_error() {\n        let io_error_1 = io::Error::new(io::ErrorKind::Interrupted, \"operation interrupted\");\n        let io_error_2 = io::Error::new(io::ErrorKind::Interrupted, \"operation interrupted\");\n\n        let registry_error: RegistryError = io_error_1.into();\n        assert_eq!(\n            registry_error.code,\n            RegistryErrorCode::Unknown(io_error_2.to_string())\n        );\n    }\n\n    #[test]\n    fn from_from_hex_error() {\n        let from_hex_error = hex::FromHexError::OddLength;\n\n        let registry_error: RegistryError = from_hex_error.into();\n        assert_eq!(\n            registry_error.code,\n            RegistryErrorCode::Unknown(from_hex_error.to_string())\n        );\n    }\n\n    #[test]\n    fn from_anyhow_error() {\n        let from_hex_error_1 = hex::FromHexError::OddLength;\n        let anyhow_error_1: anyhow::Error = from_hex_error_1.into();\n\n        let from_hex_error_2 = hex::FromHexError::OddLength;\n        let anyhow_error_2: anyhow::Error = from_hex_error_2.into();\n\n        let registry_error: RegistryError = anyhow_error_1.into();\n        assert_eq!(\n            registry_error.code,\n            RegistryErrorCode::Unknown(anyhow_error_2.to_string())\n        );\n    }\n\n    #[test]\n    fn from_transparency_log_error() {\n        let transparency_log_error_1 = TransparencyLogError::NotFound {\n            id: String::from(\"artifact_id\"),\n        };\n        let transparency_log_error_2 = TransparencyLogError::NotFound {\n            id: String::from(\"artifact_id\"),\n        };\n\n        let registry_error: RegistryError = transparency_log_error_1.into();\n        assert_eq!(\n            registry_error.code,\n            RegistryErrorCode::Unknown(transparency_log_error_2.to_string())\n        );\n    }\n\n    #[tokio::test]\n    async fn custom_recover_from_registry_error_for_blob_unknown() {\n        let registry_error = RegistryError {\n            code: RegistryErrorCode::BlobUnknown,\n        };\n\n        let expected_body = serde_json::to_string(\u0026ErrorMessages {\n            errors: vec![ErrorMessage {\n                code: RegistryErrorCode::BlobUnknown,\n                message: \"\".to_string(),\n            }],\n        })\n        .expect(\"Generating JSON body should not fail.\");\n\n        let response = custom_recover(registry_error.into())\n            .await\n            .expect(\"Reply should be created.\")\n            .into_response();\n\n        verify_recover_response(response, expected_body, StatusCode::NOT_FOUND).await;\n    }\n\n    #[tokio::test]\n    async fn custom_recover_from_registry_error_for_blob_does_not_exist() {\n        let registry_error = RegistryError {\n            code: RegistryErrorCode::BlobDoesNotExist(String::from(\"non_existing_blob_hash\")),\n        };\n\n        let expected_body = serde_json::to_string(\u0026ErrorMessages {\n            errors: vec![ErrorMessage {\n                code: RegistryErrorCode::BlobDoesNotExist(String::from(\"non_existing_blob_hash\")),\n                message: \"\".to_string(),\n            }],\n        })\n        .expect(\"Generating JSON body should not fail.\");\n\n        let response = custom_recover(registry_error.into())\n            .await\n            .expect(\"Reply should be created.\")\n            .into_response();\n\n        verify_recover_response(response, expected_body, StatusCode::NOT_FOUND).await;\n    }\n\n    #[tokio::test]\n    async fn custom_recover_from_registry_error_for_manifest_unknown() {\n        let registry_error = RegistryError {\n            code: RegistryErrorCode::ManifestUnknown,\n        };\n\n        let expected_body = serde_json::to_string(\u0026ErrorMessages {\n            errors: vec![ErrorMessage {\n                code: RegistryErrorCode::ManifestUnknown,\n                message: \"\".to_string(),\n            }],\n        })\n        .expect(\"Generating JSON body should not fail.\");\n\n        let response = custom_recover(registry_error.into())\n            .await\n            .expect(\"Reply should be created.\")\n            .into_response();\n\n        verify_recover_response(response, expected_body, StatusCode::NOT_FOUND).await;\n    }\n\n    #[tokio::test]\n    async fn custom_recover_from_registry_error_for_unknown() {\n        let registry_error = RegistryError {\n            code: RegistryErrorCode::Unknown(String::from(\"unknown_error\")),\n        };\n\n        let expected_body = serde_json::to_string(\u0026ErrorMessages {\n            errors: vec![ErrorMessage {\n                code: RegistryErrorCode::Unknown(\"\".to_string()),\n                message: String::from(\"unknown_error\"),\n            }],\n        })\n        .expect(\"Generating JSON body should not fail.\");\n\n        let response = custom_recover(registry_error.into())\n            .await\n            .expect(\"Reply should be created.\")\n            .into_response();\n\n        verify_recover_response(response, expected_body, StatusCode::INTERNAL_SERVER_ERROR).await;\n    }\n\n    #[derive(Debug)]\n    struct UnhandledErrorForCustomRecover {}\n    impl Reject for UnhandledErrorForCustomRecover {}\n\n    #[tokio::test]\n    async fn custom_recover_from_registry_error_for_unhandled_error() {\n        let unhandled_error = UnhandledErrorForCustomRecover {};\n\n        let expected_body = serde_json::to_string(\u0026ErrorMessages {\n            errors: vec![ErrorMessage {\n                code: RegistryErrorCode::Unknown(\"\".to_string()),\n                message: String::from(\"\"),\n            }],\n        })\n        .expect(\"Generating JSON body should not fail.\");\n\n        let response = custom_recover(unhandled_error.into())\n            .await\n            .expect(\"Reply should be created.\")\n            .into_response();\n\n        verify_recover_response(response, expected_body, StatusCode::INTERNAL_SERVER_ERROR).await;\n    }\n\n    async fn verify_recover_response(\n        response: Response,\n        expected_body: String,\n        expected_status: StatusCode,\n    ) {\n        let status = response.status();\n        let actual_body_bytes = hyper::body::to_bytes(response.into_body())\n            .await\n            .expect(\"Response body to be converted to bytes\");\n        let actual_body_str = str::from_utf8(\u0026actual_body_bytes)\n            .map(str::to_owned)\n            .expect(\"Response body to be converted to string\");\n        assert_eq!(status, expected_status);\n        assert_eq!(actual_body_str, expected_body);\n    }\n}\n","traces":[{"line":45,"address":[8411264,8411878],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":46,"address":[8411289],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[8411325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":[8411622,8411352],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[8411392],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[8411419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":[8411842,8411586,8411747],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[8412077,8411920],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":64,"address":[8411949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[8412112],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":72,"address":[8412155],"length":1,"stats":{"Line":1},"fn_name":null},{"line":78,"address":[8412272,8412429],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":80,"address":[8412301],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[8412464,8412625],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":88,"address":[8412483],"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":[8412656,8412816],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":96,"address":[8412689],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[8413008,8412848],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":104,"address":[8412881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[7322975,7319985,7319808,7322456,7319863],"length":1,"stats":{"Line":5},"fn_name":"{async_fn#0}"},{"line":112,"address":[7319949],"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":[7319959,7320059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":115,"address":[7320103],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[7320386,7320252,7320340,7320474],"length":1,"stats":{"Line":3},"fn_name":null},{"line":119,"address":[7320699],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[7320771,7321240],"length":1,"stats":{"Line":1},"fn_name":null},{"line":121,"address":[7322049],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[7321242],"length":1,"stats":{"Line":1},"fn_name":null},{"line":123,"address":[7321252,7321977,7322054],"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":[7321287],"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":[7321299],"length":1,"stats":{"Line":1},"fn_name":null},{"line":127,"address":[7321742,7321878,7321317],"length":1,"stats":{"Line":2},"fn_name":null},{"line":129,"address":[7321638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":130,"address":[7321327],"length":1,"stats":{"Line":1},"fn_name":null},{"line":131,"address":[7321566,7321337,7321643],"length":1,"stats":{"Line":2},"fn_name":null},{"line":133,"address":[7321372],"length":1,"stats":{"Line":1},"fn_name":null},{"line":134,"address":[7321483,7321384],"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":[7321152,7320808,7320910],"length":1,"stats":{"Line":2},"fn_name":null},{"line":138,"address":[7320875],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[7321157,7320963,7320893],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[7322157,7322239,7320912],"length":1,"stats":{"Line":3},"fn_name":null},{"line":143,"address":[7322907,7322804],"length":1,"stats":{"Line":2},"fn_name":null},{"line":144,"address":[7322681],"length":1,"stats":{"Line":1},"fn_name":null},{"line":145,"address":[7322485],"length":1,"stats":{"Line":1},"fn_name":null},{"line":160,"address":[4749994,4749440],"length":1,"stats":{"Line":3},"fn_name":"from_io_error"},{"line":161,"address":[4749447],"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":[4749496],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[4749544],"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":[4749834,4749728],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[4749620,4749684],"length":1,"stats":{"Line":2},"fn_name":null},{"line":172,"address":[4750376,4750032],"length":1,"stats":{"Line":3},"fn_name":"from_from_hex_error"},{"line":173,"address":[4750039],"length":1,"stats":{"Line":1},"fn_name":null},{"line":175,"address":[4750047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":[4750153,4750255],"length":1,"stats":{"Line":2},"fn_name":null},{"line":178,"address":[4750100],"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":[4750979,4750400],"length":1,"stats":{"Line":3},"fn_name":"from_anyhow_error"},{"line":184,"address":[4750407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":[4750423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[4750461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":188,"address":[4750469],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[4750511],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[4750817,4750697],"length":1,"stats":{"Line":2},"fn_name":null},{"line":193,"address":[4750606,4750653],"length":1,"stats":{"Line":2},"fn_name":null},{"line":197,"address":[4751165,4751314],"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":[4751008,4751409,4751023],"length":1,"stats":{"Line":6},"fn_name":"custom_recover_from_registry_error_for_blob_unknown"},{"line":203,"address":[7901055],"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":[7901045,7900550,7900872],"length":1,"stats":{"Line":2},"fn_name":null},{"line":205,"address":[7900780],"length":1,"stats":{"Line":1},"fn_name":null},{"line":206,"address":[7900792],"length":1,"stats":{"Line":1},"fn_name":null},{"line":211,"address":[7900672,7901337,7901231,7900592],"length":1,"stats":{"Line":3},"fn_name":null},{"line":216,"address":[4751057,4751146,4751203,4751015],"length":1,"stats":{"Line":5},"fn_name":null},{"line":219,"address":[4751746,4751597],"length":1,"stats":{"Line":1},"fn_name":null},{"line":220,"address":[4751440,4751841,4751455],"length":1,"stats":{"Line":6},"fn_name":"custom_recover_from_registry_error_for_blob_does_not_exist"},{"line":222,"address":[7902671,7902428],"length":1,"stats":{"Line":2},"fn_name":null},{"line":225,"address":[7903200],"length":1,"stats":{"Line":1},"fn_name":null},{"line":226,"address":[7903190,7902983,7902761],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[7902835,7902908],"length":1,"stats":{"Line":2},"fn_name":null},{"line":228,"address":[7902952],"length":1,"stats":{"Line":1},"fn_name":null},{"line":233,"address":[7903376,7902485,7902565,7903482],"length":1,"stats":{"Line":3},"fn_name":null},{"line":238,"address":[4751578,4751447,4751635,4751489],"length":1,"stats":{"Line":5},"fn_name":null},{"line":241,"address":[4752178,4752029],"length":1,"stats":{"Line":1},"fn_name":null},{"line":242,"address":[4752273,4751887,4751872],"length":1,"stats":{"Line":6},"fn_name":"custom_recover_from_registry_error_for_manifest_unknown"},{"line":247,"address":[7905119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":248,"address":[7904936,7905109,7904614],"length":1,"stats":{"Line":2},"fn_name":null},{"line":249,"address":[7904844],"length":1,"stats":{"Line":1},"fn_name":null},{"line":250,"address":[7904856],"length":1,"stats":{"Line":1},"fn_name":null},{"line":255,"address":[7904736,7905401,7904656,7905295],"length":1,"stats":{"Line":3},"fn_name":null},{"line":260,"address":[4752067,4751921,4752010,4751879],"length":1,"stats":{"Line":5},"fn_name":null},{"line":263,"address":[4752610,4752461],"length":1,"stats":{"Line":1},"fn_name":null},{"line":264,"address":[4752705,4752304,4752319],"length":1,"stats":{"Line":6},"fn_name":"custom_recover_from_registry_error_for_unknown"},{"line":266,"address":[7906735,7906492],"length":1,"stats":{"Line":2},"fn_name":null},{"line":269,"address":[7907255],"length":1,"stats":{"Line":1},"fn_name":null},{"line":270,"address":[7906825,7907047],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[7906971,7906899],"length":1,"stats":{"Line":2},"fn_name":null},{"line":272,"address":[7907015],"length":1,"stats":{"Line":1},"fn_name":null},{"line":277,"address":[7906549,7907431,7907537,7906629],"length":1,"stats":{"Line":3},"fn_name":null},{"line":282,"address":[4752353,4752311,4752442,4752499],"length":1,"stats":{"Line":5},"fn_name":null},{"line":289,"address":[4753170,4753021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":290,"address":[4752879,4753265,4752864],"length":1,"stats":{"Line":6},"fn_name":"custom_recover_from_registry_error_for_unhandled_error"},{"line":291,"address":[7908596],"length":1,"stats":{"Line":1},"fn_name":null},{"line":293,"address":[7909201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":[7908610,7908993],"length":1,"stats":{"Line":1},"fn_name":null},{"line":295,"address":[7908918,7908840],"length":1,"stats":{"Line":2},"fn_name":null},{"line":296,"address":[7908962],"length":1,"stats":{"Line":1},"fn_name":null},{"line":301,"address":[7908732,7908652,7909369,7909431],"length":1,"stats":{"Line":3},"fn_name":null},{"line":306,"address":[4752871,4753002,4752913,4753059],"length":1,"stats":{"Line":5},"fn_name":null},{"line":309,"address":[4749296],"length":1,"stats":{"Line":1},"fn_name":"verify_recover_response"},{"line":314,"address":[7899022,7898843],"length":1,"stats":{"Line":2},"fn_name":null},{"line":315,"address":[7899025,7898894,7899147],"length":1,"stats":{"Line":2},"fn_name":null},{"line":318,"address":[7899639,7899536],"length":1,"stats":{"Line":2},"fn_name":null},{"line":321,"address":[7899693,7899932],"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":[7899840,7899988,7900022],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":97,"coverable":112},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","docker","v2","handlers","blobs.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::artifact_service::handlers::get_artifact;\nuse crate::artifact_service::storage::ArtifactStorage;\nuse crate::docker::error_util::{RegistryError, RegistryErrorCode};\nuse crate::network::client::Client;\nuse crate::transparency_log::log::TransparencyLog;\nuse futures::lock::Mutex;\nuse log::debug;\nuse std::result::Result;\nuse std::sync::Arc;\nuse warp::{http::StatusCode, Rejection, Reply};\n\npub async fn handle_get_blobs(\n    transparency_log: Arc\u003cMutex\u003cTransparencyLog\u003e\u003e,\n    p2p_client: Client,\n    artifact_storage: ArtifactStorage,\n    hash: String,\n) -\u003e Result\u003cimpl Reply, Rejection\u003e {\n    debug!(\"Getting blob with hash : {:?}\", hash);\n\n    let blob_content = get_artifact(\n        transparency_log,\n        p2p_client,\n        \u0026artifact_storage,\n        \u0026get_namespace_specific_id(\u0026hash),\n    )\n    .await\n    .map_err(|_| {\n        warp::reject::custom(RegistryError {\n            code: RegistryErrorCode::BlobUnknown,\n        })\n    })?;\n\n    Ok(warp::http::response::Builder::new()\n        .header(\"Content-Type\", \"application/octet-stream\")\n        .status(StatusCode::OK)\n        .body(blob_content.to_vec())\n        .unwrap())\n}\n\nfn get_namespace_specific_id(hash: \u0026str) -\u003e String {\n    format!(\"DOCKER::BLOB::{}\", hash)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::artifact_service::service::{Hash, HashAlgorithm};\n    use crate::util::test_util;\n    use anyhow::Context;\n    use assay::assay;\n    use futures::channel::mpsc;\n    use hyper::header::HeaderValue;\n    use libp2p::identity::Keypair;\n    use std::borrow::Borrow;\n    use std::fs::File;\n    use std::path::PathBuf;\n\n    const VALID_ARTIFACT_HASH: [u8; 32] = [\n        0x86, 0x5c, 0x8d, 0x98, 0x8b, 0xe4, 0x66, 0x9f, 0x3e, 0x48, 0xf7, 0x3b, 0x98, 0xf9, 0xbc,\n        0x25, 0x7, 0xbe, 0x2, 0x46, 0xea, 0x35, 0xe0, 0x9, 0x8c, 0xf6, 0x5, 0x4d, 0x36, 0x44, 0xc1,\n        0x4f,\n    ];\n\n    #[test]\n    fn test_get_namespace_specific_id() {\n        let hash = \"hash\";\n\n        assert_eq!(\n            get_namespace_specific_id(hash),\n            format!(\"DOCKER::BLOB::{}\", hash)\n        );\n    }\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-node\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    #[tokio::test]\n    async fn test_handle_get_blobs_unknown_in_artifact_service() {\n        let hash = \"7300a197d7deb39371d4683d60f60f2fbbfd7541837ceb2278c12014e94e657b\";\n        let namespace_specific_id = format!(\"DOCKER::BLOB::{}\", hash);\n\n        let transparency_log = Arc::new(Mutex::new(TransparencyLog::new()));\n        transparency_log\n            .lock()\n            .await\n            .add_artifact(\u0026namespace_specific_id, hash)?;\n\n        let (sender, _) = mpsc::channel(1);\n        let p2p_client = Client {\n            sender,\n            local_peer_id: Keypair::generate_ed25519().public().to_peer_id(),\n        };\n\n        let artifact_storage = ArtifactStorage::new()?;\n\n        let result = handle_get_blobs(\n            transparency_log,\n            p2p_client,\n            artifact_storage,\n            hash.to_string(),\n        )\n        .await;\n\n        assert!(result.is_err());\n        let rejection = result.err().unwrap();\n        let registry_error = rejection.find::\u003cRegistryError\u003e().unwrap().borrow();\n        assert_eq!(\n            *registry_error,\n            RegistryError {\n                code: RegistryErrorCode::BlobUnknown,\n            }\n        );\n    }\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-node\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    #[tokio::test]\n    async fn test_handle_get_blobs() {\n        let hash = \"865c8d988be4669f3e48f73b98f9bc2507be0246ea35e0098cf6054d3644c14f\";\n        let namespace_specific_id = format!(\"DOCKER::BLOB::{}\", hash);\n\n        let transparency_log = Arc::new(Mutex::new(TransparencyLog::new()));\n        transparency_log\n            .lock()\n            .await\n            .add_artifact(\u0026namespace_specific_id, hash)?;\n\n        let (sender, _) = mpsc::channel(1);\n        let p2p_client = Client {\n            sender,\n            local_peer_id: Keypair::generate_ed25519().public().to_peer_id(),\n        };\n\n        let artifact_storage = ArtifactStorage::new()?;\n        create_artifact(\u0026artifact_storage)?;\n\n        let result = handle_get_blobs(\n            transparency_log,\n            p2p_client,\n            artifact_storage,\n            hash.to_string(),\n        )\n        .await;\n\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_response();\n        assert_eq!(response.status(), StatusCode::OK);\n        assert_eq!(\n            response.headers().get(\"Content-Type\"),\n            Some(\u0026HeaderValue::from_static(\"application/octet-stream\"))\n        );\n    }\n\n    fn get_file_reader() -\u003e Result\u003cFile, anyhow::Error\u003e {\n        // test artifact file in resources/test dir\n        let mut curr_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n        curr_dir.push(\"tests/resources/artifact_test.json\");\n\n        let path = String::from(curr_dir.to_string_lossy());\n        let reader = File::open(path.as_str()).unwrap();\n        Ok(reader)\n    }\n\n    fn create_artifact(artifact_storage: \u0026ArtifactStorage) -\u003e Result\u003c(), anyhow::Error\u003e {\n        let hash = Hash::new(HashAlgorithm::SHA256, \u0026VALID_ARTIFACT_HASH)?;\n        artifact_storage\n            .push_artifact(\u0026mut get_file_reader()?, \u0026hash)\n            .context(\"Error while pushing artifact\")\n    }\n}\n","traces":[{"line":26,"address":[6220912],"length":1,"stats":{"Line":0},"fn_name":"handle_get_blobs"},{"line":32,"address":[8408860,8409039,8409166,8409090],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[8409396],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[8409459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[8409586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[8409689,8409594],"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":[8411136,8411232],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":42,"address":[8411154],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[8411145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[8410743,8410887,8410695],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[8410823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[6221056],"length":1,"stats":{"Line":1},"fn_name":"get_namespace_specific_id"},{"line":55,"address":[6221080],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[8346336,8346341],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":80,"address":[8532407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[8532629,8532539],"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":[8532428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":84,"address":[8532448,8532577],"length":1,"stats":{"Line":2},"fn_name":null},{"line":88,"address":[8346661,8351303,8347707,8347788,8346368,8346373,8347349,8347230,8347053,8347927,8346400,8347472,8347488,8347142,8346619,8347549,8346415,8346730,8351337,8347447,8351328],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":93,"address":[8347440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[8347614],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[8347659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[8347677,8347971,8347864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[8348030],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[8348260,8348423,8348343,8348182,8348049],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[8348480,8348333],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[8348732,8348648,8348581],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[8349412,8349097,8349505],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[8349209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[8349260],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[8349387],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[8350232,8350379],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[8350302,8350427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[8350473,8350567],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[8350700,8350592],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[8351392,8352254,8352812,8357328,8352573,8352166,8352512,8357337,8352496,8352951,8351754,8352373,8351424,8352077,8352471,8351685,8357299,8351439,8351643,8352731,8351397],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":135,"address":[8352464],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[8352638],"length":1,"stats":{"Line":1},"fn_name":null},{"line":139,"address":[8352683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[8352701,8352888,8352995],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[8353054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[8353073,8353206,8353284,8353447,8353367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[8353357,8353504],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[8353756,8353605,8353672],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[8354121,8354245,8354325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[8354652,8354378,8354735,8354230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[8354449],"length":1,"stats":{"Line":0},"fn_name":null},{"line":156,"address":[8354500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[8354627],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[8355462,8355608],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[8355656,8355532],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[8355883,8355663,8355847],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[8356523],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[8355853,8356429],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[8356472],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[8531264,8531650],"length":1,"stats":{"Line":0},"fn_name":"get_file_reader"},{"line":174,"address":[8531271],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[8531294],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[8531400,8531327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[8531532,8531436],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[8531609],"length":1,"stats":{"Line":0},"fn_name":null},{"line":182,"address":[8531696,8532085],"length":1,"stats":{"Line":0},"fn_name":"create_artifact"},{"line":183,"address":[8531716,8531870],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[8532320,8532141,8532257],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[8532100,8531928,8531853,8532037,8532153],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":11,"coverable":65},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","docker","v2","handlers","manifests.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::artifact_service::handlers::get_artifact;\nuse crate::artifact_service::storage::ArtifactStorage;\nuse crate::docker::error_util::{RegistryError, RegistryErrorCode};\nuse crate::network::client::Client;\nuse crate::transparency_log::log::TransparencyLog;\nuse futures::lock::Mutex;\nuse log::debug;\nuse std::sync::Arc;\nuse warp::http::StatusCode;\nuse warp::{Rejection, Reply};\n\n// Handles GET endpoint documented at https://docs.docker.com/registry/spec/api/#manifest\npub async fn fetch_manifest(\n    transparency_log: Arc\u003cMutex\u003cTransparencyLog\u003e\u003e,\n    p2p_client: Client,\n    artifact_storage: ArtifactStorage,\n    name: String,\n    tag: String,\n) -\u003e Result\u003cimpl Reply, Rejection\u003e {\n    debug!(\"Fetching manifest for {} with tag: {}\", name, tag);\n\n    let manifest_content = get_artifact(\n        transparency_log,\n        p2p_client,\n        \u0026artifact_storage,\n        \u0026get_namespace_specific_id(\u0026name, \u0026tag),\n    )\n    .await\n    .map_err(|_| {\n        warp::reject::custom(RegistryError {\n            code: RegistryErrorCode::ManifestUnknown,\n        })\n    })?;\n\n    let len = manifest_content.len();\n\n    Ok(warp::http::response::Builder::new()\n        .header(\n            \"Content-Type\",\n            \"application/vnd.docker.distribution.manifest.v2+json\",\n        )\n        .header(\"Content-Length\", len)\n        .status(StatusCode::OK)\n        .body(manifest_content.to_vec())\n        .unwrap())\n}\n\nfn get_namespace_specific_id(name: \u0026str, tag: \u0026str) -\u003e String {\n    format!(\"DOCKER::MANIFEST::{}::{}\", name, tag)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::artifact_service::service::{Hash, HashAlgorithm};\n    use crate::util::test_util;\n    use anyhow::Context;\n    use assay::assay;\n    use futures::channel::mpsc;\n    use hyper::header::HeaderValue;\n    use libp2p::identity::Keypair;\n    use std::borrow::Borrow;\n    use std::fs::File;\n    use std::path::PathBuf;\n\n    const VALID_ARTIFACT_HASH: [u8; 32] = [\n        0x86, 0x5c, 0x8d, 0x98, 0x8b, 0xe4, 0x66, 0x9f, 0x3e, 0x48, 0xf7, 0x3b, 0x98, 0xf9, 0xbc,\n        0x25, 0x7, 0xbe, 0x2, 0x46, 0xea, 0x35, 0xe0, 0x9, 0x8c, 0xf6, 0x5, 0x4d, 0x36, 0x44, 0xc1,\n        0x4f,\n    ];\n\n    #[test]\n    fn test_get_namespace_specific_id() {\n        let name = \"name\";\n        let tag = \"tag\";\n\n        assert_eq!(\n            get_namespace_specific_id(name, tag),\n            format!(\"DOCKER::MANIFEST::{}::{}\", name, tag)\n        );\n    }\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-node\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    #[tokio::test]\n    async fn test_fetch_manifest_unknown_in_artifact_service() {\n        let name = \"name\";\n        let tag = \"tag\";\n        let hash = \"7300a197d7deb39371d4683d60f60f2fbbfd7541837ceb2278c12014e94e657b\";\n        let namespace_specific_id = format!(\"DOCKER::MANIFEST::{}::{}\", name, tag);\n\n        let transparency_log = Arc::new(Mutex::new(TransparencyLog::new()));\n        transparency_log\n            .lock()\n            .await\n            .add_artifact(\u0026namespace_specific_id, hash)?;\n\n        let (sender, _) = mpsc::channel(1);\n        let p2p_client = Client {\n            sender,\n            local_peer_id: Keypair::generate_ed25519().public().to_peer_id(),\n        };\n\n        let artifact_storage = ArtifactStorage::new()?;\n\n        let result = fetch_manifest(\n            transparency_log,\n            p2p_client,\n            artifact_storage,\n            name.to_string(),\n            tag.to_string(),\n        )\n        .await;\n\n        assert!(result.is_err());\n        let rejection = result.err().unwrap();\n        let registry_error = rejection.find::\u003cRegistryError\u003e().unwrap().borrow();\n        assert_eq!(\n            *registry_error,\n            RegistryError {\n                code: RegistryErrorCode::ManifestUnknown,\n            }\n        );\n    }\n\n    #[assay(\n        env = [\n          (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-node\"),\n          (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    #[tokio::test]\n    async fn test_fetch_manifest() {\n        let name = \"name\";\n        let tag = \"tag\";\n        let hash = \"865c8d988be4669f3e48f73b98f9bc2507be0246ea35e0098cf6054d3644c14f\";\n        let namespace_specific_id = format!(\"DOCKER::MANIFEST::{}::{}\", name, tag);\n\n        let transparency_log = Arc::new(Mutex::new(TransparencyLog::new()));\n        transparency_log\n            .lock()\n            .await\n            .add_artifact(\u0026namespace_specific_id, hash)?;\n\n        let (sender, _) = mpsc::channel(1);\n        let p2p_client = Client {\n            sender,\n            local_peer_id: Keypair::generate_ed25519().public().to_peer_id(),\n        };\n\n        let artifact_storage = ArtifactStorage::new()?;\n        create_artifact(\u0026artifact_storage)?;\n\n        let result = fetch_manifest(\n            transparency_log,\n            p2p_client,\n            artifact_storage,\n            name.to_string(),\n            tag.to_string(),\n        )\n        .await;\n\n        assert!(result.is_ok());\n\n        let response = result.unwrap().into_response();\n        assert_eq!(response.status(), StatusCode::OK);\n        assert_eq!(\n            response.headers().get(\"Content-Length\"),\n            Some(\u0026HeaderValue::from_static(\"4903\"))\n        );\n        assert_eq!(\n            response.headers().get(\"Content-Type\"),\n            Some(\u0026HeaderValue::from_static(\n                \"application/vnd.docker.distribution.manifest.v2+json\"\n            ))\n        );\n    }\n\n    fn get_file_reader() -\u003e Result\u003cFile, anyhow::Error\u003e {\n        // test artifact file in resources/test dir\n        let mut curr_dir = PathBuf::from(env!(\"CARGO_MANIFEST_DIR\"));\n        curr_dir.push(\"tests/resources/artifact_test.json\");\n\n        let path = String::from(curr_dir.to_string_lossy());\n        let reader = File::open(path.as_str()).unwrap();\n        Ok(reader)\n    }\n\n    fn create_artifact(artifact_storage: \u0026ArtifactStorage) -\u003e Result\u003c(), anyhow::Error\u003e {\n        let hash = Hash::new(HashAlgorithm::SHA256, \u0026VALID_ARTIFACT_HASH)?;\n        artifact_storage\n            .push_artifact(\u0026mut get_file_reader()?, \u0026hash)\n            .context(\"Error while pushing artifact\")\n    }\n}\n","traces":[{"line":27,"address":[4604048],"length":1,"stats":{"Line":0},"fn_name":"fetch_manifest"},{"line":34,"address":[4629250,4628911,4629159,4629105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":[4629586],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[4629649],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[4629776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[4630026,4629967,4629784],"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":[4631792,4631888],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":44,"address":[4631810],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4631801],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[4631504,4631304,4631187,4631389,4631139],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[4631347,4631421,4631235,4631275],"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":[4631440],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[4604240],"length":1,"stats":{"Line":1},"fn_name":"get_namespace_specific_id"},{"line":61,"address":[4604277],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[5200453,5200448],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":86,"address":[7263975],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[7263996],"length":1,"stats":{"Line":1},"fn_name":null},{"line":89,"address":[7264119,7264312],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[7264017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":91,"address":[7264177,7264047],"length":1,"stats":{"Line":2},"fn_name":null},{"line":95,"address":[5201254,5200731,5201461,5205728,5200842,5201661,5201342,5200480,5200773,5201954,5205737,5200527,5201584,5201873,5202093,5201165,5200512,5201559,5205701,5200485,5201600],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":100,"address":[5201552],"length":1,"stats":{"Line":0},"fn_name":null},{"line":103,"address":[5201726],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[5201779],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[5201797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[5201816],"length":1,"stats":{"Line":0},"fn_name":null},{"line":107,"address":[5201843,5202169,5202054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":109,"address":[5202299],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[5202443,5202318,5202687,5202607,5202524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[5202744,5202597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[5202912,5202996,5202845],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[5203676,5203769,5203361],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[5203473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[5203524],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[5203651,5203956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[5203964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":129,"address":[5204630,5204777],"length":1,"stats":{"Line":0},"fn_name":null},{"line":130,"address":[5204700,5204825],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[5204871,5204965],"length":1,"stats":{"Line":0},"fn_name":null},{"line":132,"address":[5205098,5204990],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[5205792,5206973,5206896,5207266,5212832,5206154,5206043,5206654,5207185,5205797,5205839,5206912,5206773,5212841,5205824,5206085,5207405,5206871,5206477,5212808,5206566],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":145,"address":[5206864],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[5207038],"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":[5207091],"length":1,"stats":{"Line":0},"fn_name":null},{"line":150,"address":[5207109],"length":1,"stats":{"Line":0},"fn_name":null},{"line":151,"address":[5207128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[5207366,5207481,5207155],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[5207611],"length":1,"stats":{"Line":0},"fn_name":null},{"line":155,"address":[5207755,5207999,5207836,5207919,5207630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[5207909,5208056],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[5208157,5208308,5208224],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[5208673,5208877,5208797],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[5209287,5208930,5208782,5209204],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[5209001],"length":1,"stats":{"Line":0},"fn_name":null},{"line":168,"address":[5209052],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[5209179,5209474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":171,"address":[5209482],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[5210294,5210148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[5210218,5210342],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[5210349,5210569,5210533],"length":1,"stats":{"Line":0},"fn_name":null},{"line":179,"address":[5211209],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[5210539,5211115],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[5211158],"length":1,"stats":{"Line":0},"fn_name":null},{"line":183,"address":[5212034],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[5211911],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[5211983],"length":1,"stats":{"Line":0},"fn_name":null},{"line":191,"address":[7263218,7262832],"length":1,"stats":{"Line":0},"fn_name":"get_file_reader"},{"line":193,"address":[7262839],"length":1,"stats":{"Line":0},"fn_name":null},{"line":194,"address":[7262862],"length":1,"stats":{"Line":0},"fn_name":null},{"line":196,"address":[7262968,7262895],"length":1,"stats":{"Line":0},"fn_name":null},{"line":197,"address":[7263100,7263004],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[7263177],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[7263653,7263264],"length":1,"stats":{"Line":0},"fn_name":"create_artifact"},{"line":202,"address":[7263284,7263438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[7263825,7263888,7263709],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[7263496,7263721,7263605,7263421,7263668],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":12,"coverable":76},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","docker","v2","handlers.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod blobs;\npub mod manifests;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","docker","v2","routes.rs"],"content":"// all warp routes can be here\n/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::artifact_service::storage::ArtifactStorage;\nuse crate::docker::v2::handlers::{blobs::handle_get_blobs, manifests::fetch_manifest};\nuse crate::network::client::Client;\nuse crate::transparency_log::log::TransparencyLog;\nuse futures::lock::Mutex;\nuse std::sync::Arc;\nuse warp::Filter;\n\npub fn make_docker_routes(\n    transparency_log: TransparencyLog,\n    p2p_client: Client,\n    artifact_storage: ArtifactStorage,\n) -\u003e impl Filter\u003cExtract = impl warp::Reply, Error = warp::Rejection\u003e + Clone {\n    let empty_json = \"{}\";\n    let v2_base = warp::path(\"v2\")\n        .and(warp::get())\n        .and(warp::path::end())\n        .map(move || empty_json)\n        .with(warp::reply::with::header(\n            \"Content-Length\",\n            empty_json.len(),\n        ))\n        .with(warp::reply::with::header(\n            \"Content-Type\",\n            \"application/json\",\n        ));\n\n    let transparency_log_fetch_manifest = Arc::new(Mutex::new(transparency_log));\n    let transparency_log_get_blobs = transparency_log_fetch_manifest.clone();\n    let p2p_client_fetch_manifest = p2p_client.clone();\n    let artifact_storage_fetch_manifest = artifact_storage.clone();\n\n    let v2_manifests = warp::path!(\"v2\" / \"library\" / String / \"manifests\" / String)\n        .and(warp::get().or(warp::head()).unify())\n        .and_then(move |name, tag| {\n            fetch_manifest(\n                transparency_log_fetch_manifest.clone(),\n                p2p_client_fetch_manifest.clone(),\n                artifact_storage_fetch_manifest.clone(),\n                name,\n                tag,\n            )\n        });\n\n    let v2_blobs = warp::path!(\"v2\" / \"library\" / String / \"blobs\" / String)\n        .and(warp::get().or(warp::head()).unify())\n        .and(warp::path::end())\n        .and_then(move |_name, hash| {\n            handle_get_blobs(\n                transparency_log_get_blobs.clone(),\n                p2p_client.clone(),\n                artifact_storage.clone(),\n                hash,\n            )\n        });\n\n    warp::any().and(v2_base.or(v2_manifests).or(v2_blobs))\n}\n","traces":[{"line":26,"address":[4500834,4498848],"length":1,"stats":{"Line":0},"fn_name":"make_docker_routes"},{"line":31,"address":[4498878],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[4499108,4499386,4499331,4498985,4499220,4499166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[4499046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[4499145],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[4499193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[4499280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[4499251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[4499346],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[4499491,4499521],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[4499537,4499585],"length":1,"stats":{"Line":0},"fn_name":null},{"line":47,"address":[4499601],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[4499819,4500018,4499646,4499695],"length":1,"stats":{"Line":0},"fn_name":null},{"line":50,"address":[4499783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":[4499826],"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":[4500227,4500209,4500092,4500394,4500033],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[4500173],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[4500216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[4500244],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[4500575,4500409],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":20},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","docker","v2.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod handlers;\npub mod routes;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","docker.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod constants;\npub mod error_util;\npub mod v2;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","lib.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n#![allow(mixed_script_confusables)] // This is to allow structs created by a derive macro to have private fields that begin with the grek letter π\n\npub mod artifact_service;\npub mod cli_commands;\npub mod docker;\npub mod logging;\npub mod network;\npub mod node_api;\npub mod transparency_log;\npub mod util;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","logging","http.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse log::trace;\nuse std::convert::Infallible;\nuse warp::http::HeaderMap;\nuse warp::Filter;\n\npub fn log_headers() -\u003e impl Filter\u003cExtract = (), Error = Infallible\u003e + Copy {\n    warp::header::headers_cloned()\n        .map(|headers: HeaderMap| {\n            for (k, v) in headers.iter() {\n                // Error from `to_str` should be handled properly\n                trace!(target: \"pyrsia_registry\", \"{}: {}\", k, v.to_str().expect(\"Failed to print header value\"))\n            }\n        })\n        .untuple_one()\n}\n","traces":[{"line":22,"address":[4832624],"length":1,"stats":{"Line":0},"fn_name":"log_headers"},{"line":23,"address":[4832625],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":2},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","logging.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod http;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","network","artifact_protocol.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::network::client::ArtifactType;\nuse async_trait::async_trait;\nuse futures::prelude::*;\nuse libp2p::core::upgrade::{read_length_prefixed, write_length_prefixed, ProtocolName};\nuse libp2p::request_response::RequestResponseCodec;\nuse log::debug;\nuse std::io;\n\n#[derive(Debug, Clone)]\npub struct ArtifactExchangeProtocol();\n/// The `ArtifactExchangeCodec` defines the request and response types\n/// for the [`RequestResponse`](crate::RequestResponse) protocol for\n/// exchanging artifacts. At the moment, the implementation for\n/// encoding/decoding writes all bytes of a single artifact at once.\n#[derive(Clone)]\npub struct ArtifactExchangeCodec();\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct ArtifactRequest(pub ArtifactType, pub String);\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct ArtifactResponse(pub Vec\u003cu8\u003e);\n\nimpl ProtocolName for ArtifactExchangeProtocol {\n    fn protocol_name(\u0026self) -\u003e \u0026[u8] {\n        \"/artifact-exchange/1\".as_bytes()\n    }\n}\n\n#[async_trait]\nimpl RequestResponseCodec for ArtifactExchangeCodec {\n    type Protocol = ArtifactExchangeProtocol;\n    type Request = ArtifactRequest;\n    type Response = ArtifactResponse;\n\n    async fn read_request\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026ArtifactExchangeProtocol,\n        io: \u0026mut T,\n    ) -\u003e io::Result\u003cSelf::Request\u003e\n    where\n        T: AsyncRead + Unpin + Send,\n    {\n        let type_vec = read_length_prefixed(io, 1_000).await?;\n        if type_vec.is_empty() {\n            return Err(io::ErrorKind::UnexpectedEof.into());\n        }\n\n        let hash_vec = read_length_prefixed(io, 1_000_000).await?;\n        if hash_vec.is_empty() {\n            return Err(io::ErrorKind::UnexpectedEof.into());\n        }\n\n        let artifact_type = match type_vec[0] {\n            1 =\u003e ArtifactType::Artifact,\n            _ =\u003e return Err(io::ErrorKind::InvalidData.into()),\n        };\n\n        let artifact_hash = String::from_utf8(hash_vec).unwrap();\n        debug!(\n            \"Read ArtifactRequest: {:?}={:?}\",\n            artifact_type, artifact_hash\n        );\n\n        Ok(ArtifactRequest(artifact_type, artifact_hash))\n    }\n\n    async fn read_response\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026ArtifactExchangeProtocol,\n        io: \u0026mut T,\n    ) -\u003e io::Result\u003cSelf::Response\u003e\n    where\n        T: AsyncRead + Unpin + Send,\n    {\n        let vec = read_length_prefixed(io, 100_000_000).await?;\n\n        if vec.is_empty() {\n            return Err(io::ErrorKind::UnexpectedEof.into());\n        }\n\n        Ok(ArtifactResponse(vec))\n    }\n\n    async fn write_request\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026ArtifactExchangeProtocol,\n        io: \u0026mut T,\n        ArtifactRequest(artifact_type, artifact_hash): ArtifactRequest,\n    ) -\u003e io::Result\u003c()\u003e\n    where\n        T: AsyncWrite + Unpin + Send,\n    {\n        debug!(\n            \"Write ArtifactRequest: {:?}={:?}\",\n            artifact_type, artifact_hash\n        );\n\n        let artifact_data_type: Vec\u003cu8\u003e = match artifact_type {\n            ArtifactType::Artifact =\u003e vec![1],\n        };\n\n        write_length_prefixed(io, artifact_data_type).await?;\n        write_length_prefixed(io, artifact_hash).await?;\n        io.close().await?;\n\n        Ok(())\n    }\n\n    async fn write_response\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026ArtifactExchangeProtocol,\n        io: \u0026mut T,\n        ArtifactResponse(data): ArtifactResponse,\n    ) -\u003e io::Result\u003c()\u003e\n    where\n        T: AsyncWrite + Unpin + Send,\n    {\n        write_length_prefixed(io, data).await?;\n        io.close().await?;\n\n        Ok(())\n    }\n}\n","traces":[{"line":39,"address":[4720448],"length":1,"stats":{"Line":1},"fn_name":"protocol_name"},{"line":50,"address":[7785872],"length":1,"stats":{"Line":0},"fn_name":"read_request\u003cmultistream_select::negotiated::Negotiated\u003clibp2p_core::muxing::SubstreamRef\u003calloc::sync::Arc\u003clibp2p_core::muxing::StreamMuxerBox\u003e\u003e\u003e\u003e"},{"line":58,"address":[8252729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":[7787344,7787166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":60,"address":[7787427],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[8252606],"length":1,"stats":{"Line":0},"fn_name":null},{"line":64,"address":[7787964,7788071],"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":[7788157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":[7788241,7788126],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":70,"address":[7788309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[7788371,7788246],"length":1,"stats":{"Line":0},"fn_name":null},{"line":74,"address":[7788570,7788405,7788494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":76,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":79,"address":[7788889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[7789104],"length":1,"stats":{"Line":0},"fn_name":"read_response\u003cmultistream_select::negotiated::Negotiated\u003clibp2p_core::muxing::SubstreamRef\u003calloc::sync::Arc\u003clibp2p_core::muxing::StreamMuxerBox\u003e\u003e\u003e\u003e"},{"line":90,"address":[8253054],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[7790449,7790278],"length":1,"stats":{"Line":0},"fn_name":null},{"line":93,"address":[7790725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[7790500],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[7790816],"length":1,"stats":{"Line":0},"fn_name":"write_request\u003cmultistream_select::negotiated::Negotiated\u003clibp2p_core::muxing::SubstreamRef\u003calloc::sync::Arc\u003clibp2p_core::muxing::StreamMuxerBox\u003e\u003e\u003e\u003e"},{"line":108,"address":[7791776,7791725,7791632,7791867],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[7792210],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[7791432,7791279,7792271,7792755,7792809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[7791383,7792700,7792875,7793227,7793284,7791300],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[7793663,7793608,7793316,7793211,7791318],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[7793571],"length":1,"stats":{"Line":0},"fn_name":null},{"line":124,"address":[7793968],"length":1,"stats":{"Line":0},"fn_name":"write_response\u003cmultistream_select::negotiated::Negotiated\u003clibp2p_core::muxing::SubstreamRef\u003calloc::sync::Arc\u003clibp2p_core::muxing::StreamMuxerBox\u003e\u003e\u003e\u003e"},{"line":133,"address":[7794482,7794754,7794871,7794556,7795259,7795205],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[7795579,7795311,7794500,7795189,7795634],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[7795549],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":1,"coverable":33},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","network","behaviour.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::network::artifact_protocol::{ArtifactExchangeCodec, ArtifactRequest, ArtifactResponse};\nuse crate::network::idle_metric_protocol::{\n    IdleMetricExchangeCodec, IdleMetricRequest, IdleMetricResponse,\n};\n\nuse libp2p::identify::{Identify, IdentifyEvent};\nuse libp2p::kad::record::store::MemoryStore;\nuse libp2p::kad::{Kademlia, KademliaEvent};\nuse libp2p::request_response::{RequestResponse, RequestResponseEvent};\nuse libp2p::NetworkBehaviour;\n\n/// Defines the [`NetworkBehaviour`] to be used in the libp2p\n/// Swarm. The PyrsiaNetworkBehaviour consists of the following\n/// behaviours:\n///\n/// * [`Identify`]\n/// * [`Kademlia`]\n/// * [`RequestResponse`] for exchanging artifacts\n#[derive(NetworkBehaviour)]\n#[behaviour(out_event = \"PyrsiaNetworkEvent\")]\npub struct PyrsiaNetworkBehaviour {\n    pub identify: Identify,\n    pub kademlia: Kademlia\u003cMemoryStore\u003e,\n    pub request_response: RequestResponse\u003cArtifactExchangeCodec\u003e,\n    pub idle_metric_request_response: RequestResponse\u003cIdleMetricExchangeCodec\u003e,\n}\n\n/// Each event in the `PyrsiaNetworkBehaviour` is wrapped in a\n/// `PyrsiaNetworkEvent`.\n#[derive(Debug)]\npub enum PyrsiaNetworkEvent {\n    Identify(IdentifyEvent),\n    Kademlia(KademliaEvent),\n    RequestResponse(RequestResponseEvent\u003cArtifactRequest, ArtifactResponse\u003e),\n    IdleMetricRequestResponse(RequestResponseEvent\u003cIdleMetricRequest, IdleMetricResponse\u003e),\n}\n\nimpl From\u003cIdentifyEvent\u003e for PyrsiaNetworkEvent {\n    fn from(event: IdentifyEvent) -\u003e Self {\n        PyrsiaNetworkEvent::Identify(event)\n    }\n}\n\nimpl From\u003cKademliaEvent\u003e for PyrsiaNetworkEvent {\n    fn from(event: KademliaEvent) -\u003e Self {\n        PyrsiaNetworkEvent::Kademlia(event)\n    }\n}\n\nimpl From\u003cRequestResponseEvent\u003cArtifactRequest, ArtifactResponse\u003e\u003e for PyrsiaNetworkEvent {\n    fn from(event: RequestResponseEvent\u003cArtifactRequest, ArtifactResponse\u003e) -\u003e Self {\n        PyrsiaNetworkEvent::RequestResponse(event)\n    }\n}\n\nimpl From\u003cRequestResponseEvent\u003cIdleMetricRequest, IdleMetricResponse\u003e\u003e for PyrsiaNetworkEvent {\n    fn from(event: RequestResponseEvent\u003cIdleMetricRequest, IdleMetricResponse\u003e) -\u003e Self {\n        PyrsiaNetworkEvent::IdleMetricRequestResponse(event)\n    }\n}\n","traces":[{"line":51,"address":[6147184],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":52,"address":[6147201],"length":1,"stats":{"Line":1},"fn_name":null},{"line":57,"address":[6147280],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":58,"address":[6147296],"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":[6147360],"length":1,"stats":{"Line":0},"fn_name":"from"},{"line":64,"address":[6147377],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":2,"coverable":6},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","network","client","command.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::network::artifact_protocol::ArtifactResponse;\nuse crate::network::client::{ArtifactHash, ArtifactType};\nuse crate::network::idle_metric_protocol::{IdleMetricResponse, PeerMetrics};\nuse futures::channel::oneshot;\nuse libp2p::core::{Multiaddr, PeerId};\nuse libp2p::request_response::ResponseChannel;\nuse std::collections::HashSet;\nuse strum_macros::Display;\n\n/// Commands are sent by the [`Client`] to the [`PyrsiaEventLoop`].\n/// Each command matches exactly with one if the functions that are\n/// defined in `Client`.\n#[derive(Debug, Display)]\npub enum Command {\n    Listen {\n        addr: Multiaddr,\n        sender: oneshot::Sender\u003canyhow::Result\u003c()\u003e\u003e,\n    },\n    Dial {\n        peer_addr: Multiaddr,\n        sender: oneshot::Sender\u003canyhow::Result\u003c()\u003e\u003e,\n    },\n    ListPeers {\n        peer_id: PeerId,\n        sender: oneshot::Sender\u003cHashSet\u003cPeerId\u003e\u003e,\n    },\n    Provide {\n        artifact_type: ArtifactType,\n        artifact_hash: ArtifactHash,\n        sender: oneshot::Sender\u003c()\u003e,\n    },\n    ListProviders {\n        artifact_type: ArtifactType,\n        artifact_hash: ArtifactHash,\n        sender: oneshot::Sender\u003cHashSet\u003cPeerId\u003e\u003e,\n    },\n    RequestArtifact {\n        artifact_type: ArtifactType,\n        artifact_hash: ArtifactHash,\n        peer: PeerId,\n        sender: oneshot::Sender\u003canyhow::Result\u003cVec\u003cu8\u003e\u003e\u003e,\n    },\n    RespondArtifact {\n        artifact: Vec\u003cu8\u003e,\n        channel: ResponseChannel\u003cArtifactResponse\u003e,\n    },\n    RequestIdleMetric {\n        peer: PeerId,\n        sender: oneshot::Sender\u003canyhow::Result\u003cPeerMetrics\u003e\u003e,\n    },\n    RespondIdleMetric {\n        metric: PeerMetrics,\n        channel: ResponseChannel\u003cIdleMetricResponse\u003e,\n    },\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use futures::channel::oneshot;\n\n    #[test]\n    fn command_correctly_implements_display() {\n        let (sender, _) = oneshot::channel();\n        let addr: Multiaddr = \"/ip4/127.0.0.1\".parse().unwrap();\n\n        assert_eq!(\n            String::from(\"Listen\"),\n            Command::Listen { addr, sender }.to_string()\n        );\n    }\n}\n","traces":[{"line":80,"address":[5193472,5193477],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":81,"address":[6624407],"length":1,"stats":{"Line":1},"fn_name":null},{"line":82,"address":[6624537,6624468],"length":1,"stats":{"Line":2},"fn_name":null},{"line":84,"address":[6624728],"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":[6624579],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[6624606],"length":1,"stats":{"Line":1},"fn_name":null}],"covered":6,"coverable":6},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","network","client.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod command;\n\nuse crate::network::artifact_protocol::ArtifactResponse;\nuse crate::network::client::command::Command;\nuse crate::network::idle_metric_protocol::{IdleMetricResponse, PeerMetrics};\nuse futures::channel::{mpsc, oneshot};\nuse futures::prelude::*;\nuse libp2p::core::{Multiaddr, PeerId};\nuse libp2p::request_response::ResponseChannel;\nuse log::debug;\nuse std::collections::HashSet;\n\n/* peer metrics support */\nconst PEER_METRIC_THRESHOLD: f64 = 0.5_f64;\n#[derive(Clone, Debug, PartialEq, PartialOrd)]\nstruct IdleMetric {\n    pub peer: PeerId,\n    pub metric: f64,\n}\n/* peer metric support */\n\nuse strum_macros::Display;\n/// Defines the different types of artifacts that can be transferred\n/// within the libp2p swarm.\n#[derive(Clone, Debug, Display, PartialEq, Eq)]\npub enum ArtifactType {\n    Artifact,\n}\n\n/// A utility struct for easily defining a hash from different\n/// types that can be used as a provisioning key within the\n/// libp2p swarm.\n#[derive(Clone, Debug, PartialEq, Eq)]\npub struct ArtifactHash {\n    pub hash: String,\n}\n\n/// Construct an ArtifactHash from `String`\nimpl From\u003cString\u003e for ArtifactHash {\n    fn from(hash: String) -\u003e Self {\n        ArtifactHash { hash }\n    }\n}\n\n/// Construct an ArtifactHash from `\u0026String`\nimpl From\u003c\u0026String\u003e for ArtifactHash {\n    fn from(hash: \u0026String) -\u003e Self {\n        ArtifactHash { hash: hash.clone() }\n    }\n}\n\n/// Construct an ArtifactHash from `\u0026str`\nimpl From\u003c\u0026str\u003e for ArtifactHash {\n    fn from(hash: \u0026str) -\u003e Self {\n        ArtifactHash {\n            hash: String::from(hash),\n        }\n    }\n}\n\n/// The `Client` provides entry points to interact with the libp2p swarm.\n#[derive(Clone)]\npub struct Client {\n    pub sender: mpsc::Sender\u003cCommand\u003e,\n    pub local_peer_id: PeerId,\n}\n\nimpl Client {\n    /// Instruct the swarm to start listening on the specified address.\n    pub async fn listen(\u0026mut self, addr: \u0026Multiaddr) -\u003e anyhow::Result\u003c()\u003e {\n        debug!(\"p2p::Client::listen {:?}\", addr);\n\n        let (sender, receiver) = oneshot::channel();\n        self.sender\n            .send(Command::Listen {\n                addr: addr.clone(),\n                sender,\n            })\n            .await?;\n        receiver.await?\n    }\n\n    /// Dial a peer with the specified address.\n    pub async fn dial(\u0026mut self, peer_addr: \u0026Multiaddr) -\u003e anyhow::Result\u003c()\u003e {\n        debug!(\"p2p::Client::dial {:?}\", peer_addr);\n\n        let (sender, receiver) = oneshot::channel();\n        self.sender\n            .send(Command::Dial {\n                peer_addr: peer_addr.clone(),\n                sender,\n            })\n            .await?;\n        receiver.await?\n    }\n\n    /// List the peers that this node is connected to.\n    pub async fn list_peers(\u0026mut self) -\u003e anyhow::Result\u003cHashSet\u003cPeerId\u003e\u003e {\n        let (sender, receiver) = oneshot::channel();\n        self.sender\n            .send(Command::ListPeers {\n                peer_id: self.local_peer_id,\n                sender,\n            })\n            .await?;\n        Ok(receiver.await?)\n    }\n\n    /// Inform the swarm that this node is currently a\n    /// provider of the artifact with the specified `type`\n    /// and `hash`.\n    pub async fn provide(\n        \u0026mut self,\n        artifact_type: ArtifactType,\n        artifact_hash: ArtifactHash,\n    ) -\u003e anyhow::Result\u003c()\u003e {\n        debug!(\n            \"p2p::Client::provide {:?}={:?}\",\n            artifact_type, artifact_hash\n        );\n\n        let (sender, receiver) = oneshot::channel();\n        self.sender\n            .send(Command::Provide {\n                artifact_type,\n                artifact_hash,\n                sender,\n            })\n            .await?;\n        Ok(receiver.await?)\n    }\n\n    /// List all peers in the swarm that are providing\n    /// the artifact with the specified `type` and `hash`.\n    pub async fn list_providers(\n        \u0026mut self,\n        artifact_type: ArtifactType,\n        artifact_hash: ArtifactHash,\n    ) -\u003e anyhow::Result\u003cHashSet\u003cPeerId\u003e\u003e {\n        debug!(\n            \"p2p::Client::list_providers {:?}={:?}\",\n            artifact_type, artifact_hash\n        );\n\n        let (sender, receiver) = oneshot::channel();\n        self.sender\n            .send(Command::ListProviders {\n                artifact_type,\n                artifact_hash,\n                sender,\n            })\n            .await?;\n        Ok(receiver.await?)\n    }\n\n    /// Request an artifact with the specified `type` and `hash`\n    /// from the swarm.\n    pub async fn request_artifact(\n        \u0026mut self,\n        peer: \u0026PeerId,\n        artifact_type: ArtifactType,\n        artifact_hash: ArtifactHash,\n    ) -\u003e anyhow::Result\u003cVec\u003cu8\u003e\u003e {\n        debug!(\n            \"p2p::Client::request_artifact {:?}: {:?}={:?}\",\n            peer, artifact_type, artifact_hash\n        );\n\n        let (sender, receiver) = oneshot::channel();\n        self.sender\n            .send(Command::RequestArtifact {\n                artifact_type,\n                artifact_hash,\n                peer: *peer,\n                sender,\n            })\n            .await?;\n        receiver.await?\n    }\n\n    /// Put the artifact as a response to an incoming artifact\n    /// request.\n    pub async fn respond_artifact(\n        \u0026mut self,\n        artifact: Vec\u003cu8\u003e,\n        channel: ResponseChannel\u003cArtifactResponse\u003e,\n    ) -\u003e anyhow::Result\u003c()\u003e {\n        debug!(\"p2p::Client::respond_artifact size={:?}\", artifact.len());\n\n        self.sender\n            .send(Command::RespondArtifact { artifact, channel })\n            .await?;\n\n        Ok(())\n    }\n\n    //get a peer with a low enough work load to download artifact otherwise the lowest work load of the set\n    //TODO: chunk the peers to some limit to keep from shotgunning the network\n    pub async fn get_idle_peer(\n        \u0026mut self,\n        providers: HashSet\u003cPeerId\u003e,\n    ) -\u003e anyhow::Result\u003cOption\u003cPeerId\u003e\u003e {\n        debug!(\n            \"p2p::Client::get_idle_peer() entered with {} peers\",\n            providers.len()\n        );\n        let mut idle_metrics: Vec\u003cIdleMetric\u003e = Vec::new();\n        for peer in providers.iter() {\n            let (sender, receiver) = oneshot::channel();\n            self.sender\n                .send(Command::RequestIdleMetric {\n                    peer: *peer,\n                    sender,\n                })\n                .await?;\n\n            match receiver.await.expect(\"Sender not to be dropped.\") {\n                Ok(peer_metric) =\u003e {\n                    let metric: f64 = f64::from_le_bytes(peer_metric.idle_metric);\n                    let idle_metric = IdleMetric {\n                        peer: *peer,\n                        metric,\n                    };\n                    if idle_metric.metric \u003c PEER_METRIC_THRESHOLD {\n                        debug!(\n                                \"p2p::Client::get_idle_peer() Found peer with a below threshold idle value {}\",\n                                metric\n                            );\n                        return Ok(Some(idle_metric.peer));\n                    } else {\n                        debug!(\n                            \"p2p::Client::get_idle_peer() Pushing idle peer with value {}\",\n                            metric\n                        );\n                        idle_metrics.push(idle_metric);\n                    }\n                }\n                Err(e) =\u003e {\n                    debug!(\n                            \"p2p::Client::get_idle_peer() Unable to get peer metric for peer {} error {}\",\n                            peer, e\n                        );\n                }\n            };\n        }\n\n        //sort the peers in ascending order according to their idle metric and return top of list\n        idle_metrics.sort_by(|a, b| a.metric.partial_cmp(\u0026b.metric).unwrap());\n        Ok(idle_metrics.first().map(|idle_metric| idle_metric.peer))\n    }\n\n    pub async fn respond_idle_metric(\n        \u0026mut self,\n        metric: PeerMetrics,\n        channel: ResponseChannel\u003cIdleMetricResponse\u003e,\n    ) -\u003e anyhow::Result\u003c()\u003e {\n        debug!(\n            \"p2p::Client::respond_idle_metric PeerMetrics metric ={:?}\",\n            metric\n        );\n\n        self.sender\n            .send(Command::RespondIdleMetric { metric, channel })\n            .await?;\n\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use libp2p::identity::Keypair;\n    use rand::distributions::Alphanumeric;\n    use rand::{thread_rng, Rng};\n\n    #[tokio::test]\n    async fn test_listen() {\n        let (sender, mut receiver) = mpsc::channel(1);\n\n        let mut client = Client {\n            sender,\n            local_peer_id: Keypair::generate_ed25519().public().to_peer_id(),\n        };\n\n        let address: Multiaddr = \"/ip4/127.0.0.1\".parse().unwrap();\n        let cloned_address = address.clone();\n        tokio::spawn(async move { client.listen(\u0026address).await });\n\n        futures::select! {\n            command = receiver.next() =\u003e match command {\n                Some(Command::Listen { addr, sender }) =\u003e {\n                    assert_eq!(addr, cloned_address);\n                    let _ = sender.send(Ok(()));\n                },\n                _ =\u003e panic!(\"Command must match Command::Listen\")\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_dial() {\n        let (sender, mut receiver) = mpsc::channel(1);\n\n        let mut client = Client {\n            sender,\n            local_peer_id: Keypair::generate_ed25519().public().to_peer_id(),\n        };\n\n        let address: Multiaddr = \"/ip4/127.0.0.1\".parse().unwrap();\n        let cloned_address = address.clone();\n        tokio::spawn(async move { client.dial(\u0026address).await });\n\n        futures::select! {\n            command = receiver.next() =\u003e match command {\n                Some(Command::Dial { peer_addr, sender }) =\u003e {\n                    assert_eq!(peer_addr, cloned_address);\n                    let _ = sender.send(Ok(()));\n                },\n                _ =\u003e panic!(\"Command must match Command::Dial\")\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_list_peers() {\n        let (sender, mut receiver) = mpsc::channel(1);\n\n        let local_peer_id = Keypair::generate_ed25519().public().to_peer_id();\n        let mut client = Client {\n            sender,\n            local_peer_id,\n        };\n\n        tokio::spawn(async move { client.list_peers().await });\n\n        futures::select! {\n            command = receiver.next() =\u003e match command {\n                Some(Command::ListPeers { peer_id, sender }) =\u003e {\n                    assert_eq!(peer_id, local_peer_id);\n                    let _ = sender.send(Default::default());\n                },\n                _ =\u003e panic!(\"Command must match Command::ListPeers\")\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_get_idle_metric() {\n        let (sender, mut receiver) = mpsc::channel(1);\n\n        let local_peer_id = Keypair::generate_ed25519().public().to_peer_id();\n        let mut client = Client {\n            sender,\n            local_peer_id,\n        };\n\n        let mut peers: HashSet\u003cPeerId\u003e = HashSet::new();\n        peers.insert(client.local_peer_id);\n        tokio::spawn(async move { client.get_idle_peer(peers).await });\n\n        futures::select! {\n            command = receiver.next() =\u003e match command {\n                Some(Command::RequestIdleMetric { peer, sender }) =\u003e {\n                    assert_eq!(peer, local_peer_id);\n                    let peer_metric = PeerMetrics {\n                        idle_metric: 8675309f64.to_le_bytes(),\n                    };\n                    let _ = sender.send(Ok(peer_metric));\n                },\n                None =\u003e {},\n                _ =\u003e panic!(\"Command must match Command::RequestIdleMetric\")\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_provide() {\n        let (sender, mut receiver) = mpsc::channel(1);\n\n        let mut client = Client {\n            sender,\n            local_peer_id: Keypair::generate_ed25519().public().to_peer_id(),\n        };\n\n        let random_hash: String = thread_rng()\n            .sample_iter(\u0026Alphanumeric)\n            .take(30)\n            .map(char::from)\n            .collect();\n        let cloned_random_hash = random_hash.clone();\n        tokio::spawn(async move {\n            client\n                .provide(ArtifactType::Artifact, random_hash.into())\n                .await\n        });\n\n        futures::select! {\n            command = receiver.next() =\u003e match command {\n                Some(Command::Provide { artifact_type, artifact_hash, sender }) =\u003e {\n                    assert_eq!(artifact_type, ArtifactType::Artifact);\n                    assert_eq!(artifact_hash.hash, cloned_random_hash);\n                    let _ = sender.send(());\n                },\n                _ =\u003e panic!(\"Command must match Command::Provide\")\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_list_providers() {\n        let (sender, mut receiver) = mpsc::channel(1);\n\n        let mut client = Client {\n            sender,\n            local_peer_id: Keypair::generate_ed25519().public().to_peer_id(),\n        };\n\n        let random_hash: String = thread_rng()\n            .sample_iter(\u0026Alphanumeric)\n            .take(30)\n            .map(char::from)\n            .collect();\n        let cloned_random_hash = random_hash.clone();\n        tokio::spawn(async move {\n            client\n                .list_providers(ArtifactType::Artifact, random_hash.into())\n                .await\n        });\n\n        futures::select! {\n            command = receiver.next() =\u003e match command {\n                Some(Command::ListProviders { artifact_type, artifact_hash, sender }) =\u003e {\n                    assert_eq!(artifact_type, ArtifactType::Artifact);\n                    assert_eq!(artifact_hash.hash, cloned_random_hash);\n                    let _ = sender.send(Default::default());\n                },\n                _ =\u003e panic!(\"Command must match Command::ListProviders\")\n            }\n        }\n    }\n\n    #[tokio::test]\n    async fn test_request_artifact() {\n        let (sender, mut receiver) = mpsc::channel(1);\n\n        let mut client = Client {\n            sender,\n            local_peer_id: Keypair::generate_ed25519().public().to_peer_id(),\n        };\n\n        let other_peer_id = Keypair::generate_ed25519().public().to_peer_id();\n        let random_hash: String = thread_rng()\n            .sample_iter(\u0026Alphanumeric)\n            .take(30)\n            .map(char::from)\n            .collect();\n        let cloned_random_hash = random_hash.clone();\n        tokio::spawn(async move {\n            client\n                .request_artifact(\u0026other_peer_id, ArtifactType::Artifact, random_hash.into())\n                .await\n        });\n\n        futures::select! {\n            command = receiver.next() =\u003e match command {\n                Some(Command::RequestArtifact { peer, artifact_type, artifact_hash, sender }) =\u003e {\n                    assert_eq!(peer, other_peer_id);\n                    assert_eq!(artifact_type, ArtifactType::Artifact);\n                    assert_eq!(artifact_hash.hash, cloned_random_hash);\n                    let _ = sender.send(Ok(vec![]));\n                },\n                _ =\u003e panic!(\"Command must match Command::RequestArtifact\")\n            }\n        }\n    }\n\n    #[test]\n    fn test_artifact_from_str_ref() {\n        let str = \"abcd\";\n\n        let artifact = ArtifactHash::from(str);\n\n        assert_eq!(artifact.hash, str);\n    }\n\n    #[test]\n    fn test_artifact_from_string() {\n        let str = \"abcd\";\n\n        let artifact = ArtifactHash::from(str.to_string());\n\n        assert_eq!(artifact.hash, str);\n    }\n\n    #[test]\n    fn test_artifact_from_string_ref() {\n        let str = String::from(\"abcd\");\n\n        let artifact = ArtifactHash::from(\u0026str);\n\n        assert_eq!(artifact.hash, str);\n    }\n}\n","traces":[{"line":56,"address":[7346256],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":63,"address":[7346320],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":64,"address":[7346339],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[7346400],"length":1,"stats":{"Line":1},"fn_name":"from"},{"line":72,"address":[7346423],"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":[4731191,4729207,4729344,4729579,4729498,4729168],"length":1,"stats":{"Line":5},"fn_name":"{async_fn#0}"},{"line":87,"address":[4729711,4729300,4729565,4729620],"length":1,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[4729954],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[4730110,4730227,4730430,4730349,4730529],"length":1,"stats":{"Line":4},"fn_name":null},{"line":91,"address":[4730070],"length":1,"stats":{"Line":1},"fn_name":null},{"line":92,"address":[4730024],"length":1,"stats":{"Line":1},"fn_name":null},{"line":93,"address":[4730058],"length":1,"stats":{"Line":1},"fn_name":null},{"line":95,"address":[4730509],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[4731196,4730490,4729392,4730789,4730947,4730741],"length":1,"stats":{"Line":5},"fn_name":null},{"line":100,"address":[4733486,4731727,4731492,4731296,4731646,4731335],"length":1,"stats":{"Line":5},"fn_name":"{async_fn#0}"},{"line":101,"address":[4731448,4731859,4731713,4731768],"length":1,"stats":{"Line":3},"fn_name":null},{"line":103,"address":[4732102],"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":[4732644,4732522,4732725,4732824,4732405],"length":1,"stats":{"Line":4},"fn_name":null},{"line":105,"address":[4732285],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[4732180],"length":1,"stats":{"Line":1},"fn_name":null},{"line":107,"address":[4732239],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[4732273],"length":1,"stats":{"Line":1},"fn_name":null},{"line":110,"address":[4732804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":111,"address":[4733242,4732785,4733491,4731540,4733036,4733084],"length":1,"stats":{"Line":5},"fn_name":null},{"line":115,"address":[4733850,4733717,4733627,4735205,4733584,4734136],"length":1,"stats":{"Line":4},"fn_name":"{async_fn#0}"},{"line":116,"address":[4733697,4733930],"length":1,"stats":{"Line":2},"fn_name":null},{"line":117,"address":[4734124,4734391,4734554,4734281,4734458],"length":1,"stats":{"Line":4},"fn_name":null},{"line":118,"address":[4734012],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[4733943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":120,"address":[4734003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[4734534],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[4733756,4734881,4734764,4734515,4735210,4734719],"length":1,"stats":{"Line":4},"fn_name":null},{"line":129,"address":[7346720],"length":1,"stats":{"Line":1},"fn_name":"provide"},{"line":134,"address":[4735444,4735760,4735709,4735851],"length":1,"stats":{"Line":3},"fn_name":null},{"line":139,"address":[4736149],"length":1,"stats":{"Line":1},"fn_name":null},{"line":140,"address":[4736553,4736634,4736316,4736434,4736733],"length":1,"stats":{"Line":4},"fn_name":null},{"line":141,"address":[4736252],"length":1,"stats":{"Line":1},"fn_name":null},{"line":143,"address":[4736212],"length":1,"stats":{"Line":1},"fn_name":null},{"line":144,"address":[4736240],"length":1,"stats":{"Line":1},"fn_name":null},{"line":146,"address":[4736713],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[4737288,4736951,4736903,4736694,4735536,4737090],"length":1,"stats":{"Line":4},"fn_name":null},{"line":152,"address":[7346816],"length":1,"stats":{"Line":1},"fn_name":"list_providers"},{"line":157,"address":[4737882,4737620,4738009,4737933],"length":1,"stats":{"Line":3},"fn_name":null},{"line":162,"address":[4738301],"length":1,"stats":{"Line":1},"fn_name":null},{"line":163,"address":[4738581,4738773,4738464,4738872,4738697],"length":1,"stats":{"Line":4},"fn_name":null},{"line":164,"address":[4738400],"length":1,"stats":{"Line":1},"fn_name":null},{"line":166,"address":[4738360],"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":[4738388],"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":[4738852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[4738833,4737712,4739547,4739027,4739199,4739075],"length":1,"stats":{"Line":4},"fn_name":null},{"line":175,"address":[7346912],"length":1,"stats":{"Line":1},"fn_name":"request_artifact"},{"line":181,"address":[4739916,4740181,4740232,4740323],"length":1,"stats":{"Line":3},"fn_name":null},{"line":186,"address":[4740700],"length":1,"stats":{"Line":1},"fn_name":null},{"line":187,"address":[4741006,4741242,4741318,4741417,4741123],"length":1,"stats":{"Line":4},"fn_name":null},{"line":188,"address":[4740862],"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":[4740759],"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":[4740787],"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":[4740850],"length":1,"stats":{"Line":1},"fn_name":null},{"line":194,"address":[4741397],"length":1,"stats":{"Line":0},"fn_name":null},{"line":195,"address":[4742102,4741572,4741378,4741748,4740008,4741620],"length":1,"stats":{"Line":4},"fn_name":null},{"line":200,"address":[7347008],"length":1,"stats":{"Line":0},"fn_name":"respond_artifact"},{"line":216,"address":[7347120],"length":1,"stats":{"Line":1},"fn_name":"get_idle_peer"},{"line":220,"address":[4743012,4742896,4742805,4742754,4742485],"length":1,"stats":{"Line":3},"fn_name":null},{"line":222,"address":[4742973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":224,"address":[4743192],"length":1,"stats":{"Line":1},"fn_name":null},{"line":225,"address":[4745365,4743459,4743211,4743313],"length":1,"stats":{"Line":3},"fn_name":null},{"line":226,"address":[4743474],"length":1,"stats":{"Line":1},"fn_name":null},{"line":227,"address":[4744008,4743747,4743550,4743871,4744096,4744211],"length":1,"stats":{"Line":5},"fn_name":null},{"line":228,"address":[4743635],"length":1,"stats":{"Line":1},"fn_name":null},{"line":229,"address":[4743554],"length":1,"stats":{"Line":1},"fn_name":null},{"line":230,"address":[4743620],"length":1,"stats":{"Line":1},"fn_name":null},{"line":232,"address":[4744191],"length":1,"stats":{"Line":0},"fn_name":null},{"line":234,"address":[4744277,4742577,4744316,4744162],"length":1,"stats":{"Line":4},"fn_name":null},{"line":235,"address":[4744717],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[4744733,4745409],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[4745418],"length":1,"stats":{"Line":0},"fn_name":null},{"line":241,"address":[4745499],"length":1,"stats":{"Line":0},"fn_name":null},{"line":242,"address":[4745559,4745683],"length":1,"stats":{"Line":0},"fn_name":null},{"line":246,"address":[4745904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":248,"address":[4745518,4746265,4746347],"length":1,"stats":{"Line":0},"fn_name":null},{"line":252,"address":[4746576],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[4744776],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[4744887,4744792,4744978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[4746772,4747056,4747101,4743421],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":266,"address":[4747168,4746887,4747152,4746787],"length":1,"stats":{"Line":0},"fn_name":"{closure#1}"},{"line":269,"address":[7347216],"length":1,"stats":{"Line":0},"fn_name":"respond_idle_metric"},{"line":295,"address":[4724080,4724087,4724184],"length":1,"stats":{"Line":6},"fn_name":"test_listen"},{"line":296,"address":[6460389,6460181],"length":1,"stats":{"Line":2},"fn_name":null},{"line":300,"address":[6460540,6460626,6460472],"length":1,"stats":{"Line":3},"fn_name":null},{"line":303,"address":[6460985,6461145],"length":1,"stats":{"Line":2},"fn_name":null},{"line":304,"address":[6461152],"length":1,"stats":{"Line":1},"fn_name":null},{"line":305,"address":[6461201,6461409,6463063,6461493,6462880,6462913],"length":1,"stats":{"Line":5},"fn_name":"{async_block#0}"},{"line":307,"address":[4724204,4724260,4724107],"length":1,"stats":{"Line":7},"fn_name":null},{"line":308,"address":[6461532,6461888,6461774],"length":1,"stats":{"Line":3},"fn_name":null},{"line":309,"address":[6461952],"length":1,"stats":{"Line":1},"fn_name":null},{"line":310,"address":[6462294,6462182,6462008],"length":1,"stats":{"Line":2},"fn_name":null},{"line":311,"address":[6462231,6462357],"length":1,"stats":{"Line":2},"fn_name":null},{"line":313,"address":[6462089,6461902],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[4724503,4724606,4724496],"length":1,"stats":{"Line":6},"fn_name":"test_dial"},{"line":320,"address":[6464485,6464693],"length":1,"stats":{"Line":2},"fn_name":null},{"line":322,"address":[6464883,6464808,6464740],"length":1,"stats":{"Line":3},"fn_name":null},{"line":328,"address":[6465240,6465394],"length":1,"stats":{"Line":2},"fn_name":null},{"line":329,"address":[6465401],"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":[6467456,6465724,6467489,6465456,6465808,6467651],"length":1,"stats":{"Line":5},"fn_name":"{async_block#0}"},{"line":332,"address":[4724626,4724682,4724529],"length":1,"stats":{"Line":7},"fn_name":null},{"line":333,"address":[6466089,6466203,6465847],"length":1,"stats":{"Line":3},"fn_name":null},{"line":334,"address":[6466267],"length":1,"stats":{"Line":1},"fn_name":null},{"line":335,"address":[6466403,6466729,6466577],"length":1,"stats":{"Line":2},"fn_name":null},{"line":336,"address":[6466786,6466638,6466854],"length":1,"stats":{"Line":2},"fn_name":null},{"line":337,"address":[6466916,6466792],"length":1,"stats":{"Line":2},"fn_name":null},{"line":339,"address":[6466484,6466217],"length":1,"stats":{"Line":0},"fn_name":null},{"line":345,"address":[4724999,4724992,4725102],"length":1,"stats":{"Line":6},"fn_name":"test_list_peers"},{"line":346,"address":[6469247,6469059],"length":1,"stats":{"Line":2},"fn_name":null},{"line":348,"address":[6469359,6469428,6469294],"length":1,"stats":{"Line":3},"fn_name":null},{"line":354,"address":[6471280,6471466,6471323,6469778],"length":1,"stats":{"Line":3},"fn_name":"{async_block#0}"},{"line":356,"address":[4725025,4725178,4725122],"length":1,"stats":{"Line":7},"fn_name":null},{"line":357,"address":[6470326,6469999,6470229],"length":1,"stats":{"Line":3},"fn_name":null},{"line":358,"address":[6470387],"length":1,"stats":{"Line":1},"fn_name":null},{"line":359,"address":[6470783,6470499,6470673],"length":1,"stats":{"Line":2},"fn_name":null},{"line":360,"address":[6470722,6470945,6470836],"length":1,"stats":{"Line":2},"fn_name":null},{"line":362,"address":[6470340,6470580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":368,"address":[4725472,4725582,4725479],"length":1,"stats":{"Line":6},"fn_name":"test_get_idle_metric"},{"line":369,"address":[6472888,6473104],"length":1,"stats":{"Line":2},"fn_name":null},{"line":371,"address":[6473154,6473300,6473225],"length":1,"stats":{"Line":3},"fn_name":null},{"line":377,"address":[6473663],"length":1,"stats":{"Line":1},"fn_name":null},{"line":378,"address":[6473686],"length":1,"stats":{"Line":1},"fn_name":null},{"line":379,"address":[6473859,6476043,6474100,6476000,6476235],"length":1,"stats":{"Line":4},"fn_name":"{async_block#0}"},{"line":381,"address":[4725602,4725655,4725505],"length":1,"stats":{"Line":7},"fn_name":null},{"line":382,"address":[6474181,6474631,6474902],"length":1,"stats":{"Line":3},"fn_name":null},{"line":383,"address":[6474924],"length":1,"stats":{"Line":1},"fn_name":null},{"line":384,"address":[6475036,6475289,6475210],"length":1,"stats":{"Line":2},"fn_name":null},{"line":385,"address":[6475371],"length":1,"stats":{"Line":1},"fn_name":null},{"line":386,"address":[6475267,6475347],"length":1,"stats":{"Line":2},"fn_name":null},{"line":388,"address":[6475387],"length":1,"stats":{"Line":1},"fn_name":null},{"line":390,"address":[6474897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":391,"address":[6475117,6474855],"length":1,"stats":{"Line":0},"fn_name":null},{"line":397,"address":[4725888,4725895,4725995],"length":1,"stats":{"Line":6},"fn_name":"test_provide"},{"line":398,"address":[6477733,6477941],"length":1,"stats":{"Line":2},"fn_name":null},{"line":402,"address":[6478024,6478092,6478178],"length":1,"stats":{"Line":3},"fn_name":null},{"line":405,"address":[6478660,6478537],"length":1,"stats":{"Line":2},"fn_name":null},{"line":410,"address":[6478754],"length":1,"stats":{"Line":1},"fn_name":null},{"line":411,"address":[6478784,6481213,6480625,6480592,6479004,6480736,6479088,6480810],"length":1,"stats":{"Line":5},"fn_name":"{async_block#0}"},{"line":412,"address":[6481125,6480678,6480995,6480891],"length":1,"stats":{"Line":3},"fn_name":null},{"line":413,"address":[6480757,6480948,6481146,6481012,6480686],"length":1,"stats":{"Line":2},"fn_name":null},{"line":417,"address":[4726015,4726071,4725918],"length":1,"stats":{"Line":7},"fn_name":null},{"line":418,"address":[6479483,6479369,6479127],"length":1,"stats":{"Line":3},"fn_name":null},{"line":419,"address":[6479539],"length":1,"stats":{"Line":1},"fn_name":null},{"line":420,"address":[6479788,6479940,6479619],"length":1,"stats":{"Line":2},"fn_name":null},{"line":421,"address":[6479849,6479997,6480040],"length":1,"stats":{"Line":2},"fn_name":null},{"line":422,"address":[6480003],"length":1,"stats":{"Line":1},"fn_name":null},{"line":424,"address":[6479695,6479497],"length":1,"stats":{"Line":0},"fn_name":null},{"line":430,"address":[4726343,4726443,4726336],"length":1,"stats":{"Line":6},"fn_name":"test_list_providers"},{"line":431,"address":[6482181,6482397],"length":1,"stats":{"Line":2},"fn_name":null},{"line":435,"address":[6482634,6482548,6482480],"length":1,"stats":{"Line":3},"fn_name":null},{"line":438,"address":[6482993,6483116],"length":1,"stats":{"Line":2},"fn_name":null},{"line":443,"address":[6483210],"length":1,"stats":{"Line":1},"fn_name":null},{"line":444,"address":[6485900,6483544,6485184,6485412,6485338,6485227,6483460,6483240],"length":1,"stats":{"Line":5},"fn_name":"{async_block#0}"},{"line":445,"address":[6485597,6485493,6485280,6485707],"length":1,"stats":{"Line":3},"fn_name":null},{"line":446,"address":[6485288,6485835,6485613,6485550,6485359],"length":1,"stats":{"Line":2},"fn_name":null},{"line":450,"address":[4726366,4726463,4726519],"length":1,"stats":{"Line":7},"fn_name":null},{"line":451,"address":[6483825,6483583,6483939],"length":1,"stats":{"Line":3},"fn_name":null},{"line":452,"address":[6483995],"length":1,"stats":{"Line":1},"fn_name":null},{"line":453,"address":[6484244,6484396,6484075],"length":1,"stats":{"Line":2},"fn_name":null},{"line":454,"address":[6484453,6484520,6484305],"length":1,"stats":{"Line":2},"fn_name":null},{"line":455,"address":[6484682,6484573,6484459],"length":1,"stats":{"Line":2},"fn_name":null},{"line":457,"address":[6484151,6483953],"length":1,"stats":{"Line":0},"fn_name":null},{"line":463,"address":[4726784,4726894,4726791],"length":1,"stats":{"Line":6},"fn_name":"test_request_artifact"},{"line":464,"address":[6486872,6487099],"length":1,"stats":{"Line":2},"fn_name":null},{"line":468,"address":[6487348,6487259,6487188],"length":1,"stats":{"Line":3},"fn_name":null},{"line":471,"address":[6487713],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[6488048,6487929],"length":1,"stats":{"Line":2},"fn_name":null},{"line":477,"address":[6488145],"length":1,"stats":{"Line":1},"fn_name":null},{"line":478,"address":[6488464,6490496,6490539,6491173,6488548,6488175,6490742,6490668],"length":1,"stats":{"Line":5},"fn_name":"{async_block#0}"},{"line":479,"address":[6490828,6491041,6490932,6490592],"length":1,"stats":{"Line":3},"fn_name":null},{"line":480,"address":[6490949,6490689,6491105,6490600,6490885],"length":1,"stats":{"Line":2},"fn_name":null},{"line":484,"address":[4726817,4726967,4726914],"length":1,"stats":{"Line":7},"fn_name":null},{"line":485,"address":[6488836,6488953,6488587],"length":1,"stats":{"Line":3},"fn_name":null},{"line":486,"address":[6489017],"length":1,"stats":{"Line":1},"fn_name":null},{"line":487,"address":[6489343,6489486,6489169],"length":1,"stats":{"Line":2},"fn_name":null},{"line":488,"address":[6489543,6489400,6489647],"length":1,"stats":{"Line":2},"fn_name":null},{"line":489,"address":[6489770,6489557,6489704],"length":1,"stats":{"Line":2},"fn_name":null},{"line":490,"address":[6489976,6489710,6489823],"length":1,"stats":{"Line":2},"fn_name":null},{"line":492,"address":[6489250,6488967],"length":1,"stats":{"Line":0},"fn_name":null},{"line":498,"address":[4727418,4727200],"length":1,"stats":{"Line":3},"fn_name":"test_artifact_from_str_ref"},{"line":499,"address":[4727207],"length":1,"stats":{"Line":1},"fn_name":null},{"line":501,"address":[4727228],"length":1,"stats":{"Line":1},"fn_name":null},{"line":503,"address":[4727253,4727381],"length":1,"stats":{"Line":1},"fn_name":null},{"line":507,"address":[4727456,4727691],"length":1,"stats":{"Line":3},"fn_name":"test_artifact_from_string"},{"line":508,"address":[4727463],"length":1,"stats":{"Line":1},"fn_name":null},{"line":510,"address":[4727484],"length":1,"stats":{"Line":1},"fn_name":null},{"line":512,"address":[4727654,4727524],"length":1,"stats":{"Line":1},"fn_name":null},{"line":516,"address":[4727997,4727728],"length":1,"stats":{"Line":3},"fn_name":"test_artifact_from_string_ref"},{"line":517,"address":[4727735],"length":1,"stats":{"Line":1},"fn_name":null},{"line":519,"address":[4727767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":521,"address":[4727883,4727947,4727779],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":165,"coverable":195},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","network","event_loop.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::network::artifact_protocol::{ArtifactRequest, ArtifactResponse};\nuse crate::network::behaviour::{PyrsiaNetworkBehaviour, PyrsiaNetworkEvent};\nuse crate::network::client::command::Command;\nuse crate::network::client::ArtifactType;\nuse crate::network::idle_metric_protocol::{IdleMetricRequest, IdleMetricResponse, PeerMetrics};\nuse futures::channel::{mpsc, oneshot};\nuse futures::prelude::*;\nuse libp2p::core::{Multiaddr, PeerId};\nuse libp2p::identify::IdentifyEvent;\nuse libp2p::kad::{GetClosestPeersOk, GetProvidersOk, KademliaEvent, QueryId, QueryResult};\nuse libp2p::multiaddr::Protocol;\nuse libp2p::request_response::{\n    RequestId, RequestResponseEvent, RequestResponseMessage, ResponseChannel,\n};\nuse libp2p::swarm::SwarmEvent;\nuse libp2p::Swarm;\nuse log::{debug, info, trace, warn};\nuse std::collections::hash_map::Entry::Vacant;\nuse std::collections::{HashMap, HashSet};\nuse std::error::Error;\n\ntype PendingDialMap = HashMap\u003cMultiaddr, oneshot::Sender\u003canyhow::Result\u003c()\u003e\u003e\u003e;\ntype PendingListPeersMap = HashMap\u003cQueryId, oneshot::Sender\u003cHashSet\u003cPeerId\u003e\u003e\u003e;\ntype PendingStartProvidingMap = HashMap\u003cQueryId, oneshot::Sender\u003c()\u003e\u003e;\ntype PendingRequestArtifactMap = HashMap\u003cRequestId, oneshot::Sender\u003canyhow::Result\u003cVec\u003cu8\u003e\u003e\u003e\u003e;\ntype PendingRequestIdleMetricMap = HashMap\u003cRequestId, oneshot::Sender\u003canyhow::Result\u003cPeerMetrics\u003e\u003e\u003e;\n\n/// The `PyrsiaEventLoop` is responsible for taking care of incoming\n/// events from the libp2p [`Swarm`] itself, the different network\n/// behaviours that exist inside the `Swarm` and incoming commands\n/// from the [`Client`].\npub struct PyrsiaEventLoop {\n    swarm: Swarm\u003cPyrsiaNetworkBehaviour\u003e,\n    command_receiver: mpsc::Receiver\u003cCommand\u003e,\n    event_sender: mpsc::Sender\u003cPyrsiaEvent\u003e,\n    pending_dial: PendingDialMap,\n    pending_list_peers: PendingListPeersMap,\n    pending_start_providing: PendingStartProvidingMap,\n    pending_list_providers: PendingListPeersMap,\n    pending_request_artifact: PendingRequestArtifactMap,\n    pending_idle_metric_requests: PendingRequestIdleMetricMap,\n}\n\nimpl PyrsiaEventLoop {\n    pub fn new(\n        swarm: Swarm\u003cPyrsiaNetworkBehaviour\u003e,\n        command_receiver: mpsc::Receiver\u003cCommand\u003e,\n        event_sender: mpsc::Sender\u003cPyrsiaEvent\u003e,\n    ) -\u003e Self {\n        Self {\n            swarm,\n            command_receiver,\n            event_sender,\n            pending_dial: Default::default(),\n            pending_list_peers: Default::default(),\n            pending_start_providing: Default::default(),\n            pending_list_providers: Default::default(),\n            pending_request_artifact: Default::default(),\n            pending_idle_metric_requests: Default::default(),\n        }\n    }\n\n    /// Creates the actual event loop to begin listening for\n    /// incoming events on the swarm and command channels.\n    pub async fn run(mut self) {\n        loop {\n            futures::select! {\n                event = self.swarm.next() =\u003e match event.expect(\"Swarm stream to be infinite.\") {\n                    SwarmEvent::Behaviour(PyrsiaNetworkEvent::Identify(identify_event)) =\u003e self.handle_identify_event(identify_event).await,\n                    SwarmEvent::Behaviour(PyrsiaNetworkEvent::Kademlia(kademlia_event)) =\u003e self.handle_kademlia_event(kademlia_event).await,\n                    SwarmEvent::Behaviour(PyrsiaNetworkEvent::RequestResponse(request_response_event)) =\u003e self.handle_request_response_event(request_response_event).await,\n                    SwarmEvent::Behaviour(PyrsiaNetworkEvent::IdleMetricRequestResponse(request_response_event)) =\u003e self.handle_idle_metric_request_response_event(request_response_event).await,\n                    swarm_event =\u003e self.handle_swarm_event(swarm_event).await,\n                },\n                command = self.command_receiver.next() =\u003e match command {\n                    Some(c) =\u003e {\n                        self.handle_command(c).await;\n                    },\n                    // Command channel closed, thus shutting down the network event loop.\n                    None =\u003e { warn!(\"Got empty command\"); return },\n                },\n            }\n        }\n    }\n\n    // Handles events from the `Identify` network behaviour.\n    async fn handle_identify_event(\u0026mut self, event: IdentifyEvent) {\n        trace!(\"Handle IdentifyEvent: {:?}\", event);\n        match event {\n            IdentifyEvent::Pushed { .. } =\u003e {}\n            IdentifyEvent::Received { peer_id, info } =\u003e {\n                println!(\"Identify::Received: {}; {:?}\", peer_id, info);\n                if let Some(addr) = info.listen_addrs.get(0) {\n                    if let Some(sender) = self.pending_dial.remove(addr) {\n                        let _ = sender.send(Ok(()));\n                    }\n\n                    debug!(\n                        \"Identify::Received: adding address {:?} for peer {}\",\n                        addr.clone(),\n                        peer_id\n                    );\n                    self.swarm\n                        .behaviour_mut()\n                        .kademlia\n                        .add_address(\u0026peer_id, addr.clone());\n                }\n            }\n            IdentifyEvent::Sent { .. } =\u003e {}\n            IdentifyEvent::Error { .. } =\u003e {}\n        }\n    }\n\n    // Handles events from the `Kademlia` network behaviour.\n    async fn handle_kademlia_event(\u0026mut self, event: KademliaEvent) {\n        trace!(\"Handle KademliaEvent: {:?}\", event);\n        match event {\n            KademliaEvent::OutboundQueryCompleted {\n                id,\n                result: QueryResult::GetClosestPeers(Ok(GetClosestPeersOk { key: _key, peers })),\n                ..\n            } =\u003e {\n                let _ = self\n                    .pending_list_peers\n                    .remove(\u0026id)\n                    .expect(\"Completed query to be previously pending.\")\n                    .send(HashSet::from_iter(peers));\n            }\n            KademliaEvent::OutboundQueryCompleted {\n                id,\n                result: QueryResult::StartProviding(_),\n                ..\n            } =\u003e {\n                let sender: oneshot::Sender\u003c()\u003e = self\n                    .pending_start_providing\n                    .remove(\u0026id)\n                    .expect(\"Completed query to be previously pending.\");\n                let _ = sender.send(());\n            }\n            KademliaEvent::OutboundQueryCompleted {\n                id,\n                result:\n                    QueryResult::GetProviders(Ok(GetProvidersOk {\n                        key: _key,\n                        providers,\n                        ..\n                    })),\n                ..\n            } =\u003e {\n                let _ = self\n                    .pending_list_providers\n                    .remove(\u0026id)\n                    .expect(\"Completed query to be previously pending.\")\n                    .send(providers);\n            }\n            _ =\u003e {}\n        }\n    }\n\n    // Handles events from the `RequestResponse` for artifact exchange\n    // network behaviour.\n    async fn handle_request_response_event(\n        \u0026mut self,\n        event: RequestResponseEvent\u003cArtifactRequest, ArtifactResponse\u003e,\n    ) {\n        trace!(\"Handle RequestResponseEvent: {:?}\", event);\n        match event {\n            RequestResponseEvent::Message { message, .. } =\u003e match message {\n                RequestResponseMessage::Request {\n                    request, channel, ..\n                } =\u003e {\n                    self.event_sender\n                        .send(PyrsiaEvent::RequestArtifact {\n                            artifact_type: request.0,\n                            artifact_hash: request.1,\n                            channel,\n                        })\n                        .await\n                        .expect(\"Event receiver not to be dropped.\");\n                }\n                RequestResponseMessage::Response {\n                    request_id,\n                    response,\n                } =\u003e {\n                    let _ = self\n                        .pending_request_artifact\n                        .remove(\u0026request_id)\n                        .expect(\"Request to still be pending.\")\n                        .send(Ok(response.0));\n                }\n            },\n            RequestResponseEvent::InboundFailure { .. } =\u003e {}\n            RequestResponseEvent::OutboundFailure {\n                request_id, error, ..\n            } =\u003e {\n                let _ = self\n                    .pending_request_artifact\n                    .remove(\u0026request_id)\n                    .expect(\"Request to still be pending.\")\n                    .send(Err(From::from(error)));\n            }\n            RequestResponseEvent::ResponseSent { .. } =\u003e {}\n        }\n    }\n\n    // Handles events from the `RequestResponse` for peer metric exchange\n    // network behaviour.\n    async fn handle_idle_metric_request_response_event(\n        \u0026mut self,\n        event: RequestResponseEvent\u003cIdleMetricRequest, IdleMetricResponse\u003e,\n    ) {\n        trace!(\"Handle RequestResponseEvent: {:?}\", event);\n        match event {\n            RequestResponseEvent::Message { message, .. } =\u003e match message {\n                RequestResponseMessage::Request { channel, .. } =\u003e {\n                    self.event_sender\n                        .send(PyrsiaEvent::IdleMetricRequest { channel })\n                        .await\n                        .expect(\"Event receiver not to be dropped.\");\n                }\n                RequestResponseMessage::Response {\n                    request_id,\n                    response,\n                } =\u003e {\n                    let _ = self\n                        .pending_idle_metric_requests\n                        .remove(\u0026request_id)\n                        .expect(\"Request to still be pending.\")\n                        .send(Ok(response.0));\n                }\n            },\n            RequestResponseEvent::InboundFailure { .. } =\u003e {}\n            RequestResponseEvent::OutboundFailure {\n                request_id, error, ..\n            } =\u003e {\n                let _ = self\n                    .pending_idle_metric_requests\n                    .remove(\u0026request_id)\n                    .expect(\"Request to still be pending.\")\n                    .send(Err(From::from(error)));\n            }\n            RequestResponseEvent::ResponseSent { .. } =\u003e {}\n        }\n    }\n    // Handles all other events from the libp2p `Swarm`.\n    async fn handle_swarm_event(\u0026mut self, event: SwarmEvent\u003cPyrsiaNetworkEvent, impl Error\u003e) {\n        trace!(\"Handle SwarmEvent: {:?}\", event);\n        match event {\n            SwarmEvent::Behaviour(_) =\u003e {\n                debug!(\"Unmatched Behaviour swarm event found: {:?}\", event);\n            }\n            SwarmEvent::NewListenAddr { address, .. } =\u003e {\n                let local_peer_id = *self.swarm.local_peer_id();\n                info!(\n                    \"Local node is listening on {:?}\",\n                    address.with(Protocol::P2p(local_peer_id.into()))\n                );\n            }\n            SwarmEvent::ConnectionEstablished { .. } =\u003e {}\n            SwarmEvent::ConnectionClosed { .. } =\u003e {}\n            SwarmEvent::OutgoingConnectionError { .. } =\u003e {}\n            SwarmEvent::BannedPeer { .. } =\u003e {}\n            SwarmEvent::Dialing(peer_id) =\u003e {\n                debug!(\n                    \"Local Peer {} is dialing Peer {}...\",\n                    self.swarm.local_peer_id(),\n                    peer_id\n                );\n            }\n            SwarmEvent::ExpiredListenAddr { .. } =\u003e {}\n            SwarmEvent::IncomingConnection { .. } =\u003e {}\n            SwarmEvent::IncomingConnectionError { .. } =\u003e {}\n            SwarmEvent::ListenerClosed { .. } =\u003e {}\n            SwarmEvent::ListenerError { .. } =\u003e {}\n        }\n    }\n\n    // Handle incoming commands that are sent by the [`Client`].\n    async fn handle_command(\u0026mut self, command: Command) {\n        trace!(\"Handle Command: {}\", command);\n        match command {\n            Command::Listen { addr, sender } =\u003e {\n                let _ = match self.swarm.listen_on(addr) {\n                    Ok(_) =\u003e sender.send(Ok(())),\n                    Err(e) =\u003e sender.send(Err(From::from(e))),\n                };\n            }\n            Command::Dial { peer_addr, sender } =\u003e {\n                if let Vacant(_) = self.pending_dial.entry(peer_addr.clone()) {\n                    match self.swarm.dial(peer_addr.clone()) {\n                        Ok(()) =\u003e {\n                            self.pending_dial.insert(peer_addr, sender);\n                        }\n                        Err(e) =\u003e {\n                            let _ = sender.send(Err(From::from(e)));\n                        }\n                    }\n                }\n            }\n            Command::ListPeers { peer_id, sender } =\u003e {\n                let query_id = self\n                    .swarm\n                    .behaviour_mut()\n                    .kademlia\n                    .get_closest_peers(peer_id);\n                self.pending_list_peers.insert(query_id, sender);\n            }\n            Command::Provide {\n                artifact_type,\n                artifact_hash,\n                sender,\n            } =\u003e {\n                let kademlia_key = format!(\"{}|{}\", artifact_type, artifact_hash.hash);\n                let query_id = self\n                    .swarm\n                    .behaviour_mut()\n                    .kademlia\n                    .start_providing(kademlia_key.into_bytes().into())\n                    .expect(\"No store error.\");\n                self.pending_start_providing.insert(query_id, sender);\n            }\n            Command::ListProviders {\n                artifact_type,\n                artifact_hash,\n                sender,\n            } =\u003e {\n                let kademlia_key = format!(\"{}|{}\", artifact_type, artifact_hash.hash);\n                let query_id = self\n                    .swarm\n                    .behaviour_mut()\n                    .kademlia\n                    .get_providers(kademlia_key.into_bytes().into());\n                self.pending_list_providers.insert(query_id, sender);\n            }\n            Command::RequestArtifact {\n                artifact_type,\n                artifact_hash,\n                peer,\n                sender,\n            } =\u003e {\n                let request_id = self\n                    .swarm\n                    .behaviour_mut()\n                    .request_response\n                    .send_request(\u0026peer, ArtifactRequest(artifact_type, artifact_hash.hash));\n                self.pending_request_artifact.insert(request_id, sender);\n            }\n            Command::RespondArtifact { artifact, channel } =\u003e {\n                self.swarm\n                    .behaviour_mut()\n                    .request_response\n                    .send_response(channel, ArtifactResponse(artifact))\n                    .expect(\"Connection to peer to be still open.\");\n            }\n            Command::RequestIdleMetric { peer, sender } =\u003e {\n                let request_id = self\n                    .swarm\n                    .behaviour_mut()\n                    .idle_metric_request_response\n                    .send_request(\u0026peer, IdleMetricRequest());\n                self.pending_idle_metric_requests.insert(request_id, sender);\n            }\n            Command::RespondIdleMetric { metric, channel } =\u003e {\n                self.swarm\n                    .behaviour_mut()\n                    .idle_metric_request_response\n                    .send_response(channel, IdleMetricResponse(metric))\n                    .expect(\"Connection to peer to be still open.\");\n            }\n        }\n    }\n}\n\n#[derive(Debug)]\npub enum PyrsiaEvent {\n    RequestArtifact {\n        artifact_type: ArtifactType,\n        artifact_hash: String,\n        channel: ResponseChannel\u003cArtifactResponse\u003e,\n    },\n    IdleMetricRequest {\n        channel: ResponseChannel\u003cIdleMetricResponse\u003e,\n    },\n}\n","traces":[{"line":59,"address":[6622829,6622128],"length":1,"stats":{"Line":1},"fn_name":"new"},{"line":68,"address":[6622230],"length":1,"stats":{"Line":1},"fn_name":null},{"line":69,"address":[6622245],"length":1,"stats":{"Line":1},"fn_name":null},{"line":70,"address":[6622300],"length":1,"stats":{"Line":1},"fn_name":null},{"line":71,"address":[6622352],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[6622404],"length":1,"stats":{"Line":1},"fn_name":null},{"line":73,"address":[6622456],"length":1,"stats":{"Line":1},"fn_name":null},{"line":79,"address":[6275935,6275870,6274200,6273424,6273573,6273469,6274019],"length":1,"stats":{"Line":5},"fn_name":"{async_fn#0}"},{"line":80,"address":[6275579,6273568],"length":1,"stats":{"Line":2},"fn_name":null},{"line":81,"address":[6275577,6277143,6274266,6273603,6276873,6276023,6273976,6277922,6275857],"length":1,"stats":{"Line":5},"fn_name":null},{"line":82,"address":[6274674,6274087,6276072,6275987],"length":1,"stats":{"Line":4},"fn_name":null},{"line":83,"address":[6277679,6273925,6276320,6273624],"length":1,"stats":{"Line":3},"fn_name":null},{"line":84,"address":[6276462,6277428,6273645,6273874],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[6277177,6276592,6273666,6273823],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[6276146,6273687,6276858,6273772,6276921],"length":1,"stats":{"Line":4},"fn_name":null},{"line":88,"address":[6274829,6274263,6274153],"length":1,"stats":{"Line":3},"fn_name":null},{"line":89,"address":[6275015],"length":1,"stats":{"Line":1},"fn_name":null},{"line":90,"address":[6273705,6275351,6275135],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[6275688,6274963,6275591],"length":1,"stats":{"Line":3},"fn_name":null},{"line":100,"address":[6278439,6278526,6279074,6280049,6278112,6280729,6278151],"length":1,"stats":{"Line":5},"fn_name":"{async_fn#0}"},{"line":101,"address":[6278571,6278520,6278647,6278398],"length":1,"stats":{"Line":3},"fn_name":null},{"line":102,"address":[6278930,6278864],"length":1,"stats":{"Line":1},"fn_name":null},{"line":103,"address":[6279519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[6279726,6279607,6279837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[6279670,6279876,6279742],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[6278969],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[6278985],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[6279061],"length":1,"stats":{"Line":0},"fn_name":null},{"line":125,"address":[6279118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":135,"address":[6279403,6279222],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[6279418,6279331],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[6278925],"length":1,"stats":{"Line":1},"fn_name":null},{"line":147,"address":[6623040],"length":1,"stats":{"Line":0},"fn_name":"handle_request_response_event"},{"line":151,"address":[6281794,6281639,6281718,6281445],"length":1,"stats":{"Line":0},"fn_name":null},{"line":152,"address":[6282026],"length":1,"stats":{"Line":0},"fn_name":null},{"line":153,"address":[6282560,6282069],"length":1,"stats":{"Line":0},"fn_name":null},{"line":154,"address":[6282578],"length":1,"stats":{"Line":0},"fn_name":null},{"line":157,"address":[6282730,6283177,6282623,6283302,6283381],"length":1,"stats":{"Line":0},"fn_name":null},{"line":158,"address":[6282662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[6282630],"length":1,"stats":{"Line":0},"fn_name":null},{"line":166,"address":[6282771],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[6282809,6283018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[6283033,6282918],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[6282216],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[6282157],"length":1,"stats":{"Line":0},"fn_name":null},{"line":181,"address":[6282441,6282350,6282189,6282275],"length":1,"stats":{"Line":0},"fn_name":null},{"line":185,"address":[6282306,6282480,6282366,6282421],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[6282218],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[6623152],"length":1,"stats":{"Line":0},"fn_name":"handle_idle_metric_request_response_event"},{"line":197,"address":[6284090,6283723,6283917,6283999],"length":1,"stats":{"Line":0},"fn_name":null},{"line":198,"address":[6284325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":[6284886,6284365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[6284904],"length":1,"stats":{"Line":0},"fn_name":null},{"line":201,"address":[6285319,6284919,6285523,6284962,6285444],"length":1,"stats":{"Line":0},"fn_name":null},{"line":202,"address":[6285339,6284926,6285266,6285462,6283791],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[6285003],"length":1,"stats":{"Line":0},"fn_name":null},{"line":210,"address":[6285153,6285018],"length":1,"stats":{"Line":0},"fn_name":null},{"line":214,"address":[6285113,6285236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":217,"address":[6284494],"length":1,"stats":{"Line":0},"fn_name":null},{"line":218,"address":[6284438],"length":1,"stats":{"Line":0},"fn_name":null},{"line":221,"address":[6284553,6284808,6284467,6284715,6284628],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[6284644,6284584,6284840,6284699,6284764],"length":1,"stats":{"Line":0},"fn_name":null},{"line":227,"address":[6284496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":231,"address":[6285760,6285648,6285686,6290099,6285799,6286137,6290298,6286050,6287584],"length":1,"stats":{"Line":6},"fn_name":"handle_swarm_event\u003clibp2p_core::either::EitherError\u003clibp2p_core::either::EitherError\u003cstd::io::error::Error, libp2p_swarm::handler::ConnectionHandlerUpgrErr\u003cstd::io::error::Error\u003e\u003e, libp2p_swarm::handler::ConnectionHandlerUpgrErr\u003cstd::io::error::Error\u003e\u003e\u003e"},{"line":232,"address":[6286009,6286320,6286229,6286131],"length":1,"stats":{"Line":3},"fn_name":null},{"line":233,"address":[6286555],"length":1,"stats":{"Line":1},"fn_name":null},{"line":234,"address":[6290285],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[6289799,6286596,6289881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":237,"address":[6286913],"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":[6286945,6287662],"length":1,"stats":{"Line":2},"fn_name":null},{"line":239,"address":[6287810,6288355,6287721,6288299,6287904],"length":1,"stats":{"Line":3},"fn_name":null},{"line":241,"address":[6288329,6287967,6288316],"length":1,"stats":{"Line":0},"fn_name":null},{"line":244,"address":[6286640],"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":[6289403,6286760,6289450,6289753],"length":1,"stats":{"Line":4},"fn_name":null},{"line":248,"address":[6289635,6289463,6289574,6289733],"length":1,"stats":{"Line":3},"fn_name":null},{"line":249,"address":[6289598,6289675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":253,"address":[6286789],"length":1,"stats":{"Line":0},"fn_name":null},{"line":254,"address":[6286804],"length":1,"stats":{"Line":0},"fn_name":null},{"line":255,"address":[6288635,6288742,6289293,6286880],"length":1,"stats":{"Line":0},"fn_name":null},{"line":256,"address":[6288768,6289044,6288864,6288715,6289248],"length":1,"stats":{"Line":0},"fn_name":null},{"line":257,"address":[6289086,6289228,6288888],"length":1,"stats":{"Line":0},"fn_name":null},{"line":261,"address":[6286900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":262,"address":[6286978],"length":1,"stats":{"Line":0},"fn_name":null},{"line":263,"address":[6287203,6287311,6287058],"length":1,"stats":{"Line":0},"fn_name":null},{"line":265,"address":[6287280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":269,"address":[6286963],"length":1,"stats":{"Line":0},"fn_name":null},{"line":270,"address":[6286794],"length":1,"stats":{"Line":1},"fn_name":null},{"line":271,"address":[6286799],"length":1,"stats":{"Line":0},"fn_name":null},{"line":272,"address":[6286968],"length":1,"stats":{"Line":0},"fn_name":null},{"line":273,"address":[6286973],"length":1,"stats":{"Line":0},"fn_name":null},{"line":278,"address":[6290455,6293067,6291056,6291143,6290416,6297616],"length":1,"stats":{"Line":5},"fn_name":"{async_fn#0}"},{"line":279,"address":[6291015,6291137,6291306,6291215],"length":1,"stats":{"Line":3},"fn_name":null},{"line":280,"address":[6291541],"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":[6291591],"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":[6297164,6291655,6297222],"length":1,"stats":{"Line":2},"fn_name":null},{"line":283,"address":[6297224,6297535],"length":1,"stats":{"Line":2},"fn_name":null},{"line":284,"address":[6297490,6297280],"length":1,"stats":{"Line":0},"fn_name":null},{"line":287,"address":[6291673],"length":1,"stats":{"Line":1},"fn_name":null},{"line":292,"address":[6295775,6291817,6296954,6295849],"length":1,"stats":{"Line":3},"fn_name":null},{"line":293,"address":[6295837,6295918],"length":1,"stats":{"Line":2},"fn_name":null},{"line":296,"address":[6295888],"length":1,"stats":{"Line":1},"fn_name":null},{"line":298,"address":[6296305,6296267],"length":1,"stats":{"Line":2},"fn_name":null},{"line":300,"address":[6296284,6295938,6296274],"length":1,"stats":{"Line":1},"fn_name":null},{"line":302,"address":[6296987],"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":[6296361,6296964],"length":1,"stats":{"Line":2},"fn_name":null},{"line":305,"address":[6296487],"length":1,"stats":{"Line":0},"fn_name":null},{"line":306,"address":[6296910,6296599],"length":1,"stats":{"Line":0},"fn_name":null},{"line":311,"address":[6291938],"length":1,"stats":{"Line":0},"fn_name":null},{"line":312,"address":[6295594,6295663,6292050],"length":1,"stats":{"Line":0},"fn_name":null},{"line":316,"address":[6295506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":317,"address":[6295671],"length":1,"stats":{"Line":0},"fn_name":null},{"line":319,"address":[6292108],"length":1,"stats":{"Line":0},"fn_name":null},{"line":324,"address":[6294869,6294753,6292148],"length":1,"stats":{"Line":0},"fn_name":null},{"line":325,"address":[6295015,6295189],"length":1,"stats":{"Line":0},"fn_name":null},{"line":329,"address":[6295166,6295046],"length":1,"stats":{"Line":0},"fn_name":null},{"line":331,"address":[6295334],"length":1,"stats":{"Line":0},"fn_name":null},{"line":333,"address":[6292174],"length":1,"stats":{"Line":0},"fn_name":null},{"line":338,"address":[6294199,6292254,6294083],"length":1,"stats":{"Line":0},"fn_name":null},{"line":339,"address":[6294345,6294519],"length":1,"stats":{"Line":0},"fn_name":null},{"line":343,"address":[6294376,6294496],"length":1,"stats":{"Line":0},"fn_name":null},{"line":344,"address":[6294558],"length":1,"stats":{"Line":0},"fn_name":null},{"line":346,"address":[6292288],"length":1,"stats":{"Line":0},"fn_name":null},{"line":352,"address":[6292448,6293722,6293817,6293889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":356,"address":[6293729],"length":1,"stats":{"Line":0},"fn_name":null},{"line":357,"address":[6293897],"length":1,"stats":{"Line":0},"fn_name":null},{"line":359,"address":[6292474],"length":1,"stats":{"Line":0},"fn_name":null},{"line":360,"address":[6293554,6293443,6293595,6292554],"length":1,"stats":{"Line":0},"fn_name":null},{"line":363,"address":[6293450],"length":1,"stats":{"Line":0},"fn_name":null},{"line":366,"address":[6292580],"length":1,"stats":{"Line":0},"fn_name":null},{"line":367,"address":[6292692,6293317,6293230],"length":1,"stats":{"Line":0},"fn_name":null},{"line":372,"address":[6293325],"length":1,"stats":{"Line":0},"fn_name":null},{"line":374,"address":[6292718],"length":1,"stats":{"Line":0},"fn_name":null},{"line":375,"address":[6292766,6292844,6292932],"length":1,"stats":{"Line":0},"fn_name":null},{"line":378,"address":[6292796],"length":1,"stats":{"Line":0},"fn_name":null},{"line":418,"address":[4878992,4882424],"length":1,"stats":{"Line":1},"fn_name":"create_test_swarm"},{"line":419,"address":[4879021],"length":1,"stats":{"Line":1},"fn_name":null},{"line":420,"address":[4879131],"length":1,"stats":{"Line":1},"fn_name":null},{"line":421,"address":[4879158],"length":1,"stats":{"Line":1},"fn_name":null},{"line":423,"address":[4879283,4879226],"length":1,"stats":{"Line":2},"fn_name":null},{"line":427,"address":[4879372],"length":1,"stats":{"Line":1},"fn_name":null},{"line":428,"address":[4879464],"length":1,"stats":{"Line":1},"fn_name":null},{"line":430,"address":[4880091,4879775,4879589,4880007,4879867,4880136,4879607],"length":1,"stats":{"Line":7},"fn_name":null},{"line":431,"address":[4879630,4879599],"length":1,"stats":{"Line":2},"fn_name":null},{"line":432,"address":[4879814,4879638,4879849],"length":1,"stats":{"Line":2},"fn_name":null},{"line":433,"address":[4879830,4879906,4879980],"length":1,"stats":{"Line":1},"fn_name":null},{"line":434,"address":[4879964,4880038,4880108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":438,"address":[4880160],"length":1,"stats":{"Line":1},"fn_name":null},{"line":439,"address":[4880506],"length":1,"stats":{"Line":1},"fn_name":null},{"line":447,"address":[4880619],"length":1,"stats":{"Line":1},"fn_name":null},{"line":457,"address":[4881064,4881236,4880756],"length":1,"stats":{"Line":2},"fn_name":null},{"line":458,"address":[4792672],"length":1,"stats":{"Line":1},"fn_name":"{closure#0}"},{"line":459,"address":[4792715],"length":1,"stats":{"Line":1},"fn_name":null},{"line":463,"address":[4881282],"length":1,"stats":{"Line":1},"fn_name":null},{"line":464,"address":[4881414,4881366],"length":1,"stats":{"Line":2},"fn_name":null},{"line":470,"address":[4881742],"length":1,"stats":{"Line":1},"fn_name":null},{"line":472,"address":[4881910],"length":1,"stats":{"Line":1},"fn_name":null},{"line":475,"address":[4885010,4884861],"length":1,"stats":{"Line":1},"fn_name":null},{"line":476,"address":[4792845,4792773,4792942,4793383,4793172,4792800,4792768],"length":1,"stats":{"Line":6},"fn_name":"{closure#0}"},{"line":477,"address":[4793240,4792910],"length":1,"stats":{"Line":2},"fn_name":null},{"line":478,"address":[4793435,4793368],"length":1,"stats":{"Line":2},"fn_name":null},{"line":480,"address":[4793715,4793611,4793817],"length":1,"stats":{"Line":3},"fn_name":null},{"line":481,"address":[4793860],"length":1,"stats":{"Line":1},"fn_name":null},{"line":483,"address":[4794166,4794450,4794533,4794290],"length":1,"stats":{"Line":4},"fn_name":null},{"line":484,"address":[4794033,4794471,4794252,4792972,4794189,4794313,4793129],"length":1,"stats":{"Line":6},"fn_name":null},{"line":487,"address":[4794828,4794967,4795050,4794704],"length":1,"stats":{"Line":4},"fn_name":null},{"line":488,"address":[4792993,4794790,4794727,4794586,4794988,4793078,4794848],"length":1,"stats":{"Line":6},"fn_name":null},{"line":492,"address":[4795505,4795098,4795242,4795366],"length":1,"stats":{"Line":4},"fn_name":null},{"line":494,"address":[4795110],"length":1,"stats":{"Line":1},"fn_name":null},{"line":495,"address":[4795119],"length":1,"stats":{"Line":1},"fn_name":null},{"line":497,"address":[4795280,4795594],"length":1,"stats":{"Line":1},"fn_name":null},{"line":498,"address":[4795696,4795620,4795675],"length":1,"stats":{"Line":6},"fn_name":null}],"covered":83,"coverable":171},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","network","idle_metric_protocol.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse async_trait::async_trait;\nuse futures::prelude::*;\nuse libp2p::core::upgrade::{read_varint, write_length_prefixed, ProtocolName};\nuse libp2p::request_response::RequestResponseCodec;\nuse log::debug;\nuse serde::{Deserialize, Serialize};\nuse std::io;\n\n/// The `IdleMetricExchangeCodec` defines the request and response types\n/// for the [`RequestResponse`](crate::RequestResponse) protocol for\n/// exchanging peer metrics. The peer metric is passed through the framework\n/// in the PeerMetrics structure but over the network as the bytes needed\n/// for passing a floating point as bits of the idle metric field of the\n/// PeerMetrics structure.\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct PeerMetrics {\n    pub idle_metric: [u8; 8],\n}\n\nimpl PartialEq for PeerMetrics {\n    fn eq(\u0026self, other: \u0026Self) -\u003e bool {\n        self.idle_metric == other.idle_metric\n    }\n}\n\nimpl Eq for PeerMetrics {}\n\nimpl AsRef\u003c[u8]\u003e for PeerMetrics {\n    fn as_ref(\u0026self) -\u003e \u0026[u8] {\n        \u0026self.idle_metric\n    }\n}\n\n#[derive(Debug, Clone)]\npub struct IdleMetricExchangeProtocol();\n\n#[derive(Clone)]\npub struct IdleMetricExchangeCodec();\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct IdleMetricRequest();\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct IdleMetricResponse(pub PeerMetrics);\n\nimpl ProtocolName for IdleMetricExchangeProtocol {\n    fn protocol_name(\u0026self) -\u003e \u0026[u8] {\n        \"/metric-exchange/1\".as_bytes()\n    }\n}\n#[async_trait]\nimpl RequestResponseCodec for IdleMetricExchangeCodec {\n    type Protocol = IdleMetricExchangeProtocol;\n    type Request = IdleMetricRequest;\n    type Response = IdleMetricResponse;\n\n    //request for idle metric from a peer.\n    async fn read_request\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026IdleMetricExchangeProtocol,\n        _io: \u0026mut T,\n    ) -\u003e io::Result\u003cSelf::Request\u003e\n    where\n        T: AsyncRead + Unpin + Send,\n    {\n        debug!(\"p2p::idle_metric_protocol::read_request received from peer.\",);\n        //unlike the artifact, there is no has parameter there is only one metric possible\n        Ok(IdleMetricRequest()) //TODO: can I just return OK from here with no type\n    }\n\n    //reads the peer metric from the peer\n    async fn read_response\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026IdleMetricExchangeProtocol,\n        io: \u0026mut T,\n    ) -\u003e io::Result\u003cSelf::Response\u003e\n    where\n        T: AsyncRead + Unpin + Send,\n    {\n        let mut buff: [u8; 8] = [0; 8];\n        let mut size = read_varint(io).await?;\n        if size != 8 {\n            return Err(io::ErrorKind::InvalidData.into());\n        }\n\n        size = io.read(\u0026mut buff).await?;\n        if size != 8 {\n            return Err(io::ErrorKind::InvalidData.into());\n        }\n\n        let metric = PeerMetrics { idle_metric: buff };\n        debug!(\n            \"p2p::idle_metric_protocol::read_response Reading response to idle metric request with value ={:?}\",\n            metric.idle_metric\n        );\n        Ok(IdleMetricResponse(metric))\n    }\n\n    //this method request the idle metric from the peer\n    async fn write_request\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026IdleMetricExchangeProtocol,\n        io: \u0026mut T,\n        IdleMetricRequest(): IdleMetricRequest,\n    ) -\u003e io::Result\u003c()\u003e\n    where\n        T: AsyncWrite + Unpin + Send,\n    {\n        debug!(\n            \"p2p::idle_metric_protocol::write_request writing a request to peer for and idle metric\",\n        );\n        io.close().await?;\n        Ok(())\n    }\n\n    //this object writes the quality metric to the peer.\n    async fn write_response\u003cT\u003e(\n        \u0026mut self,\n        _: \u0026IdleMetricExchangeProtocol,\n        io: \u0026mut T,\n        IdleMetricResponse(data): IdleMetricResponse,\n    ) -\u003e io::Result\u003c()\u003e\n    where\n        T: AsyncWrite + Unpin + Send,\n    {\n        debug!(\n            \"p2p::idle_metric_protocol::write_response sending PeerMetric metric value {:?}\",\n            data\n        );\n        write_length_prefixed(io, data.idle_metric).await?;\n        io.close().await?;\n\n        Ok(())\n    }\n}\n","traces":[{"line":37,"address":[5747104],"length":1,"stats":{"Line":0},"fn_name":"eq"},{"line":38,"address":[5747118],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[5747152],"length":1,"stats":{"Line":0},"fn_name":"as_ref"},{"line":61,"address":[5747168],"length":1,"stats":{"Line":1},"fn_name":"protocol_name"},{"line":72,"address":[4452848],"length":1,"stats":{"Line":0},"fn_name":"read_request\u003cmultistream_select::negotiated::Negotiated\u003clibp2p_core::muxing::SubstreamRef\u003calloc::sync::Arc\u003clibp2p_core::muxing::StreamMuxerBox\u003e\u003e\u003e\u003e"},{"line":80,"address":[4453419,4453258,4453340],"length":1,"stats":{"Line":0},"fn_name":null},{"line":82,"address":[4453564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[4453648],"length":1,"stats":{"Line":0},"fn_name":"read_response\u003cmultistream_select::negotiated::Negotiated\u003clibp2p_core::muxing::SubstreamRef\u003calloc::sync::Arc\u003clibp2p_core::muxing::StreamMuxerBox\u003e\u003e\u003e\u003e"},{"line":94,"address":[4454401],"length":1,"stats":{"Line":0},"fn_name":null},{"line":95,"address":[4455013,4454106,4454409,4454189,4454493,4454901],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[4454881],"length":1,"stats":{"Line":0},"fn_name":null},{"line":97,"address":[4455128],"length":1,"stats":{"Line":0},"fn_name":null},{"line":100,"address":[4454124,4455594,4455100,4455202,4455697],"length":1,"stats":{"Line":0},"fn_name":null},{"line":101,"address":[4455574],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[4455798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":105,"address":[4455732],"length":1,"stats":{"Line":0},"fn_name":null},{"line":106,"address":[4455942,4455760,4455860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[4456159],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[4456256],"length":1,"stats":{"Line":0},"fn_name":"write_request\u003cmultistream_select::negotiated::Negotiated\u003clibp2p_core::muxing::SubstreamRef\u003calloc::sync::Arc\u003clibp2p_core::muxing::StreamMuxerBox\u003e\u003e\u003e\u003e"},{"line":123,"address":[4456771,4456941,4456859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[4456579,4457446,4457109,4457394],"length":1,"stats":{"Line":0},"fn_name":null},{"line":127,"address":[4457364],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[4457536],"length":1,"stats":{"Line":0},"fn_name":"write_response\u003cmultistream_select::negotiated::Negotiated\u003clibp2p_core::muxing::SubstreamRef\u003calloc::sync::Arc\u003clibp2p_core::muxing::StreamMuxerBox\u003e\u003e\u003e\u003e"},{"line":140,"address":[4458421,4458230,4458327],"length":1,"stats":{"Line":0},"fn_name":null},{"line":142,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":144,"address":[4459060,4457963,4459114,4458046,4458650],"length":1,"stats":{"Line":0},"fn_name":null},{"line":145,"address":[4459490,4459041,4459210,4457981,4459545],"length":1,"stats":{"Line":0},"fn_name":null},{"line":147,"address":[4459457],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":1,"coverable":29},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","network","p2p.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::network::artifact_protocol::{ArtifactExchangeCodec, ArtifactExchangeProtocol};\nuse crate::network::behaviour::PyrsiaNetworkBehaviour;\nuse crate::network::client::Client;\nuse crate::network::event_loop::{PyrsiaEvent, PyrsiaEventLoop};\nuse crate::network::idle_metric_protocol::{IdleMetricExchangeCodec, IdleMetricExchangeProtocol};\nuse crate::util::keypair_util;\n\nuse futures::channel::mpsc;\nuse futures::prelude::*;\nuse libp2p::core;\nuse libp2p::dns;\nuse libp2p::identify;\nuse libp2p::identity;\nuse libp2p::kad;\nuse libp2p::kad::record::store::{MemoryStore, MemoryStoreConfig};\nuse libp2p::mplex;\nuse libp2p::noise;\nuse libp2p::request_response::{ProtocolSupport, RequestResponse};\nuse libp2p::swarm::{Swarm, SwarmBuilder};\nuse libp2p::tcp;\nuse libp2p::yamux;\nuse libp2p::Transport;\nuse std::error::Error;\nuse std::iter;\n\n/// Sets up the libp2p [`Swarm`] with the necessary components, doing the following things:\n///\n/// * load a keypair that is used for the libp2p identity\n/// * create a libp2p swarm\n/// * create a mpsc channel for sending and receiving client commands\n/// * create a mpsc channel for sending and receiving custom events\n/// * create a [`Client`] for sending client commands\n/// * create an [`PyrsiaEventLoop`] to process swarm events and client commands\n///\n/// The Swarm is created with a [`NetworkBehaviour`] that is implemented by the\n/// [`PyrsiaNetworkBehaviour`]. The PyrsiaNetworkBehaviour contains the following\n/// components:\n///\n/// * Identify: a protocol for exchanging identity information between peers\n/// * Kademlia: a DHT to share information over the libp2p network\n/// * RequestResponse: a generic request/response protocol implementation for\n/// the [`FileExchangeProtocol`]\n///\n/// The maximum number of provided keys for the memory store that is used by\n/// Kademlia can be provided with the `max_provided_keys` parameter. This number\n/// should be equal to or higher than the total number of artifacts and manifests\n/// that the pyrsia node will be providing.\n///\n/// The Client uses the command channel to send commands that interact with the libp2p\n/// network. This is the main entry point for an application to perform actions on the\n/// libp2p network, i.e. dialing other peers, listing available providers, ...\n///\n/// The PyrsiaEventLoop uses the swarm and command channel for receiving swarm events\n/// and client commands respectively. It implements the actual logic of the commands\n/// by interacting with the libp2p swarm. The run method of the PyrsiaEventLoop must\n/// be called in order to start listening for swarm events and client commands.\n/// Ideally, this is done in a separate thread.\n///\n/// To get an idea of how these components are used, we explain this by following what\n/// happens when a client wants to announce itself as a provider of a specific hash.\n///\n/// 1. An application calls: `client.provide(\u0026some_hash)`.\n/// 2. The Client creates a oneshot channel.\n/// 3. The Client creates a [`Command::Provide`] that contains the hash and the sender\n///    of the oneshot channel.\n/// 4. The Client sends the command to the sender of the command channel.\n/// 5. The Client now awaits the receiver of the oneshot channel for the incoming\n///    response by the oneshot sender.\n/// 6. The PyrsiaEventLoop receives the command via the receiver of the command channel.\n/// 7. The PyrsiaEventLoop calls `handle_command` to start processing the command.\n/// 8. The implementation of Command::Provide will announce itself as a provider of\n///    `some_hash` on the Kademlia DHT and receives a QueryId.\n/// 9. The QueryId is stored in a map with the QueryId as the key and the sender of the\n///    oneshot channel as the value (which was passed down with the command).\n/// 10. The Kademlia DHT is doing its thing to make the peer known as a provider of the\n///     hash. When the operation has finished, Kademlia sends a Swarm event to notify\n///     the completion.\n/// 11. The PyrsiaEventLoop receives the event via the swarm listener.\n/// 12. The PyrsiaEventLoop calls `handle_kademlia_event` to start processing the event.\n/// 13. The Kademlia Event contains the QueryId and the Key that was provided.\n/// 14. The PyrsiaEventLoop looks up the oneshot sender in the map via the QueryId.\n/// 15. The PyrsiaEventLoop sends the result Ok() on the oneshot sender.\n/// 16. The Client receiver receives the incoming response and can now safely return\n///     to the application.\n///\n/// This function returns the following components:\n///  * the Client\n///  * the receiver part of the event channel\n///  * the PyrsiaEventLoop\npub fn setup_libp2p_swarm(\n    max_provided_keys: usize,\n) -\u003e Result\u003c(Client, impl Stream\u003cItem = PyrsiaEvent\u003e, PyrsiaEventLoop), Box\u003cdyn Error\u003e\u003e {\n    let local_keypair = keypair_util::load_or_generate_ed25519();\n\n    let (swarm, local_peer_id) = create_swarm(local_keypair, max_provided_keys)?;\n\n    let (command_sender, command_receiver) = mpsc::channel(32);\n    let (event_sender, event_receiver) = mpsc::channel(32);\n\n    Ok((\n        Client {\n            sender: command_sender,\n            local_peer_id,\n        },\n        event_receiver,\n        PyrsiaEventLoop::new(swarm, command_receiver, event_sender),\n    ))\n}\n\n// create the libp2p transport for the swarm\nfn create_transport(\n    keypair: identity::Keypair,\n) -\u003e std::io::Result\u003ccore::transport::Boxed\u003c(core::PeerId, core::muxing::StreamMuxerBox)\u003e\u003e {\n    let noise_keys = noise::Keypair::\u003cnoise::X25519Spec\u003e::new()\n        .into_authentic(\u0026keypair)\n        .expect(\"Signing libp2p-noise static DH keypair failed.\");\n\n    let tcp = tcp::TokioTcpConfig::new().nodelay(true);\n    let dns = dns::TokioDnsConfig::system(tcp)?;\n\n    Ok(dns\n        .upgrade(core::upgrade::Version::V1)\n        .authenticate(noise::NoiseConfig::xx(noise_keys).into_authenticated())\n        .multiplex(core::upgrade::SelectUpgrade::new(\n            yamux::YamuxConfig::default(),\n            mplex::MplexConfig::default(),\n        ))\n        .timeout(std::time::Duration::from_secs(20))\n        .boxed())\n}\n\n// create the libp2p swarm\nfn create_swarm(\n    keypair: identity::Keypair,\n    max_provided_keys: usize,\n) -\u003e Result\u003c(Swarm\u003cPyrsiaNetworkBehaviour\u003e, core::PeerId), Box\u003cdyn Error\u003e\u003e {\n    let peer_id = keypair.public().to_peer_id();\n\n    let identify_config =\n        identify::IdentifyConfig::new(String::from(\"ipfs/1.0.0\"), keypair.public());\n\n    let memory_store_config = MemoryStoreConfig {\n        max_provided_keys,\n        ..Default::default()\n    };\n\n    Ok((\n        SwarmBuilder::new(\n            create_transport(keypair)?,\n            PyrsiaNetworkBehaviour {\n                identify: identify::Identify::new(identify_config),\n                kademlia: kad::Kademlia::new(\n                    peer_id,\n                    MemoryStore::with_config(peer_id, memory_store_config),\n                ),\n                request_response: RequestResponse::new(\n                    ArtifactExchangeCodec(),\n                    iter::once((ArtifactExchangeProtocol(), ProtocolSupport::Full)),\n                    Default::default(),\n                ),\n                idle_metric_request_response: RequestResponse::new(\n                    IdleMetricExchangeCodec(),\n                    iter::once((IdleMetricExchangeProtocol(), ProtocolSupport::Full)),\n                    Default::default(),\n                ),\n            },\n            peer_id,\n        )\n        .executor(Box::new(|fut| {\n            tokio::spawn(fut);\n        }))\n        .build(),\n        peer_id,\n    ))\n}\n","traces":[{"line":105,"address":[5376528,5377901],"length":1,"stats":{"Line":0},"fn_name":"setup_libp2p_swarm"},{"line":108,"address":[5376564],"length":1,"stats":{"Line":0},"fn_name":null},{"line":110,"address":[5376919,5376614],"length":1,"stats":{"Line":0},"fn_name":null},{"line":112,"address":[5376978,5376907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[5377055,5377103],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[5377589],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[5377287],"length":1,"stats":{"Line":0},"fn_name":null},{"line":117,"address":[5377167],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[5377207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[5377399],"length":1,"stats":{"Line":0},"fn_name":null},{"line":121,"address":[5377423],"length":1,"stats":{"Line":0},"fn_name":null},{"line":126,"address":[5377936,5379301],"length":1,"stats":{"Line":0},"fn_name":"create_transport"},{"line":129,"address":[5378093,5377964],"length":1,"stats":{"Line":0},"fn_name":null},{"line":133,"address":[5378144],"length":1,"stats":{"Line":0},"fn_name":null},{"line":134,"address":[5378236,5378564,5378506],"length":1,"stats":{"Line":0},"fn_name":null},{"line":136,"address":[5378478,5379224,5378797,5378984,5379171,5378442,5379087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[5378470,5378623],"length":1,"stats":{"Line":0},"fn_name":null},{"line":138,"address":[5378736,5378836,5378631,5378871],"length":1,"stats":{"Line":0},"fn_name":null},{"line":139,"address":[5378949],"length":1,"stats":{"Line":0},"fn_name":null},{"line":140,"address":[5378852],"length":1,"stats":{"Line":0},"fn_name":null},{"line":141,"address":[5378889],"length":1,"stats":{"Line":0},"fn_name":null},{"line":143,"address":[5379118,5379044,5379187],"length":1,"stats":{"Line":0},"fn_name":null},{"line":148,"address":[5379328,5381010],"length":1,"stats":{"Line":0},"fn_name":"create_swarm"},{"line":152,"address":[5379369,5379485],"length":1,"stats":{"Line":0},"fn_name":null},{"line":159,"address":[5380907],"length":1,"stats":{"Line":0},"fn_name":null},{"line":160,"address":[5380740,5380575,5380859],"length":1,"stats":{"Line":0},"fn_name":null},{"line":161,"address":[5379627,5380009],"length":1,"stats":{"Line":0},"fn_name":null},{"line":162,"address":[5380430],"length":1,"stats":{"Line":0},"fn_name":null},{"line":163,"address":[5380121],"length":1,"stats":{"Line":0},"fn_name":null},{"line":164,"address":[5379783],"length":1,"stats":{"Line":0},"fn_name":null},{"line":165,"address":[5379860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":167,"address":[5380253],"length":1,"stats":{"Line":0},"fn_name":null},{"line":169,"address":[5380166],"length":1,"stats":{"Line":0},"fn_name":null},{"line":170,"address":[5380193],"length":1,"stats":{"Line":0},"fn_name":null},{"line":172,"address":[5380366],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[5380279],"length":1,"stats":{"Line":0},"fn_name":null},{"line":175,"address":[5380306],"length":1,"stats":{"Line":0},"fn_name":null},{"line":178,"address":[5380498],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[7328896],"length":1,"stats":{"Line":0},"fn_name":"{closure#0}"},{"line":181,"address":[7328939],"length":1,"stats":{"Line":0},"fn_name":null},{"line":184,"address":[5380884],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":41},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","network.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod artifact_protocol;\npub mod behaviour;\npub mod client;\npub mod event_loop;\npub mod idle_metric_protocol;\npub mod p2p;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","node_api","handlers","swarm.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse super::{get_config, RegistryError, RegistryErrorCode};\nuse crate::artifact_service::handlers::*;\nuse crate::artifact_service::storage::ArtifactStorage;\nuse crate::network::client::Client;\nuse crate::node_api::model::cli::{ArtifactsSummary, Status};\n\nuse log::debug;\nuse std::collections::HashMap;\nuse warp::{http::StatusCode, Rejection, Reply};\n\npub async fn handle_get_peers(mut p2p_client: Client) -\u003e Result\u003cimpl Reply, Rejection\u003e {\n    let peers = p2p_client.list_peers().await.map_err(RegistryError::from)?;\n    debug!(\"Got received_peers: {:?}\", peers);\n\n    let str_peers: Vec\u003cString\u003e = peers.into_iter().map(|p| p.to_string()).collect();\n    let str_peers_as_json = serde_json::to_string(\u0026str_peers).unwrap();\n\n    Ok(warp::http::response::Builder::new()\n        .header(\"Content-Type\", \"application/octet-stream\")\n        .status(StatusCode::OK)\n        .body(str_peers_as_json)\n        .unwrap())\n}\n\npub async fn handle_get_status(\n    mut p2p_client: Client,\n    artifact_storage: ArtifactStorage,\n) -\u003e Result\u003cimpl Reply, Rejection\u003e {\n    let peers = p2p_client.list_peers().await.map_err(RegistryError::from)?;\n\n    let art_count_result = get_arts_summary(\u0026artifact_storage);\n    if art_count_result.is_err() {\n        return Err(warp::reject::custom(RegistryError {\n            code: RegistryErrorCode::Unknown(art_count_result.err().unwrap().to_string()),\n        }));\n    }\n\n    let disk_space_result = disk_usage(\u0026artifact_storage);\n    if disk_space_result.is_err() {\n        return Err(warp::reject::custom(RegistryError {\n            code: RegistryErrorCode::Unknown(disk_space_result.err().unwrap().to_string()),\n        }));\n    }\n\n    let cli_config = get_config();\n    if cli_config.is_err() {\n        return Err(warp::reject::custom(RegistryError {\n            code: RegistryErrorCode::Unknown(cli_config.err().unwrap().to_string()),\n        }));\n    }\n    let mut total_artifacts = 0;\n    let mut art_summ_map: HashMap\u003cString, usize\u003e = HashMap::new();\n    for (k, v) in art_count_result.unwrap().iter() {\n        if k == \"SHA256\" {\n            total_artifacts += v;\n            art_summ_map.insert(\"blobs\".to_string(), *v);\n        } else if k == \"SHA512\" {\n            total_artifacts += v;\n            art_summ_map.insert(\"manifests\".to_string(), *v);\n        }\n    }\n    let artifacts_summary = ArtifactsSummary {\n        total: total_artifacts.to_string(),\n        summary: art_summ_map,\n    };\n\n    let status = Status {\n        artifact_count: artifacts_summary,\n        peers_count: peers.len(),\n        peer_id: p2p_client.local_peer_id.to_string(),\n        disk_allocated: cli_config.unwrap().disk_allocated,\n        disk_usage: format!(\"{:.4}\", disk_space_result.unwrap()),\n    };\n\n    let status_as_json = serde_json::to_string(\u0026status).unwrap();\n\n    Ok(warp::http::response::Builder::new()\n        .header(\"Content-Type\", \"application/json\")\n        .status(StatusCode::OK)\n        .body(status_as_json)\n        .unwrap())\n}\n","traces":[{"line":27,"address":[4833585,4833568],"length":1,"stats":{"Line":0},"fn_name":"handle_get_peers"},{"line":41,"address":[4833648],"length":1,"stats":{"Line":0},"fn_name":"handle_get_status"}],"covered":0,"coverable":2},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","node_api","handlers.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod swarm;\npub use crate::cli_commands::config::*;\npub use crate::docker::error_util::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","node_api","model","cli.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct Status {\n    pub peers_count: usize,\n    pub peer_id: String,\n    pub artifact_count: ArtifactsSummary,\n    pub disk_allocated: String,\n    pub disk_usage: String,\n}\n\n#[derive(Debug, Deserialize, Serialize)]\npub struct ArtifactsSummary {\n    pub total: String,\n    pub summary: HashMap\u003cString, usize\u003e,\n}\n\nimpl std::fmt::Display for Status {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        writeln!(f, \"Connected Peers Count:       {}\", self.peers_count)?;\n        writeln!(f, \"Artifacts Count:             {}\", self.artifact_count)?;\n        writeln!(f, \"Total Disk Space Allocated:  {}\", self.disk_allocated)?;\n        write!(f, \"Disk Space Used:             {}%\", self.disk_usage)\n    }\n}\n\nimpl std::fmt::Display for ArtifactsSummary {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter) -\u003e std::fmt::Result {\n        write!(f, \"{} {:?}\", self.total, self.summary)\n    }\n}\n","traces":[{"line":36,"address":[5757216],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":37,"address":[5757249,5757413],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[5757392,5757610,5757459],"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":[5757588,5757644,5757798],"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":[5757773,5757832],"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":[5757920],"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":46,"address":[5757953],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":7},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","node_api","model.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod cli;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","node_api","routes.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse super::handlers::swarm::*;\nuse crate::artifact_service::storage::ArtifactStorage;\nuse crate::network::client::Client;\nuse warp::Filter;\n\npub fn make_node_routes(\n    p2p_client: Client,\n    artifact_storage: ArtifactStorage,\n) -\u003e impl Filter\u003cExtract = impl warp::Reply, Error = warp::Rejection\u003e + Clone {\n    let p2p_client_peers = p2p_client.clone();\n\n    let peers = warp::path!(\"peers\")\n        .and(warp::get())\n        .and(warp::path::end())\n        .and_then(move || handle_get_peers(p2p_client_peers.clone()));\n\n    let status = warp::path!(\"status\")\n        .and(warp::get())\n        .and(warp::path::end())\n        .and_then(move || handle_get_status(p2p_client.clone(), artifact_storage.clone()));\n\n    warp::any().and(peers.or(status))\n}\n","traces":[{"line":22,"address":[5746295,5745248],"length":1,"stats":{"Line":0},"fn_name":"make_node_routes"},{"line":26,"address":[5745270],"length":1,"stats":{"Line":0},"fn_name":null},{"line":28,"address":[5745382,5745481,5745427,5745606,5745330,5745463],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[5745452],"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":[5745470],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[5745613,5745488],"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":[5745716,5745621,5745734,5745853,5745680],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[5745705],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[5745723],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[5745746,5745860],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[5746200,5745868],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":11},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","node_api.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod handlers;\npub mod model;\npub mod routes;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","node_manager.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod handlers;\npub mod model;\n\npub use crate::artifacts_repository::artifact_manager::*;\npub use crate::artifacts_repository::hash_util::*;\npub use crate::cli_commands::*;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","transparency_log","log.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::util::env_util::read_var;\nuse log::debug;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::fs;\nuse std::io::{self, Write};\nuse std::time::{SystemTime, UNIX_EPOCH};\nuse thiserror::Error;\n\n#[derive(Debug, Clone, Error, PartialEq)]\npub enum TransparencyLogError {\n    #[error(\"Duplicate ID {id:?} in transparency log\")]\n    DuplicateId { id: String },\n    #[error(\"ID {id:?} not found in transparency log\")]\n    NotFound { id: String },\n    #[error(\"Hash Verification failed for ID {id:?}: {invalid_hash:?} vs {actual_hash:?}\")]\n    InvalidHash {\n        id: String,\n        invalid_hash: String,\n        actual_hash: String,\n    },\n}\n\n#[derive(Debug, Clone, strum_macros::Display, Deserialize, Serialize, PartialEq)]\npub enum Operation {\n    AddArtifact,\n}\n\n#[derive(Debug, Clone, Deserialize, Serialize)]\npub struct Payload {\n    id: String,\n    hash: String,\n    timestamp: u64,\n    operation: Operation,\n}\n\n#[derive(Serialize, Deserialize, Debug, Clone)]\npub struct SignatureEnvelope {\n    /// The data that is integrity protected\n    payload: Payload,\n    /// The time at which the signature was generated. This is a part of signed attributes\n    signing_timestamp: u64,\n    /// The digital signature computed on payload and signed attributes\n    signature: Vec\u003cu8\u003e,\n    /// the public key of the signer\n    sign_identifier: [u8; 32], //this is identity::ed25519::PublicKey(a byte array in compressed form\n}\n\n#[derive(Clone)]\npub struct TransparencyLog {\n    payloads: HashMap\u003cString, Payload\u003e,\n}\n\nimpl TransparencyLog {\n    pub fn new() -\u003e Self {\n        TransparencyLog {\n            payloads: HashMap::new(),\n        }\n    }\n\n    pub fn add_artifact(\u0026mut self, id: \u0026str, hash: \u0026str) -\u003e anyhow::Result\u003c()\u003e {\n        let payload = Payload {\n            id: id.to_string(),\n            hash: hash.to_string(),\n            timestamp: SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            operation: Operation::AddArtifact,\n        };\n\n        write_payload(\u0026payload)?;\n        self.payloads.insert(id.into(), payload);\n\n        Ok(())\n    }\n\n    pub fn verify_artifact(\u0026mut self, id: \u0026str, hash: \u0026str) -\u003e Result\u003c(), TransparencyLogError\u003e {\n        if let Some(payload) = self.payloads.get(id) {\n            if payload.hash == hash {\n                Ok(())\n            } else {\n                Err(TransparencyLogError::InvalidHash {\n                    id: String::from(id),\n                    invalid_hash: String::from(hash),\n                    actual_hash: payload.hash.clone(),\n                })\n            }\n        } else {\n            Err(TransparencyLogError::NotFound {\n                id: String::from(id),\n            })\n        }\n    }\n\n    pub fn get_artifact(\u0026mut self, namespace_specific_id: \u0026str) -\u003e anyhow::Result\u003cString\u003e {\n        if let Some(payload) = self.payloads.get(namespace_specific_id) {\n            return Ok(String::from(\u0026payload.hash));\n        }\n\n        anyhow::bail!(\"No payload found with specified ID\");\n    }\n}\n\nfn write_payload(payload: \u0026Payload) -\u003e anyhow::Result\u003c()\u003e {\n    let payload_storage_path = get_payload_storage_path();\n    fs::create_dir_all(\u0026payload_storage_path)?;\n    let payload_filename = format!(\n        \"{}/{}.log\",\n        payload_storage_path,\n        str::replace(\u0026payload.id, \"/\", \"_\")\n    );\n    debug!(\n        \"Storing transparency log payload at: {:?}\",\n        payload_filename\n    );\n    match fs::File::options()\n        .write(true)\n        .create_new(true)\n        .open(\u0026payload_filename)\n    {\n        Ok(mut payload_file) =\u003e {\n            let json_payload = serde_json::to_string(payload)?;\n            payload_file.write_all(json_payload.as_bytes())?;\n            Ok(())\n        }\n        Err(e) =\u003e match e.kind() {\n            io::ErrorKind::AlreadyExists =\u003e Err(TransparencyLogError::DuplicateId {\n                id: payload.id.clone(),\n            }\n            .into()),\n            _ =\u003e Err(e.into()),\n        },\n    }\n}\n\nfn get_payload_storage_path() -\u003e String {\n    format!(\n        \"{}/{}\",\n        read_var(\"PYRSIA_ARTIFACT_PATH\", \"pyrsia\"),\n        \"transparency_log\"\n    )\n}\n\nimpl Default for TransparencyLog {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::util::test_util;\n    use assay::assay;\n\n    #[test]\n    fn create_payload() {\n        let id = \"id\";\n        let hash = \"hash\";\n        let timestamp = 1234567890;\n        let operation = Operation::AddArtifact;\n        let payload = Payload {\n            id: id.to_string(),\n            hash: hash.to_string(),\n            timestamp,\n            operation: Operation::AddArtifact,\n        };\n\n        assert_eq!(payload.id, id);\n        assert_eq!(payload.hash, hash);\n        assert_eq!(payload.timestamp, timestamp);\n        assert_eq!(payload.operation, operation);\n    }\n\n    #[assay(\n        env = [\n            (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-transparency-log\"),\n            (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    fn test_new_transparency_log_has_empty_payload() {\n        let log = TransparencyLog::new();\n\n        assert_eq!(log.payloads.len(), 0);\n    }\n\n    #[assay(\n        env = [\n            (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-transparency-log\"),\n            (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    fn test_with_default() {\n        let log: TransparencyLog = Default::default();\n\n        assert_eq!(log.payloads.len(), 0);\n    }\n\n    #[assay(\n        env = [\n            (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-transparency-log\"),\n            (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    fn test_add_artifact() {\n        let mut log = TransparencyLog::new();\n\n        let result = log.add_artifact(\"id\", \"hash\");\n        assert!(result.is_ok());\n\n        assert!(log.payloads.contains_key(\"id\"));\n    }\n\n    #[assay(\n        env = [\n            (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-transparency-log\"),\n            (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    fn test_add_artifact_with_id_containing_forward_slash() {\n        let mut log = TransparencyLog::new();\n\n        let result = log.add_artifact(\"id/with/slash\", \"hash\");\n        assert!(result.is_ok());\n\n        assert!(log.payloads.contains_key(\"id/with/slash\"));\n    }\n\n    #[assay(\n        env = [\n            (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-transparency-log\"),\n            (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    fn test_add_duplicate_artifact() {\n        let mut log = TransparencyLog::new();\n\n        let result = log.add_artifact(\"id\", \"hash\");\n        assert!(result.is_ok());\n\n        let result = log.add_artifact(\"id\", \"hash2\");\n        assert!(result.is_err());\n    }\n\n    #[assay(\n        env = [\n            (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-transparency-log\"),\n            (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    fn test_verify_artifact() {\n        let mut log = TransparencyLog::new();\n\n        log.add_artifact(\"id\", \"hash\")\n            .expect(\"Adding artifact failed.\");\n\n        let result = log.verify_artifact(\"id\", \"hash\");\n        assert!(result.is_ok());\n    }\n\n    #[assay(\n        env = [\n            (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-transparency-log\"),\n            (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    fn test_verify_unknown_artifact() {\n        let mut log = TransparencyLog::new();\n\n        let result = log.verify_artifact(\"id\", \"hash\");\n        assert!(result.is_err());\n        assert_eq!(\n            result,\n            Err(TransparencyLogError::NotFound {\n                id: String::from(\"id\")\n            })\n        );\n    }\n\n    #[assay(\n        env = [\n            (\"PYRSIA_ARTIFACT_PATH\", \"pyrsia-test-transparency-log\"),\n            (\"DEV_MODE\", \"on\")\n        ],\n        teardown = test_util::tear_down()\n    )]\n    fn test_verify_artifact_with_invalid_hash() {\n        let mut log = TransparencyLog::new();\n\n        log.add_artifact(\"id\", \"hash\")\n            .expect(\"Adding artifact failed.\");\n\n        let result = log.verify_artifact(\"id\", \"invalid_hash\");\n        assert!(result.is_err());\n        assert_eq!(\n            result,\n            Err(TransparencyLogError::InvalidHash {\n                id: String::from(\"id\"),\n                invalid_hash: String::from(\"invalid_hash\"),\n                actual_hash: String::from(\"hash\"),\n            })\n        );\n    }\n}\n","traces":[{"line":63,"address":[6922512],"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":65,"address":[6922526],"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":[6923034,6922576],"length":1,"stats":{"Line":0},"fn_name":"add_artifact"},{"line":71,"address":[6922656],"length":1,"stats":{"Line":0},"fn_name":null},{"line":72,"address":[6922687],"length":1,"stats":{"Line":0},"fn_name":null},{"line":73,"address":[6922861,6922694,6922766],"length":1,"stats":{"Line":0},"fn_name":null},{"line":80,"address":[6923049,6923301,6923027,6923110,6923236],"length":1,"stats":{"Line":0},"fn_name":null},{"line":81,"address":[6923229,6923346,6923454],"length":1,"stats":{"Line":0},"fn_name":null},{"line":83,"address":[6923473],"length":1,"stats":{"Line":0},"fn_name":null},{"line":86,"address":[6923536],"length":1,"stats":{"Line":0},"fn_name":"get_artifact"},{"line":87,"address":[6923616],"length":1,"stats":{"Line":0},"fn_name":null},{"line":88,"address":[6923786,6924003,6923662],"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":[6923900],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[6923679],"length":1,"stats":{"Line":0},"fn_name":null},{"line":96,"address":[6925426,6924048],"length":1,"stats":{"Line":0},"fn_name":"write_payload"},{"line":97,"address":[6924087],"length":1,"stats":{"Line":0},"fn_name":null},{"line":98,"address":[6924116,6924329,6924283,6924207],"length":1,"stats":{"Line":0},"fn_name":null},{"line":99,"address":[6924240,6924500,6924800],"length":1,"stats":{"Line":0},"fn_name":null},{"line":102,"address":[6924412],"length":1,"stats":{"Line":0},"fn_name":null},{"line":104,"address":[6924848,6924895,6924986,6924759,6925077],"length":1,"stats":{"Line":0},"fn_name":null},{"line":108,"address":[6925050,6925441,6925251],"length":1,"stats":{"Line":0},"fn_name":null},{"line":113,"address":[6925451],"length":1,"stats":{"Line":0},"fn_name":null},{"line":114,"address":[6925473,6925887,6926083,6925935,6926051],"length":1,"stats":{"Line":0},"fn_name":null},{"line":115,"address":[6926212,6926142,6926367,6926026,6926419],"length":1,"stats":{"Line":0},"fn_name":null},{"line":116,"address":[6926274],"length":1,"stats":{"Line":0},"fn_name":null},{"line":118,"address":[6925483],"length":1,"stats":{"Line":0},"fn_name":null},{"line":119,"address":[6925685],"length":1,"stats":{"Line":0},"fn_name":null},{"line":120,"address":[6925602],"length":1,"stats":{"Line":0},"fn_name":null},{"line":122,"address":[6925761],"length":1,"stats":{"Line":0},"fn_name":null},{"line":123,"address":[6925621],"length":1,"stats":{"Line":0},"fn_name":null},{"line":128,"address":[6926560,6926850],"length":1,"stats":{"Line":0},"fn_name":"get_payload_storage_path"},{"line":129,"address":[6926883,6926615],"length":1,"stats":{"Line":0},"fn_name":null},{"line":131,"address":[6926577],"length":1,"stats":{"Line":0},"fn_name":null},{"line":137,"address":[6926928],"length":1,"stats":{"Line":0},"fn_name":"default"},{"line":138,"address":[6926936],"length":1,"stats":{"Line":0},"fn_name":null},{"line":149,"address":[6628885,6628880],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":150,"address":[5194087],"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":[5194108],"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":[5194129],"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":[5194141],"length":1,"stats":{"Line":1},"fn_name":null},{"line":156,"address":[5194164],"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":[5194277,5194545,5194408],"length":1,"stats":{"Line":2},"fn_name":null},{"line":162,"address":[5194710,5194595,5194453],"length":1,"stats":{"Line":2},"fn_name":null},{"line":163,"address":[5194601,5194852],"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":[5194907,5194765,5194938],"length":1,"stats":{"Line":2},"fn_name":null},{"line":167,"address":[6630025,6628959,6628917,6629229,6630016,6629175,6629963,6628944,6629994,6628912],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":172,"address":[6629956],"length":1,"stats":{"Line":0},"fn_name":null},{"line":174,"address":[5195008],"length":1,"stats":{"Line":1},"fn_name":"test_new_transparency_log_has_empty_payload"},{"line":175,"address":[6629309],"length":1,"stats":{"Line":0},"fn_name":null},{"line":177,"address":[6629497,6629324],"length":1,"stats":{"Line":0},"fn_name":null},{"line":180,"address":[5197141,5196654,5196218,5196330,5196877,5196951,5196782,5196559,5196509,5196944,5196768,5196752,5196251,5196103,5197066],"length":1,"stats":{"Line":11},"fn_name":"modify"},{"line":185,"address":[6631124],"length":1,"stats":{"Line":0},"fn_name":null},{"line":187,"address":[5196096],"length":1,"stats":{"Line":1},"fn_name":"test_with_default"},{"line":188,"address":[6630477],"length":1,"stats":{"Line":0},"fn_name":null},{"line":190,"address":[6630492,6630665],"length":1,"stats":{"Line":0},"fn_name":null},{"line":193,"address":[6631910,6631280,6631253,6631952,6631295,6631478,6631935,6631961,6631248,6631520],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":198,"address":[6631903],"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":[5197184],"length":1,"stats":{"Line":1},"fn_name":"test_add_artifact"},{"line":201,"address":[6631597],"length":1,"stats":{"Line":0},"fn_name":null},{"line":203,"address":[6631604],"length":1,"stats":{"Line":0},"fn_name":null},{"line":204,"address":[6631801,6631670,6631725],"length":1,"stats":{"Line":0},"fn_name":null},{"line":206,"address":[6631858,6631770,6631837],"length":1,"stats":{"Line":0},"fn_name":null},{"line":209,"address":[5199242,5199127,5198944,5198830,5198685,5198735,5199053,5198394,5198958,5199317,5198427,5198928,5198279,5199120,5198506],"length":1,"stats":{"Line":11},"fn_name":"modify"},{"line":214,"address":[6632671],"length":1,"stats":{"Line":0},"fn_name":null},{"line":216,"address":[5198272],"length":1,"stats":{"Line":1},"fn_name":"test_add_artifact_with_id_containing_forward_slash"},{"line":217,"address":[6632365],"length":1,"stats":{"Line":0},"fn_name":null},{"line":219,"address":[6632372],"length":1,"stats":{"Line":0},"fn_name":null},{"line":220,"address":[6632438,6632569,6632493],"length":1,"stats":{"Line":0},"fn_name":null},{"line":222,"address":[6632626,6632605,6632538],"length":1,"stats":{"Line":0},"fn_name":null},{"line":225,"address":[5199918,5200046,5199482,5200032,5199367,5200016,5199823,5200405,5200215,5200141,5200208,5199515,5199594,5200330,5199773],"length":1,"stats":{"Line":11},"fn_name":"modify"},{"line":230,"address":[6633548],"length":1,"stats":{"Line":0},"fn_name":null},{"line":232,"address":[5199360],"length":1,"stats":{"Line":1},"fn_name":"test_add_duplicate_artifact"},{"line":233,"address":[6633136],"length":1,"stats":{"Line":0},"fn_name":null},{"line":235,"address":[6633143],"length":1,"stats":{"Line":0},"fn_name":null},{"line":236,"address":[6633354,6633209,6633264],"length":1,"stats":{"Line":0},"fn_name":null},{"line":238,"address":[6633309,6633391],"length":1,"stats":{"Line":0},"fn_name":null},{"line":239,"address":[6633485,6633407],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":20,"coverable":77},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","transparency_log.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod log;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","util","env_util.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse std::env;\n\npub fn read_var(variable_name: \u0026str, default_value: \u0026str) -\u003e String {\n    match env::var(variable_name) {\n        Ok(v) =\u003e {\n            let tr = v.trim();\n            if !tr.is_empty() {\n                String::from(tr)\n            } else {\n                String::from(default_value)\n            }\n        }\n        Err(_err) =\u003e String::from(default_value),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use assay::assay;\n\n    #[assay(\n        env = [\n          (\"DEV_MODE\", \"on\")\n        ],)]\n    fn test_value_present() {\n        assert_eq!(\"on\", read_var(\"DEV_MODE\", \"off\"));\n    }\n\n    #[assay(\n        env = [\n          (\"DEV_MODE\", \"on \")\n        ],)]\n    fn test_value_present_trim() {\n        assert_eq!(\"on\", read_var(\"DEV_MODE\", \"off\"));\n    }\n\n    #[assay(\n        env = [\n            (\"DEV_MODE\", \"\")\n        ],)]\n    fn test_value_empty() {\n        assert_eq!(\"off\", read_var(\"DEV_MODE\", \"off\"));\n    }\n\n    #[assay]\n    fn test_value_absent() {\n        assert_eq!(\"absent\", read_var(\"DEV_MODE\", \"absent\"));\n    }\n}\n","traces":[{"line":19,"address":[7114002,7113760],"length":1,"stats":{"Line":0},"fn_name":"read_var"},{"line":20,"address":[7113819],"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":[7113846],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[7114040,7113880,7114105],"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":[7114137],"length":1,"stats":{"Line":0},"fn_name":null},{"line":24,"address":[7114195],"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[7114173,7114223],"length":1,"stats":{"Line":0},"fn_name":null},{"line":29,"address":[7113915],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[7258583,7259344,7258367,7259401,7258352,7259392,7258325,7258320,7259375],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":42,"address":[8098016],"length":1,"stats":{"Line":1},"fn_name":"test_value_present"},{"line":43,"address":[7258718,7258637],"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":[7259488,7259461,7259456,7260480,7259719,7259503,7260537,7260528,7260511],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":50,"address":[8099104],"length":1,"stats":{"Line":1},"fn_name":"test_value_present_trim"},{"line":51,"address":[7259773,7259854],"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":[7261664,7261673,7260639,7260597,7260854,7260592,7261615,7261646,7260624],"length":1,"stats":{"Line":11},"fn_name":"{closure#0}"},{"line":58,"address":[8100192],"length":1,"stats":{"Line":1},"fn_name":"test_value_empty"},{"line":59,"address":[7260989,7260908],"length":1,"stats":{"Line":0},"fn_name":null},{"line":62,"address":[7261733,7262718,7261760,7262138,7261728,7261775,7262777,7262768,7261968],"length":1,"stats":{"Line":7},"fn_name":"{closure#0}"},{"line":63,"address":[8101280],"length":1,"stats":{"Line":1},"fn_name":"test_value_absent"},{"line":64,"address":[7261928,7262054,7262183],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":8,"coverable":20},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","util","keypair_util.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse crate::util::env_util::read_var;\n\nuse libp2p::identity;\nuse log::warn;\nuse std::error;\nuse std::fs;\nuse std::io::{self, Read, Write};\n\nconst KEYPAIR_FILENAME: \u0026str = \"p2p_keypair.ser\";\n\n/// Load a ed25519 keypair from disk. If a keypair file does not yet exist,\n/// a new keypair is generated and then saved to disk.\npub fn load_or_generate_ed25519() -\u003e identity::Keypair {\n    let keypair_path = get_keypair_path();\n    match load_ed25519(\u0026keypair_path) {\n        Ok(keypair) =\u003e identity::Keypair::Ed25519(keypair),\n        Err(_) =\u003e {\n            let keypair = identity::ed25519::Keypair::generate();\n            if let Err(e) = save_ed25519(\u0026keypair, \u0026keypair_path) {\n                warn!(\"Failed to persist newly generated keypair: {:?}\", e);\n            }\n            identity::Keypair::Ed25519(keypair)\n        }\n    }\n}\n\n// Load a keypair from the specified path. It only returns a Keypair if all\n// the following conditions are met:\n//\n//  * the file at the specified path exists\n//  * the size of the file is exactly 64 bytes\n//  * no io errors occured while reading from the file\nfn load_ed25519(keypair_path: \u0026str) -\u003e Result\u003cidentity::ed25519::Keypair, Box\u003cdyn error::Error\u003e\u003e {\n    let mut keypair_file = fs::File::open(keypair_path)?;\n    let keypair_metadata = fs::metadata(keypair_path)?;\n    if keypair_metadata.len() == 64 {\n        let mut buffer = vec![0; 64];\n        keypair_file.read_exact(\u0026mut buffer)?;\n        return Ok(identity::ed25519::Keypair::decode(\u0026mut buffer)?);\n    }\n\n    Err(Box::new(io::Error::from(io::ErrorKind::InvalidData)))\n}\n\n// Save the provided keypair to the specified path.\nfn save_ed25519(\n    keypair: \u0026identity::ed25519::Keypair,\n    keypair_path: \u0026str,\n) -\u003e Result\u003c(), Box\u003cdyn error::Error\u003e\u003e {\n    let mut keypair_file = fs::File::create(\u0026keypair_path)?;\n    keypair_file.write_all(\u0026keypair.encode())?;\n    Ok(())\n}\n\n// Get the path on disk where the keypair is stored.\nfn get_keypair_path() -\u003e String {\n    format!(\n        \"{}/{}\",\n        read_var(\"PYRSIA_ARTIFACT_PATH\", \"pyrsia\"),\n        KEYPAIR_FILENAME\n    )\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn load_non_existing_keypair_fails() {\n        let tmp_dir = tempfile::tempdir().unwrap();\n        let path = tmp_dir\n            .path()\n            .join(\"load_non_existing_keypair_fails\")\n            .join(KEYPAIR_FILENAME);\n\n        let keypair = load_ed25519(path.to_str().unwrap());\n        assert!(keypair.is_err());\n    }\n\n    #[test]\n    fn load_existing_keypair_with_wrong_size_fails() {\n        let tmp_file = tempfile::Builder::new().tempfile().unwrap();\n        tmp_file.as_file().write_all(\u0026vec![1; 32]).unwrap();\n\n        let keypair = load_ed25519(tmp_file.path().to_str().unwrap());\n        assert!(keypair.is_err());\n    }\n\n    #[test]\n    fn load_existing_keypair_succeeds() {\n        let tmp_file = tempfile::Builder::new().tempfile().unwrap();\n        tmp_file.as_file().write_all(\u0026vec![1; 64]).unwrap();\n\n        let keypair = load_ed25519(tmp_file.path().to_str().unwrap());\n        assert!(keypair.is_ok());\n    }\n\n    #[test]\n    fn saved_keypair_can_be_loaded() {\n        let tmp_file = tempfile::Builder::new().tempfile().unwrap();\n\n        let saved_keypair = identity::ed25519::Keypair::generate();\n        let save_result = save_ed25519(\u0026saved_keypair, tmp_file.path().to_str().unwrap());\n        assert!(save_result.is_ok());\n\n        let loaded_keypair = load_ed25519(tmp_file.path().to_str().unwrap()).unwrap();\n        assert_eq!(saved_keypair.encode(), loaded_keypair.encode());\n    }\n}\n","traces":[{"line":29,"address":[7350214,7350080],"length":1,"stats":{"Line":0},"fn_name":"load_or_generate_ed25519"},{"line":30,"address":[7350097],"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":[7350197,7350120,7350229],"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":[7350231],"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":[7350330],"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":[7350427,7350354,7350492],"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":[7350706,7350782,7350582,7350870,7350659],"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":[7351064],"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":[7352762,7351264],"length":1,"stats":{"Line":1},"fn_name":"load_ed25519"},{"line":50,"address":[7351341,7351553],"length":1,"stats":{"Line":2},"fn_name":null},{"line":51,"address":[7351816,7351693,7351599,7351526,7351848],"length":1,"stats":{"Line":3},"fn_name":null},{"line":52,"address":[7351899,7351792],"length":1,"stats":{"Line":2},"fn_name":null},{"line":53,"address":[7351905],"length":1,"stats":{"Line":1},"fn_name":null},{"line":54,"address":[7352253,7352344,7352144,7352376],"length":1,"stats":{"Line":2},"fn_name":null},{"line":55,"address":[7352435,7352307],"length":1,"stats":{"Line":2},"fn_name":null},{"line":58,"address":[7352103,7351934],"length":1,"stats":{"Line":2},"fn_name":null},{"line":62,"address":[7353286,7352784],"length":1,"stats":{"Line":1},"fn_name":"save_ed25519"},{"line":66,"address":[7352981,7352819],"length":1,"stats":{"Line":1},"fn_name":null},{"line":67,"address":[7353186,7353259,7352962,7353113,7353036],"length":1,"stats":{"Line":3},"fn_name":null},{"line":68,"address":[7353161],"length":1,"stats":{"Line":1},"fn_name":null},{"line":72,"address":[7353602,7353312],"length":1,"stats":{"Line":0},"fn_name":"get_keypair_path"},{"line":73,"address":[7353635,7353367],"length":1,"stats":{"Line":0},"fn_name":null},{"line":75,"address":[7353329],"length":1,"stats":{"Line":0},"fn_name":null},{"line":85,"address":[5664421,5664416],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":86,"address":[7329335],"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":[7329373,7329487],"length":1,"stats":{"Line":2},"fn_name":null},{"line":90,"address":[7329546],"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":[7329679,7329611],"length":1,"stats":{"Line":2},"fn_name":null},{"line":93,"address":[7329845,7329767],"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":[5664453,5664448],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":98,"address":[7329943],"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":[7329998,7330099],"length":1,"stats":{"Line":2},"fn_name":null},{"line":101,"address":[7330247],"length":1,"stats":{"Line":1},"fn_name":null},{"line":102,"address":[7330440,7330362],"length":1,"stats":{"Line":1},"fn_name":null},{"line":106,"address":[7330512,7331061],"length":1,"stats":{"Line":3},"fn_name":"load_existing_keypair_succeeds"},{"line":107,"address":[7330519],"length":1,"stats":{"Line":1},"fn_name":null},{"line":108,"address":[7330574,7330675],"length":1,"stats":{"Line":2},"fn_name":null},{"line":110,"address":[7330823],"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":[7330938,7331016],"length":1,"stats":{"Line":1},"fn_name":null},{"line":115,"address":[5664517,5664512],"length":1,"stats":{"Line":3},"fn_name":"{closure#0}"},{"line":116,"address":[7331095],"length":1,"stats":{"Line":1},"fn_name":null},{"line":118,"address":[7331159],"length":1,"stats":{"Line":1},"fn_name":null},{"line":119,"address":[7331186,7331331,7331266],"length":1,"stats":{"Line":3},"fn_name":null},{"line":120,"address":[7331516,7331428],"length":1,"stats":{"Line":1},"fn_name":null},{"line":122,"address":[7331558,7331499],"length":1,"stats":{"Line":2},"fn_name":null},{"line":123,"address":[7331771,7331668,7331889],"length":1,"stats":{"Line":2},"fn_name":null}],"covered":34,"coverable":46},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","util","test_util.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n#[cfg(test)]\npub fn tear_down() {\n    if std::path::Path::new(\u0026std::env::var(\"PYRSIA_ARTIFACT_PATH\").unwrap()).exists() {\n        std::fs::remove_dir_all(std::env::var(\"PYRSIA_ARTIFACT_PATH\").unwrap()).expect(\u0026format!(\n            \"unable to remove test directory {}\",\n            std::env::var(\"PYRSIA_ARTIFACT_PATH\").unwrap()\n        ));\n    }\n}\n","traces":[{"line":18,"address":[4604448,4604603],"length":1,"stats":{"Line":0},"fn_name":"tear_down"},{"line":19,"address":[4604622,4604455],"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":[4604636,4604809],"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":[4604710],"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":4},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","src","util.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npub mod env_util;\npub mod keypair_util;\npub mod test_util;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","joeri","devel","github","tiainen","pyrsia","tests","string_manipulation","src","lib.rs"],"content":"/*\n   Copyright 2021 JFrog Ltd\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\nuse std::io::BufRead;\n\n// Reads the first line from a BufRead\npub fn first_line\u003cR\u003e(mut rdr: R) -\u003e String\nwhere\n    R: BufRead,\n{\n    let mut first_line: String = String::new();\n    rdr.read_line(\u0026mut first_line).expect(\"Unable to read line\");\n    first_line\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":25,"address":[],"length":0,"stats":{"Line":0},"fn_name":null},{"line":26,"address":[],"length":0,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":3}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>